"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-hook-form";
exports.ids = ["vendor-chunks/react-hook-form"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/react-hook-form/dist/index.esm.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   FormProvider: () => (/* binding */ FormProvider),\n/* harmony export */   appendErrors: () => (/* binding */ appendErrors),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   useController: () => (/* binding */ useController),\n/* harmony export */   useFieldArray: () => (/* binding */ useFieldArray),\n/* harmony export */   useForm: () => (/* binding */ useForm),\n/* harmony export */   useFormContext: () => (/* binding */ useFormContext),\n/* harmony export */   useFormState: () => (/* binding */ useFormState),\n/* harmony export */   useWatch: () => (/* binding */ useWatch)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar isCheckBoxInput = (element)=>element.type === \"checkbox\";\nvar isDateObject = (value1)=>value1 instanceof Date;\nvar isNullOrUndefined = (value1)=>value1 == null;\nconst isObjectType = (value1)=>typeof value1 === \"object\";\nvar isObject = (value1)=>!isNullOrUndefined(value1) && !Array.isArray(value1) && isObjectType(value1) && !isDateObject(value1);\nvar getEventValue = (event)=>isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\nvar getNodeParentName = (name)=>name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\nvar isNameInFieldArray = (names, name)=>names.has(getNodeParentName(name));\nvar isPlainObject = (tempObject)=>{\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\n    return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty(\"isPrototypeOf\");\n};\nvar isWeb =  false && 0;\nfunction cloneObject(data) {\n    let copy;\n    const isArray = Array.isArray(data);\n    if (data instanceof Date) {\n        copy = new Date(data);\n    } else if (data instanceof Set) {\n        copy = new Set(data);\n    } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray || isObject(data))) {\n        copy = isArray ? [] : {};\n        if (!isArray && !isPlainObject(data)) {\n            copy = data;\n        } else {\n            for(const key in data){\n                if (data.hasOwnProperty(key)) {\n                    copy[key] = cloneObject(data[key]);\n                }\n            }\n        }\n    } else {\n        return data;\n    }\n    return copy;\n}\nvar compact = (value1)=>Array.isArray(value1) ? value1.filter(Boolean) : [];\nvar isUndefined = (val)=>val === undefined;\nvar get = (object, path, defaultValue)=>{\n    if (!path || !isObject(object)) {\n        return defaultValue;\n    }\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key)=>isNullOrUndefined(result) ? result : result[key], object);\n    return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;\n};\nvar isBoolean = (value1)=>typeof value1 === \"boolean\";\nvar isKey = (value1)=>/^\\w*$/.test(value1);\nvar stringToPath = (input)=>compact(input.replace(/[\"|']|\\]/g, \"\").split(/\\.|\\[/));\nvar set = (object, path, value1)=>{\n    let index = -1;\n    const tempPath = isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const length = tempPath.length;\n    const lastIndex = length - 1;\n    while(++index < length){\n        const key = tempPath[index];\n        let newValue = value1;\n        if (index !== lastIndex) {\n            const objValue = object[key];\n            newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n        }\n        if (key === \"__proto__\") {\n            return;\n        }\n        object[key] = newValue;\n        object = object[key];\n    }\n    return object;\n};\nconst EVENTS = {\n    BLUR: \"blur\",\n    FOCUS_OUT: \"focusout\",\n    CHANGE: \"change\"\n};\nconst VALIDATION_MODE = {\n    onBlur: \"onBlur\",\n    onChange: \"onChange\",\n    onSubmit: \"onSubmit\",\n    onTouched: \"onTouched\",\n    all: \"all\"\n};\nconst INPUT_VALIDATION_RULES = {\n    max: \"max\",\n    min: \"min\",\n    maxLength: \"maxLength\",\n    minLength: \"minLength\",\n    pattern: \"pattern\",\n    required: \"required\",\n    validate: \"validate\"\n};\nconst HookFormContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @returns return all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const useFormContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormContext);\n/**\n * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @param props - all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const FormProvider = (props)=>{\n    const { children, ...data } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormContext.Provider, {\n        value: data\n    }, children);\n};\nvar getProxyFormState = (formState, control, localProxyFormState, isRoot = true)=>{\n    const result = {\n        defaultValues: control._defaultValues\n    };\n    for(const key in formState){\n        Object.defineProperty(result, key, {\n            get: ()=>{\n                const _key = key;\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\n                }\n                localProxyFormState && (localProxyFormState[_key] = true);\n                return formState[_key];\n            }\n        });\n    }\n    return result;\n};\nvar isEmptyObject = (value1)=>isObject(value1) && !Object.keys(value1).length;\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot)=>{\n    updateFormState(formStateData);\n    const { name, ...formState } = formStateData;\n    return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key)=>_proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));\n};\nvar convertToArrayPayload = (value1)=>Array.isArray(value1) ? value1 : [\n        value1\n    ];\nvar shouldSubscribeByName = (name, signalName, exact)=>!name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName)=>currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));\nfunction useSubscribe(props) {\n    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n    _props.current = props;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({\n            next: _props.current.next\n        });\n        return ()=>{\n            subscription && subscription.unsubscribe();\n        };\n    }, [\n        props.disabled\n    ]);\n}\n/**\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\n *\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, control } = useForm({\n *     defaultValues: {\n *     firstName: \"firstName\"\n *   }});\n *   const { dirtyFields } = useFormState({\n *     control\n *   });\n *   const onSubmit = (data) => console.log(data);\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFormState(props) {\n    const methods = useFormContext();\n    const { control = methods.control, disabled, name, exact } = props || {};\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._formState);\n    const _mounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        isDirty: false,\n        isLoading: false,\n        dirtyFields: false,\n        touchedFields: false,\n        validatingFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    });\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    _name.current = name;\n    useSubscribe({\n        disabled,\n        next: (value1)=>_mounted.current && shouldSubscribeByName(_name.current, value1.name, exact) && shouldRenderFormState(value1, _localProxyFormState.current, control._updateFormState) && updateFormState({\n                ...control._formState,\n                ...value1\n            }),\n        subject: control._subjects.state\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        _mounted.current = true;\n        _localProxyFormState.current.isValid && control._updateValid(true);\n        return ()=>{\n            _mounted.current = false;\n        };\n    }, [\n        control\n    ]);\n    return getProxyFormState(formState, control, _localProxyFormState.current, false);\n}\nvar isString = (value1)=>typeof value1 === \"string\";\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue)=>{\n    if (isString(names)) {\n        isGlobal && _names.watch.add(names);\n        return get(formValues, names, defaultValue);\n    }\n    if (Array.isArray(names)) {\n        return names.map((fieldName)=>(isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\n    }\n    isGlobal && (_names.watchAll = true);\n    return formValues;\n};\n/**\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\n *\n * @remarks\n *\n * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\n *\n * @example\n * ```tsx\n * const { control } = useForm();\n * const values = useWatch({\n *   name: \"fieldName\"\n *   control,\n * })\n * ```\n */ function useWatch(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, defaultValue, disabled, exact } = props || {};\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    _name.current = name;\n    useSubscribe({\n        disabled,\n        subject: control._subjects.values,\n        next: (formState)=>{\n            if (shouldSubscribeByName(_name.current, formState.name, exact)) {\n                updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));\n            }\n        }\n    });\n    const [value1, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getWatch(name, defaultValue));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._removeUnmounted());\n    return value1;\n}\n/**\n * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns field properties, field and form state. {@link UseControllerReturn}\n *\n * @example\n * ```tsx\n * function Input(props) {\n *   const { field, fieldState, formState } = useController(props);\n *   return (\n *     <div>\n *       <input {...field} placeholder={props.name} />\n *       <p>{fieldState.isTouched && \"Touched\"}</p>\n *       <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *     </div>\n *   );\n * }\n * ```\n */ function useController(props) {\n    const methods = useFormContext();\n    const { name, disabled, control = methods.control, shouldUnregister } = props;\n    const isArrayField = isNameInFieldArray(control._names.array, name);\n    const value1 = useWatch({\n        control,\n        name,\n        defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),\n        exact: true\n    });\n    const formState = useFormState({\n        control,\n        name\n    });\n    const _registerProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control.register(name, {\n        ...props.rules,\n        value: value1,\n        ...isBoolean(props.disabled) ? {\n            disabled: props.disabled\n        } : {}\n    }));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;\n        const updateMounted = (name, value1)=>{\n            const field = get(control._fields, name);\n            if (field) {\n                field._f.mount = value1;\n            }\n        };\n        updateMounted(name, true);\n        if (_shouldUnregisterField) {\n            const value1 = cloneObject(get(control._options.defaultValues, name));\n            set(control._defaultValues, name, value1);\n            if (isUndefined(get(control._formValues, name))) {\n                set(control._formValues, name, value1);\n            }\n        }\n        return ()=>{\n            (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        isArrayField,\n        shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (get(control._fields, name)) {\n            control._updateDisabledField({\n                disabled,\n                fields: control._fields,\n                name,\n                value: get(control._fields, name)._f.value\n            });\n        }\n    }, [\n        disabled,\n        name,\n        control\n    ]);\n    return {\n        field: {\n            name,\n            value: value1,\n            ...isBoolean(disabled) || formState.disabled ? {\n                disabled: formState.disabled || disabled\n            } : {},\n            onChange: react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>_registerProps.current.onChange({\n                    target: {\n                        value: getEventValue(event),\n                        name: name\n                    },\n                    type: EVENTS.CHANGE\n                }), [\n                name\n            ]),\n            onBlur: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>_registerProps.current.onBlur({\n                    target: {\n                        value: get(control._formValues, name),\n                        name: name\n                    },\n                    type: EVENTS.BLUR\n                }), [\n                name,\n                control\n            ]),\n            ref: (elm)=>{\n                const field = get(control._fields, name);\n                if (field && elm) {\n                    field._f.ref = {\n                        focus: ()=>elm.focus(),\n                        select: ()=>elm.select(),\n                        setCustomValidity: (message)=>elm.setCustomValidity(message),\n                        reportValidity: ()=>elm.reportValidity()\n                    };\n                }\n            }\n        },\n        formState,\n        fieldState: Object.defineProperties({}, {\n            invalid: {\n                enumerable: true,\n                get: ()=>!!get(formState.errors, name)\n            },\n            isDirty: {\n                enumerable: true,\n                get: ()=>!!get(formState.dirtyFields, name)\n            },\n            isTouched: {\n                enumerable: true,\n                get: ()=>!!get(formState.touchedFields, name)\n            },\n            isValidating: {\n                enumerable: true,\n                get: ()=>!!get(formState.validatingFields, name)\n            },\n            error: {\n                enumerable: true,\n                get: ()=>get(formState.errors, name)\n            }\n        })\n    };\n}\n/**\n * Component based on `useController` hook to work with controlled component.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns provide field handler functions, field and form state.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control } = useForm<FormValues>({\n *     defaultValues: {\n *       test: \"\"\n *     }\n *   });\n *\n *   return (\n *     <form>\n *       <Controller\n *         control={control}\n *         name=\"test\"\n *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (\n *           <>\n *             <input\n *               onChange={onChange} // send value to hook form\n *               onBlur={onBlur} // notify when input is touched\n *               value={value} // return updated value\n *               ref={ref} // set ref for focus management\n *             />\n *             <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *             <p>{fieldState.isTouched ? \"touched\" : \"\"}</p>\n *           </>\n *         )}\n *       />\n *     </form>\n *   );\n * }\n * ```\n */ const Controller = (props)=>props.render(useController(props));\nconst POST_REQUEST = \"post\";\n/**\n * Form component to manage submission.\n *\n * @param props - to setup submission detail. {@link FormProps}\n *\n * @returns form component or headless render prop.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control, formState: { errors } } = useForm();\n *\n *   return (\n *     <Form action=\"/api\" control={control}>\n *       <input {...register(\"name\")} />\n *       <p>{errors?.root?.server && 'Server error'}</p>\n *       <button>Submit</button>\n *     </Form>\n *   );\n * }\n * ```\n */ function Form(props) {\n    const methods = useFormContext();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;\n    const submit = async (event)=>{\n        let hasError = false;\n        let type = \"\";\n        await control.handleSubmit(async (data)=>{\n            const formData = new FormData();\n            let formDataJson = \"\";\n            try {\n                formDataJson = JSON.stringify(data);\n            } catch (_a) {}\n            for (const name of control._names.mount){\n                formData.append(name, get(data, name));\n            }\n            if (onSubmit) {\n                await onSubmit({\n                    data,\n                    event,\n                    method,\n                    formData,\n                    formDataJson\n                });\n            }\n            if (action) {\n                try {\n                    const shouldStringifySubmissionData = [\n                        headers && headers[\"Content-Type\"],\n                        encType\n                    ].some((value1)=>value1 && value1.includes(\"json\"));\n                    const response = await fetch(action, {\n                        method,\n                        headers: {\n                            ...headers,\n                            ...encType ? {\n                                \"Content-Type\": encType\n                            } : {}\n                        },\n                        body: shouldStringifySubmissionData ? formDataJson : formData\n                    });\n                    if (response && (validateStatus ? !validateStatus(response.status) : response.status < 200 || response.status >= 300)) {\n                        hasError = true;\n                        onError && onError({\n                            response\n                        });\n                        type = String(response.status);\n                    } else {\n                        onSuccess && onSuccess({\n                            response\n                        });\n                    }\n                } catch (error) {\n                    hasError = true;\n                    onError && onError({\n                        error\n                    });\n                }\n            }\n        })(event);\n        if (hasError && props.control) {\n            props.control._subjects.state.next({\n                isSubmitSuccessful: false\n            });\n            props.control.setError(\"root.server\", {\n                type\n            });\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return render ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, render({\n        submit\n    })) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", {\n        noValidate: mounted,\n        action: action,\n        method: method,\n        encType: encType,\n        onSubmit: submit,\n        ...rest\n    }, children);\n}\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message)=>validateAllFieldCriteria ? {\n        ...errors[name],\n        types: {\n            ...errors[name] && errors[name].types ? errors[name].types : {},\n            [type]: message || true\n        }\n    } : {};\nvar generateId = ()=>{\n    const d = typeof performance === \"undefined\" ? Date.now() : performance.now() * 1000;\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = (Math.random() * 16 + d) % 16 | 0;\n        return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\nvar getFocusFieldName = (name, index, options = {})=>options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.` : \"\";\nvar getValidationModes = (mode)=>({\n        isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n        isOnBlur: mode === VALIDATION_MODE.onBlur,\n        isOnChange: mode === VALIDATION_MODE.onChange,\n        isOnAll: mode === VALIDATION_MODE.all,\n        isOnTouch: mode === VALIDATION_MODE.onTouched\n    });\nvar isWatched = (name, _names, isBlurEvent)=>!isBlurEvent && (_names.watchAll || _names.watch.has(name) || [\n        ..._names.watch\n    ].some((watchName)=>name.startsWith(watchName) && /^\\.\\w+/.test(name.slice(watchName.length))));\nconst iterateFieldsByAction = (fields, action, fieldsNames, abortEarly)=>{\n    for (const key of fieldsNames || Object.keys(fields)){\n        const field = get(fields, key);\n        if (field) {\n            const { _f, ...currentField } = field;\n            if (_f) {\n                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {\n                    break;\n                } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {\n                    break;\n                } else {\n                    iterateFieldsByAction(currentField, action);\n                }\n            } else if (isObject(currentField)) {\n                iterateFieldsByAction(currentField, action);\n            }\n        }\n    }\n};\nvar updateFieldArrayRootError = (errors, error, name)=>{\n    const fieldArrayErrors = compact(get(errors, name));\n    set(fieldArrayErrors, \"root\", error[name]);\n    set(errors, name, fieldArrayErrors);\n    return errors;\n};\nvar isFileInput = (element)=>element.type === \"file\";\nvar isFunction = (value1)=>typeof value1 === \"function\";\nvar isHTMLElement = (value1)=>{\n    if (!isWeb) {\n        return false;\n    }\n    const owner = value1 ? value1.ownerDocument : 0;\n    return value1 instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);\n};\nvar isMessage = (value1)=>isString(value1);\nvar isRadioInput = (element)=>element.type === \"radio\";\nvar isRegex = (value1)=>value1 instanceof RegExp;\nconst defaultResult = {\n    value: false,\n    isValid: false\n};\nconst validResult = {\n    value: true,\n    isValid: true\n};\nvar getCheckboxValue = (options)=>{\n    if (Array.isArray(options)) {\n        if (options.length > 1) {\n            const values = options.filter((option)=>option && option.checked && !option.disabled).map((option)=>option.value);\n            return {\n                value: values,\n                isValid: !!values.length\n            };\n        }\n        return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === \"\" ? validResult : {\n            value: options[0].value,\n            isValid: true\n        } : validResult : defaultResult;\n    }\n    return defaultResult;\n};\nconst defaultReturn = {\n    isValid: false,\n    value: null\n};\nvar getRadioValue = (options)=>Array.isArray(options) ? options.reduce((previous, option)=>option && option.checked && !option.disabled ? {\n            isValid: true,\n            value: option.value\n        } : previous, defaultReturn) : defaultReturn;\nfunction getValidateError(result, ref, type = \"validate\") {\n    if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {\n        return {\n            type,\n            message: isMessage(result) ? result : \"\",\n            ref\n        };\n    }\n}\nvar getValueAndMessage = (validationData)=>isObject(validationData) && !isRegex(validationData) ? validationData : {\n        value: validationData,\n        message: \"\"\n    };\nvar validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray)=>{\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled } = field._f;\n    const inputValue = get(formValues, name);\n    if (!mount || disabled) {\n        return {};\n    }\n    const inputRef = refs ? refs[0] : ref;\n    const setCustomValidity = (message)=>{\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\n            inputRef.setCustomValidity(isBoolean(message) ? \"\" : message || \"\");\n            inputRef.reportValidity();\n        }\n    };\n    const error = {};\n    const isRadio = isRadioInput(ref);\n    const isCheckBox = isCheckBoxInput(ref);\n    const isRadioOrCheckbox = isRadio || isCheckBox;\n    const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === \"\" || inputValue === \"\" || Array.isArray(inputValue) && !inputValue.length;\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength)=>{\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\n        error[name] = {\n            type: exceedMax ? maxType : minType,\n            message,\n            ref,\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message)\n        };\n    };\n    if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n        const { value: value1, message } = isMessage(required) ? {\n            value: !!required,\n            message: required\n        } : getValueAndMessage(required);\n        if (value1) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.required,\n                message,\n                ref: inputRef,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n        let exceedMax;\n        let exceedMin;\n        const maxOutput = getValueAndMessage(max);\n        const minOutput = getValueAndMessage(min);\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\n            const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);\n            if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n            }\n            if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n            }\n        } else {\n            const valueDate = ref.valueAsDate || new Date(inputValue);\n            const convertTimeToDate = (time)=>new Date(new Date().toDateString() + \" \" + time);\n            const isTime = ref.type == \"time\";\n            const isWeek = ref.type == \"week\";\n            if (isString(maxOutput.value) && inputValue) {\n                exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);\n            }\n            if (isString(minOutput.value) && inputValue) {\n                exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);\n            }\n        }\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {\n        const maxLengthOutput = getValueAndMessage(maxLength);\n        const minLengthOutput = getValueAndMessage(minLength);\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if (pattern && !isEmpty && isString(inputValue)) {\n        const { value: patternValue, message } = getValueAndMessage(pattern);\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.pattern,\n                message,\n                ref,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (validate) {\n        if (isFunction(validate)) {\n            const result = await validate(inputValue, formValues);\n            const validateError = getValidateError(result, inputRef);\n            if (validateError) {\n                error[name] = {\n                    ...validateError,\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)\n                };\n                if (!validateAllFieldCriteria) {\n                    setCustomValidity(validateError.message);\n                    return error;\n                }\n            }\n        } else if (isObject(validate)) {\n            let validationResult = {};\n            for(const key in validate){\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n                    break;\n                }\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\n                if (validateError) {\n                    validationResult = {\n                        ...validateError,\n                        ...appendErrorsCurry(key, validateError.message)\n                    };\n                    setCustomValidity(validateError.message);\n                    if (validateAllFieldCriteria) {\n                        error[name] = validationResult;\n                    }\n                }\n            }\n            if (!isEmptyObject(validationResult)) {\n                error[name] = {\n                    ref: inputRef,\n                    ...validationResult\n                };\n                if (!validateAllFieldCriteria) {\n                    return error;\n                }\n            }\n        }\n    }\n    setCustomValidity(true);\n    return error;\n};\nvar appendAt = (data, value1)=>[\n        ...data,\n        ...convertToArrayPayload(value1)\n    ];\nvar fillEmptyArray = (value1)=>Array.isArray(value1) ? value1.map(()=>undefined) : undefined;\nfunction insert(data, index, value1) {\n    return [\n        ...data.slice(0, index),\n        ...convertToArrayPayload(value1),\n        ...data.slice(index)\n    ];\n}\nvar moveArrayAt = (data, from, to)=>{\n    if (!Array.isArray(data)) {\n        return [];\n    }\n    if (isUndefined(data[to])) {\n        data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n};\nvar prependAt = (data, value1)=>[\n        ...convertToArrayPayload(value1),\n        ...convertToArrayPayload(data)\n    ];\nfunction removeAtIndexes(data, indexes) {\n    let i = 0;\n    const temp = [\n        ...data\n    ];\n    for (const index of indexes){\n        temp.splice(index - i, 1);\n        i++;\n    }\n    return compact(temp).length ? temp : [];\n}\nvar removeArrayAt = (data, index)=>isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b)=>a - b));\nvar swapArrayAt = (data, indexA, indexB)=>{\n    [data[indexA], data[indexB]] = [\n        data[indexB],\n        data[indexA]\n    ];\n};\nfunction baseGet(object, updatePath) {\n    const length = updatePath.slice(0, -1).length;\n    let index = 0;\n    while(index < length){\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\n    }\n    return object;\n}\nfunction isEmptyArray(obj) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction unset(object, path) {\n    const paths = Array.isArray(path) ? path : isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\n    const index = paths.length - 1;\n    const key = paths[index];\n    if (childObject) {\n        delete childObject[key];\n    }\n    if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {\n        unset(object, paths.slice(0, -1));\n    }\n    return object;\n}\nvar updateAt = (fieldValues, index, value1)=>{\n    fieldValues[index] = value1;\n    return fieldValues;\n};\n/**\n * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n *\n * @param props - useFieldArray props\n *\n * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({\n *     defaultValues: {\n *       test: []\n *     }\n *   });\n *   const { fields, append } = useFieldArray({\n *     control,\n *     name: \"test\"\n *   });\n *\n *   return (\n *     <form onSubmit={handleSubmit(data => console.log(data))}>\n *       {fields.map((item, index) => (\n *          <input key={item.id} {...register(`test.${index}.firstName`)}  />\n *       ))}\n *       <button type=\"button\" onClick={() => append({ firstName: \"bill\" })}>\n *         append\n *       </button>\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFieldArray(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, keyName = \"id\", shouldUnregister } = props;\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getFieldArray(name));\n    const ids = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control._getFieldArray(name).map(generateId));\n    const _fieldIds = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fields);\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    const _actioned = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    _name.current = name;\n    _fieldIds.current = fields;\n    control._names.array.add(name);\n    props.rules && control.register(name, props.rules);\n    useSubscribe({\n        next: ({ values, name: fieldArrayName })=>{\n            if (fieldArrayName === _name.current || !fieldArrayName) {\n                const fieldValues = get(values, _name.current);\n                if (Array.isArray(fieldValues)) {\n                    setFields(fieldValues);\n                    ids.current = fieldValues.map(generateId);\n                }\n            }\n        },\n        subject: control._subjects.array\n    });\n    const updateValues = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((updatedFieldArrayValues)=>{\n        _actioned.current = true;\n        control._updateFieldArray(name, updatedFieldArrayValues);\n    }, [\n        control,\n        name\n    ]);\n    const append = (value1, options)=>{\n        const appendValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);\n        ids.current = appendAt(ids.current, appendValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, appendAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const prepend = (value1, options)=>{\n        const prependValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);\n        control._names.focus = getFocusFieldName(name, 0, options);\n        ids.current = prependAt(ids.current, prependValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, prependAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const remove = (index)=>{\n        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);\n        ids.current = removeArrayAt(ids.current, index);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, removeArrayAt, {\n            argA: index\n        });\n    };\n    const insert$1 = (index, value1, options)=>{\n        const insertValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);\n        control._names.focus = getFocusFieldName(name, index, options);\n        ids.current = insert(ids.current, index, insertValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, insert, {\n            argA: index,\n            argB: fillEmptyArray(value1)\n        });\n    };\n    const swap = (indexA, indexB)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        swapArrayAt(updatedFieldArrayValues, indexA, indexB);\n        swapArrayAt(ids.current, indexA, indexB);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, swapArrayAt, {\n            argA: indexA,\n            argB: indexB\n        }, false);\n    };\n    const move = (from, to)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        moveArrayAt(updatedFieldArrayValues, from, to);\n        moveArrayAt(ids.current, from, to);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, moveArrayAt, {\n            argA: from,\n            argB: to\n        }, false);\n    };\n    const update = (index, value1)=>{\n        const updateValue = cloneObject(value1);\n        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);\n        ids.current = [\n            ...updatedFieldArrayValues\n        ].map((item, i)=>!item || i === index ? generateId() : ids.current[i]);\n        updateValues(updatedFieldArrayValues);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._updateFieldArray(name, updatedFieldArrayValues, updateAt, {\n            argA: index,\n            argB: updateValue\n        }, true, false);\n    };\n    const replace = (value1)=>{\n        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value1));\n        ids.current = updatedFieldArrayValues.map(generateId);\n        updateValues([\n            ...updatedFieldArrayValues\n        ]);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._updateFieldArray(name, [\n            ...updatedFieldArrayValues\n        ], (data)=>data, {}, true, false);\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._state.action = false;\n        isWatched(name, control._names) && control._subjects.state.next({\n            ...control._formState\n        });\n        if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted)) {\n            if (control._options.resolver) {\n                control._executeSchema([\n                    name\n                ]).then((result)=>{\n                    const error = get(result.errors, name);\n                    const existingError = get(control._formState.errors, name);\n                    if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {\n                        error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);\n                        control._subjects.state.next({\n                            errors: control._formState.errors\n                        });\n                    }\n                });\n            } else {\n                const field = get(control._fields, name);\n                if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {\n                    validateField(field, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error)=>!isEmptyObject(error) && control._subjects.state.next({\n                            errors: updateFieldArrayRootError(control._formState.errors, error, name)\n                        }));\n                }\n            }\n        }\n        control._subjects.values.next({\n            name,\n            values: {\n                ...control._formValues\n            }\n        });\n        control._names.focus && iterateFieldsByAction(control._fields, (ref, key)=>{\n            if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {\n                ref.focus();\n                return 1;\n            }\n            return;\n        });\n        control._names.focus = \"\";\n        control._updateValid();\n        _actioned.current = false;\n    }, [\n        fields,\n        name,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        !get(control._formValues, name) && control._updateFieldArray(name);\n        return ()=>{\n            (control._options.shouldUnregister || shouldUnregister) && control.unregister(name);\n        };\n    }, [\n        name,\n        control,\n        keyName,\n        shouldUnregister\n    ]);\n    return {\n        swap: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(swap, [\n            updateValues,\n            name,\n            control\n        ]),\n        move: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(move, [\n            updateValues,\n            name,\n            control\n        ]),\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(prepend, [\n            updateValues,\n            name,\n            control\n        ]),\n        append: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(append, [\n            updateValues,\n            name,\n            control\n        ]),\n        remove: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(remove, [\n            updateValues,\n            name,\n            control\n        ]),\n        insert: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(insert$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        update: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(update, [\n            updateValues,\n            name,\n            control\n        ]),\n        replace: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(replace, [\n            updateValues,\n            name,\n            control\n        ]),\n        fields: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>fields.map((field, index)=>({\n                    ...field,\n                    [keyName]: ids.current[index] || generateId()\n                })), [\n            fields,\n            keyName\n        ])\n    };\n}\nvar createSubject = ()=>{\n    let _observers = [];\n    const next = (value1)=>{\n        for (const observer of _observers){\n            observer.next && observer.next(value1);\n        }\n    };\n    const subscribe = (observer)=>{\n        _observers.push(observer);\n        return {\n            unsubscribe: ()=>{\n                _observers = _observers.filter((o)=>o !== observer);\n            }\n        };\n    };\n    const unsubscribe = ()=>{\n        _observers = [];\n    };\n    return {\n        get observers () {\n            return _observers;\n        },\n        next,\n        subscribe,\n        unsubscribe\n    };\n};\nvar isPrimitive = (value1)=>isNullOrUndefined(value1) || !isObjectType(value1);\nfunction deepEqual(object1, object2) {\n    if (isPrimitive(object1) || isPrimitive(object2)) {\n        return object1 === object2;\n    }\n    if (isDateObject(object1) && isDateObject(object2)) {\n        return object1.getTime() === object2.getTime();\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1){\n        const val1 = object1[key];\n        if (!keys2.includes(key)) {\n            return false;\n        }\n        if (key !== \"ref\") {\n            const val2 = object2[key];\n            if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nvar isMultipleSelect = (element)=>element.type === `select-multiple`;\nvar isRadioOrCheckbox = (ref)=>isRadioInput(ref) || isCheckBoxInput(ref);\nvar live = (ref)=>isHTMLElement(ref) && ref.isConnected;\nvar objectHasFunction = (data)=>{\n    for(const key in data){\n        if (isFunction(data[key])) {\n            return true;\n        }\n    }\n    return false;\n};\nfunction markFieldsDirty(data, fields = {}) {\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for(const key in data){\n            if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {\n                fields[key] = Array.isArray(data[key]) ? [] : {};\n                markFieldsDirty(data[key], fields[key]);\n            } else if (!isNullOrUndefined(data[key])) {\n                fields[key] = true;\n            }\n        }\n    }\n    return fields;\n}\nfunction getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for(const key in data){\n            if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {\n                if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {\n                    dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : {\n                        ...markFieldsDirty(data[key])\n                    };\n                } else {\n                    getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\n                }\n            } else {\n                dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);\n            }\n        }\n    }\n    return dirtyFieldsFromValues;\n}\nvar getDirtyFields = (defaultValues, formValues)=>getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));\nvar getFieldValueAs = (value1, { valueAsNumber, valueAsDate, setValueAs })=>isUndefined(value1) ? value1 : valueAsNumber ? value1 === \"\" ? NaN : value1 ? +value1 : value1 : valueAsDate && isString(value1) ? new Date(value1) : setValueAs ? setValueAs(value1) : value1;\nfunction getFieldValue(_f) {\n    const ref = _f.ref;\n    if (_f.refs ? _f.refs.every((ref)=>ref.disabled) : ref.disabled) {\n        return;\n    }\n    if (isFileInput(ref)) {\n        return ref.files;\n    }\n    if (isRadioInput(ref)) {\n        return getRadioValue(_f.refs).value;\n    }\n    if (isMultipleSelect(ref)) {\n        return [\n            ...ref.selectedOptions\n        ].map(({ value: value1 })=>value1);\n    }\n    if (isCheckBoxInput(ref)) {\n        return getCheckboxValue(_f.refs).value;\n    }\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\n}\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation)=>{\n    const fields = {};\n    for (const name of fieldsNames){\n        const field = get(_fields, name);\n        field && set(fields, name, field._f);\n    }\n    return {\n        criteriaMode,\n        names: [\n            ...fieldsNames\n        ],\n        fields,\n        shouldUseNativeValidation\n    };\n};\nvar getRuleValue = (rule)=>isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;\nvar hasValidation = (options)=>options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\nfunction schemaErrorLookup(errors, _fields, name) {\n    const error = get(errors, name);\n    if (error || isKey(name)) {\n        return {\n            error,\n            name\n        };\n    }\n    const names = name.split(\".\");\n    while(names.length){\n        const fieldName = names.join(\".\");\n        const field = get(_fields, fieldName);\n        const foundError = get(errors, fieldName);\n        if (field && !Array.isArray(field) && name !== fieldName) {\n            return {\n                name\n            };\n        }\n        if (foundError && foundError.type) {\n            return {\n                name: fieldName,\n                error: foundError\n            };\n        }\n        names.pop();\n    }\n    return {\n        name\n    };\n}\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode)=>{\n    if (mode.isOnAll) {\n        return false;\n    } else if (!isSubmitted && mode.isOnTouch) {\n        return !(isTouched || isBlurEvent);\n    } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n        return !isBlurEvent;\n    } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n        return isBlurEvent;\n    }\n    return true;\n};\nvar unsetEmptyArray = (ref, name)=>!compact(get(ref, name)).length && unset(ref, name);\nconst defaultOptions = {\n    mode: VALIDATION_MODE.onSubmit,\n    reValidateMode: VALIDATION_MODE.onChange,\n    shouldFocusError: true\n};\nfunction createFormControl(props = {}) {\n    let _options = {\n        ...defaultOptions,\n        ...props\n    };\n    let _formState = {\n        submitCount: 0,\n        isDirty: false,\n        isLoading: isFunction(_options.defaultValues),\n        isValidating: false,\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        touchedFields: {},\n        dirtyFields: {},\n        validatingFields: {},\n        errors: _options.errors || {},\n        disabled: _options.disabled || false\n    };\n    let _fields = {};\n    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};\n    let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);\n    let _state = {\n        action: false,\n        mount: false,\n        watch: false\n    };\n    let _names = {\n        mount: new Set(),\n        unMount: new Set(),\n        array: new Set(),\n        watch: new Set()\n    };\n    let delayErrorCallback;\n    let timer = 0;\n    const _proxyFormState = {\n        isDirty: false,\n        dirtyFields: false,\n        validatingFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    };\n    const _subjects = {\n        values: createSubject(),\n        array: createSubject(),\n        state: createSubject()\n    };\n    const validationModeBeforeSubmit = getValidationModes(_options.mode);\n    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\n    const debounce = (callback)=>(wait)=>{\n            clearTimeout(timer);\n            timer = setTimeout(callback, wait);\n        };\n    const _updateValid = async (shouldUpdateValid)=>{\n        if (_proxyFormState.isValid || shouldUpdateValid) {\n            const isValid = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);\n            if (isValid !== _formState.isValid) {\n                _subjects.state.next({\n                    isValid\n                });\n            }\n        }\n    };\n    const _updateIsValidating = (names, isValidating)=>{\n        if (_proxyFormState.isValidating || _proxyFormState.validatingFields) {\n            (names || Array.from(_names.mount)).forEach((name)=>{\n                if (name) {\n                    isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);\n                }\n            });\n            _subjects.state.next({\n                validatingFields: _formState.validatingFields,\n                isValidating: !isEmptyObject(_formState.validatingFields)\n            });\n        }\n    };\n    const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true)=>{\n        if (args && method) {\n            _state.action = true;\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\n                shouldSetValues && set(_fields, name, fieldValues);\n            }\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.errors, name, errors);\n                unsetEmptyArray(_formState.errors, name);\n            }\n            if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\n            }\n            if (_proxyFormState.dirtyFields) {\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\n            }\n            _subjects.state.next({\n                name,\n                isDirty: _getDirty(name, values),\n                dirtyFields: _formState.dirtyFields,\n                errors: _formState.errors,\n                isValid: _formState.isValid\n            });\n        } else {\n            set(_formValues, name, values);\n        }\n    };\n    const updateErrors = (name, error)=>{\n        set(_formState.errors, name, error);\n        _subjects.state.next({\n            errors: _formState.errors\n        });\n    };\n    const _setErrors = (errors)=>{\n        _formState.errors = errors;\n        _subjects.state.next({\n            errors: _formState.errors,\n            isValid: false\n        });\n    };\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value1, ref)=>{\n        const field = get(_fields, name);\n        if (field) {\n            const defaultValue = get(_formValues, name, isUndefined(value1) ? get(_defaultValues, name) : value1);\n            isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);\n            _state.mount && _updateValid();\n        }\n    };\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender)=>{\n        let shouldUpdateField = false;\n        let isPreviousDirty = false;\n        const output = {\n            name\n        };\n        const disabledField = !!(get(_fields, name) && get(_fields, name)._f.disabled);\n        if (!isBlurEvent || shouldDirty) {\n            if (_proxyFormState.isDirty) {\n                isPreviousDirty = _formState.isDirty;\n                _formState.isDirty = output.isDirty = _getDirty();\n                shouldUpdateField = isPreviousDirty !== output.isDirty;\n            }\n            const isCurrentFieldPristine = disabledField || deepEqual(get(_defaultValues, name), fieldValue);\n            isPreviousDirty = !!(!disabledField && get(_formState.dirtyFields, name));\n            isCurrentFieldPristine || disabledField ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);\n            output.dirtyFields = _formState.dirtyFields;\n            shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;\n        }\n        if (isBlurEvent) {\n            const isPreviousFieldTouched = get(_formState.touchedFields, name);\n            if (!isPreviousFieldTouched) {\n                set(_formState.touchedFields, name, isBlurEvent);\n                output.touchedFields = _formState.touchedFields;\n                shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;\n            }\n        }\n        shouldUpdateField && shouldRender && _subjects.state.next(output);\n        return shouldUpdateField ? output : {};\n    };\n    const shouldRenderByError = (name, isValid, error, fieldState)=>{\n        const previousFieldError = get(_formState.errors, name);\n        const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid) && _formState.isValid !== isValid;\n        if (props.delayError && error) {\n            delayErrorCallback = debounce(()=>updateErrors(name, error));\n            delayErrorCallback(props.delayError);\n        } else {\n            clearTimeout(timer);\n            delayErrorCallback = null;\n            error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n        }\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {\n            const updatedFormState = {\n                ...fieldState,\n                ...shouldUpdateValid && isBoolean(isValid) ? {\n                    isValid\n                } : {},\n                errors: _formState.errors,\n                name\n            };\n            _formState = {\n                ..._formState,\n                ...updatedFormState\n            };\n            _subjects.state.next(updatedFormState);\n        }\n    };\n    const _executeSchema = async (name)=>{\n        _updateIsValidating(name, true);\n        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\n        _updateIsValidating(name);\n        return result;\n    };\n    const executeSchemaAndUpdateState = async (names)=>{\n        const { errors } = await _executeSchema(names);\n        if (names) {\n            for (const name of names){\n                const error = get(errors, name);\n                error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n            }\n        } else {\n            _formState.errors = errors;\n        }\n        return errors;\n    };\n    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {\n        valid: true\n    })=>{\n        for(const name in fields){\n            const field = fields[name];\n            if (field) {\n                const { _f, ...fieldValue } = field;\n                if (_f) {\n                    const isFieldArrayRoot = _names.array.has(_f.name);\n                    _updateIsValidating([\n                        name\n                    ], true);\n                    const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);\n                    _updateIsValidating([\n                        name\n                    ]);\n                    if (fieldError[_f.name]) {\n                        context.valid = false;\n                        if (shouldOnlyCheckValid) {\n                            break;\n                        }\n                    }\n                    !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));\n                }\n                fieldValue && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);\n            }\n        }\n        return context.valid;\n    };\n    const _removeUnmounted = ()=>{\n        for (const name of _names.unMount){\n            const field = get(_fields, name);\n            field && (field._f.refs ? field._f.refs.every((ref)=>!live(ref)) : !live(field._f.ref)) && unregister(name);\n        }\n        _names.unMount = new Set();\n    };\n    const _getDirty = (name, data)=>(name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));\n    const _getWatch = (names, defaultValue, isGlobal)=>generateWatchOutput(names, _names, {\n            ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {\n                [names]: defaultValue\n            } : defaultValue\n        }, isGlobal, defaultValue);\n    const _getFieldArray = (name)=>compact(get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));\n    const setFieldValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        let fieldValue = value1;\n        if (field) {\n            const fieldReference = field._f;\n            if (fieldReference) {\n                !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value1, fieldReference));\n                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value1) ? \"\" : value1;\n                if (isMultipleSelect(fieldReference.ref)) {\n                    [\n                        ...fieldReference.ref.options\n                    ].forEach((optionRef)=>optionRef.selected = fieldValue.includes(optionRef.value));\n                } else if (fieldReference.refs) {\n                    if (isCheckBoxInput(fieldReference.ref)) {\n                        fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef)=>(!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data)=>data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);\n                    } else {\n                        fieldReference.refs.forEach((radioRef)=>radioRef.checked = radioRef.value === fieldValue);\n                    }\n                } else if (isFileInput(fieldReference.ref)) {\n                    fieldReference.ref.value = \"\";\n                } else {\n                    fieldReference.ref.value = fieldValue;\n                    if (!fieldReference.ref.type) {\n                        _subjects.values.next({\n                            name,\n                            values: {\n                                ..._formValues\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\n        options.shouldValidate && trigger(name);\n    };\n    const setValues = (name, value1, options)=>{\n        for(const fieldKey in value1){\n            const fieldValue = value1[fieldKey];\n            const fieldName = `${name}.${fieldKey}`;\n            const field = get(_fields, fieldName);\n            (_names.array.has(name) || !isPrimitive(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);\n        }\n    };\n    const setValue = (name, value1, options = {})=>{\n        const field = get(_fields, name);\n        const isFieldArray = _names.array.has(name);\n        const cloneValue = cloneObject(value1);\n        set(_formValues, name, cloneValue);\n        if (isFieldArray) {\n            _subjects.array.next({\n                name,\n                values: {\n                    ..._formValues\n                }\n            });\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {\n                _subjects.state.next({\n                    name,\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\n                    isDirty: _getDirty(name, cloneValue)\n                });\n            }\n        } else {\n            field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);\n        }\n        isWatched(name, _names) && _subjects.state.next({\n            ..._formState\n        });\n        _subjects.values.next({\n            name: _state.mount ? name : undefined,\n            values: {\n                ..._formValues\n            }\n        });\n    };\n    const onChange = async (event)=>{\n        _state.mount = true;\n        const target = event.target;\n        let name = target.name;\n        let isFieldValueUpdated = true;\n        const field = get(_fields, name);\n        const getCurrentFieldValue = ()=>target.type ? getFieldValue(field._f) : getEventValue(event);\n        const _updateIsFieldValueUpdated = (fieldValue)=>{\n            isFieldValueUpdated = Number.isNaN(fieldValue) || fieldValue === get(_formValues, name, fieldValue);\n        };\n        if (field) {\n            let error;\n            let isValid;\n            const fieldValue = getCurrentFieldValue();\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\n            const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\n            const watched = isWatched(name, _names, isBlurEvent);\n            set(_formValues, name, fieldValue);\n            if (isBlurEvent) {\n                field._f.onBlur && field._f.onBlur(event);\n                delayErrorCallback && delayErrorCallback(0);\n            } else if (field._f.onChange) {\n                field._f.onChange(event);\n            }\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);\n            const shouldRender = !isEmptyObject(fieldState) || watched;\n            !isBlurEvent && _subjects.values.next({\n                name,\n                type: event.type,\n                values: {\n                    ..._formValues\n                }\n            });\n            if (shouldSkipValidation) {\n                _proxyFormState.isValid && _updateValid();\n                return shouldRender && _subjects.state.next({\n                    name,\n                    ...watched ? {} : fieldState\n                });\n            }\n            !isBlurEvent && watched && _subjects.state.next({\n                ..._formState\n            });\n            if (_options.resolver) {\n                const { errors } = await _executeSchema([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\n                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\n                    error = errorLookupResult.error;\n                    name = errorLookupResult.name;\n                    isValid = isEmptyObject(errors);\n                }\n            } else {\n                _updateIsValidating([\n                    name\n                ], true);\n                error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\n                _updateIsValidating([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    if (error) {\n                        isValid = false;\n                    } else if (_proxyFormState.isValid) {\n                        isValid = await executeBuiltInValidation(_fields, true);\n                    }\n                }\n            }\n            if (isFieldValueUpdated) {\n                field._f.deps && trigger(field._f.deps);\n                shouldRenderByError(name, isValid, error, fieldState);\n            }\n        }\n    };\n    const _focusInput = (ref, key)=>{\n        if (get(_formState.errors, key) && ref.focus) {\n            ref.focus();\n            return 1;\n        }\n        return;\n    };\n    const trigger = async (name, options = {})=>{\n        let isValid;\n        let validationResult;\n        const fieldNames = convertToArrayPayload(name);\n        if (_options.resolver) {\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\n            isValid = isEmptyObject(errors);\n            validationResult = name ? !fieldNames.some((name)=>get(errors, name)) : isValid;\n        } else if (name) {\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName)=>{\n                const field = get(_fields, fieldName);\n                return await executeBuiltInValidation(field && field._f ? {\n                    [fieldName]: field\n                } : field);\n            }))).every(Boolean);\n            !(!validationResult && !_formState.isValid) && _updateValid();\n        } else {\n            validationResult = isValid = await executeBuiltInValidation(_fields);\n        }\n        _subjects.state.next({\n            ...!isString(name) || _proxyFormState.isValid && isValid !== _formState.isValid ? {} : {\n                name\n            },\n            ..._options.resolver || !name ? {\n                isValid\n            } : {},\n            errors: _formState.errors\n        });\n        options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);\n        return validationResult;\n    };\n    const getValues = (fieldNames)=>{\n        const values = {\n            ..._state.mount ? _formValues : _defaultValues\n        };\n        return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name)=>get(values, name));\n    };\n    const getFieldState = (name, formState)=>({\n            invalid: !!get((formState || _formState).errors, name),\n            isDirty: !!get((formState || _formState).dirtyFields, name),\n            isTouched: !!get((formState || _formState).touchedFields, name),\n            isValidating: !!get((formState || _formState).validatingFields, name),\n            error: get((formState || _formState).errors, name)\n        });\n    const clearErrors = (name)=>{\n        name && convertToArrayPayload(name).forEach((inputName)=>unset(_formState.errors, inputName));\n        _subjects.state.next({\n            errors: name ? _formState.errors : {}\n        });\n    };\n    const setError = (name, error, options)=>{\n        const ref = (get(_fields, name, {\n            _f: {}\n        })._f || {}).ref;\n        const currentError = get(_formState.errors, name) || {};\n        // Don't override existing error messages elsewhere in the object tree.\n        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;\n        set(_formState.errors, name, {\n            ...restOfErrorTree,\n            ...error,\n            ref\n        });\n        _subjects.state.next({\n            name,\n            errors: _formState.errors,\n            isValid: false\n        });\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\n    };\n    const watch = (name, defaultValue)=>isFunction(name) ? _subjects.values.subscribe({\n            next: (payload)=>name(_getWatch(undefined, defaultValue), payload)\n        }) : _getWatch(name, defaultValue, true);\n    const unregister = (name, options = {})=>{\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount){\n            _names.mount.delete(fieldName);\n            _names.array.delete(fieldName);\n            if (!options.keepValue) {\n                unset(_fields, fieldName);\n                unset(_formValues, fieldName);\n            }\n            !options.keepError && unset(_formState.errors, fieldName);\n            !options.keepDirty && unset(_formState.dirtyFields, fieldName);\n            !options.keepTouched && unset(_formState.touchedFields, fieldName);\n            !options.keepIsValidating && unset(_formState.validatingFields, fieldName);\n            !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);\n        }\n        _subjects.values.next({\n            values: {\n                ..._formValues\n            }\n        });\n        _subjects.state.next({\n            ..._formState,\n            ...!options.keepDirty ? {} : {\n                isDirty: _getDirty()\n            }\n        });\n        !options.keepIsValid && _updateValid();\n    };\n    const _updateDisabledField = ({ disabled, name, field, fields, value: value1 })=>{\n        if (isBoolean(disabled) && _state.mount || !!disabled) {\n            const inputValue = disabled ? undefined : isUndefined(value1) ? getFieldValue(field ? field._f : get(fields, name)._f) : value1;\n            set(_formValues, name, inputValue);\n            updateTouchAndDirty(name, inputValue, false, false, true);\n        }\n    };\n    const register = (name, options = {})=>{\n        let field = get(_fields, name);\n        const disabledIsDefined = isBoolean(options.disabled);\n        set(_fields, name, {\n            ...field || {},\n            _f: {\n                ...field && field._f ? field._f : {\n                    ref: {\n                        name\n                    }\n                },\n                name,\n                mount: true,\n                ...options\n            }\n        });\n        _names.mount.add(name);\n        if (field) {\n            _updateDisabledField({\n                field,\n                disabled: options.disabled,\n                name,\n                value: options.value\n            });\n        } else {\n            updateValidAndValue(name, true, options.value);\n        }\n        return {\n            ...disabledIsDefined ? {\n                disabled: options.disabled\n            } : {},\n            ..._options.progressive ? {\n                required: !!options.required,\n                min: getRuleValue(options.min),\n                max: getRuleValue(options.max),\n                minLength: getRuleValue(options.minLength),\n                maxLength: getRuleValue(options.maxLength),\n                pattern: getRuleValue(options.pattern)\n            } : {},\n            name,\n            onChange,\n            onBlur: onChange,\n            ref: (ref)=>{\n                if (ref) {\n                    register(name, options);\n                    field = get(_fields, name);\n                    const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll(\"input,select,textarea\")[0] || ref : ref : ref;\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\n                    const refs = field._f.refs || [];\n                    if (radioOrCheckbox ? refs.find((option)=>option === fieldRef) : fieldRef === field._f.ref) {\n                        return;\n                    }\n                    set(_fields, name, {\n                        _f: {\n                            ...field._f,\n                            ...radioOrCheckbox ? {\n                                refs: [\n                                    ...refs.filter(live),\n                                    fieldRef,\n                                    ...Array.isArray(get(_defaultValues, name)) ? [\n                                        {}\n                                    ] : []\n                                ],\n                                ref: {\n                                    type: fieldRef.type,\n                                    name\n                                }\n                            } : {\n                                ref: fieldRef\n                            }\n                        }\n                    });\n                    updateValidAndValue(name, false, undefined, fieldRef);\n                } else {\n                    field = get(_fields, name, {});\n                    if (field._f) {\n                        field._f.mount = false;\n                    }\n                    (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);\n                }\n            }\n        };\n    };\n    const _focusError = ()=>_options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);\n    const _disableForm = (disabled)=>{\n        if (isBoolean(disabled)) {\n            _subjects.state.next({\n                disabled\n            });\n            iterateFieldsByAction(_fields, (ref, name)=>{\n                const currentField = get(_fields, name);\n                if (currentField) {\n                    ref.disabled = currentField._f.disabled || disabled;\n                    if (Array.isArray(currentField._f.refs)) {\n                        currentField._f.refs.forEach((inputRef)=>{\n                            inputRef.disabled = currentField._f.disabled || disabled;\n                        });\n                    }\n                }\n            }, 0, false);\n        }\n    };\n    const handleSubmit = (onValid, onInvalid)=>async (e)=>{\n            let onValidError = undefined;\n            if (e) {\n                e.preventDefault && e.preventDefault();\n                e.persist && e.persist();\n            }\n            let fieldValues = cloneObject(_formValues);\n            _subjects.state.next({\n                isSubmitting: true\n            });\n            if (_options.resolver) {\n                const { errors, values } = await _executeSchema();\n                _formState.errors = errors;\n                fieldValues = values;\n            } else {\n                await executeBuiltInValidation(_fields);\n            }\n            unset(_formState.errors, \"root\");\n            if (isEmptyObject(_formState.errors)) {\n                _subjects.state.next({\n                    errors: {}\n                });\n                try {\n                    await onValid(fieldValues, e);\n                } catch (error) {\n                    onValidError = error;\n                }\n            } else {\n                if (onInvalid) {\n                    await onInvalid({\n                        ..._formState.errors\n                    }, e);\n                }\n                _focusError();\n                setTimeout(_focusError);\n            }\n            _subjects.state.next({\n                isSubmitted: true,\n                isSubmitting: false,\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,\n                submitCount: _formState.submitCount + 1,\n                errors: _formState.errors\n            });\n            if (onValidError) {\n                throw onValidError;\n            }\n        };\n    const resetField = (name, options = {})=>{\n        if (get(_fields, name)) {\n            if (isUndefined(options.defaultValue)) {\n                setValue(name, cloneObject(get(_defaultValues, name)));\n            } else {\n                setValue(name, options.defaultValue);\n                set(_defaultValues, name, cloneObject(options.defaultValue));\n            }\n            if (!options.keepTouched) {\n                unset(_formState.touchedFields, name);\n            }\n            if (!options.keepDirty) {\n                unset(_formState.dirtyFields, name);\n                _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();\n            }\n            if (!options.keepError) {\n                unset(_formState.errors, name);\n                _proxyFormState.isValid && _updateValid();\n            }\n            _subjects.state.next({\n                ..._formState\n            });\n        }\n    };\n    const _reset = (formValues, keepStateOptions = {})=>{\n        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;\n        const cloneUpdatedValues = cloneObject(updatedValues);\n        const isEmptyResetValues = isEmptyObject(formValues);\n        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;\n        if (!keepStateOptions.keepDefaultValues) {\n            _defaultValues = updatedValues;\n        }\n        if (!keepStateOptions.keepValues) {\n            if (keepStateOptions.keepDirtyValues) {\n                for (const fieldName of _names.mount){\n                    get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));\n                }\n            } else {\n                if (isWeb && isUndefined(formValues)) {\n                    for (const name of _names.mount){\n                        const field = get(_fields, name);\n                        if (field && field._f) {\n                            const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n                            if (isHTMLElement(fieldReference)) {\n                                const form = fieldReference.closest(\"form\");\n                                if (form) {\n                                    form.reset();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                _fields = {};\n            }\n            _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);\n            _subjects.array.next({\n                values: {\n                    ...values\n                }\n            });\n            _subjects.values.next({\n                values: {\n                    ...values\n                }\n            });\n        }\n        _names = {\n            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),\n            unMount: new Set(),\n            array: new Set(),\n            watch: new Set(),\n            watchAll: false,\n            focus: \"\"\n        };\n        _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;\n        _state.watch = !!props.shouldUnregister;\n        _subjects.state.next({\n            submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,\n            isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),\n            isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,\n            dirtyFields: isEmptyResetValues ? [] : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : {},\n            touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\n            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,\n            isSubmitting: false\n        });\n    };\n    const reset = (formValues, keepStateOptions)=>_reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);\n    const setFocus = (name, options = {})=>{\n        const field = get(_fields, name);\n        const fieldReference = field && field._f;\n        if (fieldReference) {\n            const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;\n            if (fieldRef.focus) {\n                fieldRef.focus();\n                options.shouldSelect && fieldRef.select();\n            }\n        }\n    };\n    const _updateFormState = (updatedFormState)=>{\n        _formState = {\n            ..._formState,\n            ...updatedFormState\n        };\n    };\n    const _resetDefaultValues = ()=>isFunction(_options.defaultValues) && _options.defaultValues().then((values)=>{\n            reset(values, _options.resetOptions);\n            _subjects.state.next({\n                isLoading: false\n            });\n        });\n    return {\n        control: {\n            register,\n            unregister,\n            getFieldState,\n            handleSubmit,\n            setError,\n            _executeSchema,\n            _getWatch,\n            _getDirty,\n            _updateValid,\n            _removeUnmounted,\n            _updateFieldArray,\n            _updateDisabledField,\n            _getFieldArray,\n            _reset,\n            _resetDefaultValues,\n            _updateFormState,\n            _disableForm,\n            _subjects,\n            _proxyFormState,\n            _setErrors,\n            get _fields () {\n                return _fields;\n            },\n            get _formValues () {\n                return _formValues;\n            },\n            get _state () {\n                return _state;\n            },\n            set _state (value){\n                _state = value;\n            },\n            get _defaultValues () {\n                return _defaultValues;\n            },\n            get _names () {\n                return _names;\n            },\n            set _names (value){\n                _names = value;\n            },\n            get _formState () {\n                return _formState;\n            },\n            set _formState (value){\n                _formState = value;\n            },\n            get _options () {\n                return _options;\n            },\n            set _options (value){\n                _options = {\n                    ..._options,\n                    ...value\n                };\n            }\n        },\n        trigger,\n        register,\n        handleSubmit,\n        watch,\n        setValue,\n        getValues,\n        reset,\n        resetField,\n        clearErrors,\n        unregister,\n        setError,\n        setFocus,\n        getFieldState\n    };\n}\n/**\n * Custom hook to manage the entire form.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\n *\n * @param props - form configuration and validation parameters.\n *\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   console.log(watch(\"example\"));\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input defaultValue=\"test\" {...register(\"example\")} />\n *       <input {...register(\"exampleRequired\", { required: true })} />\n *       {errors.exampleRequired && <span>This field is required</span>}\n *       <button>Submit</button>\n *     </form>\n *   );\n * }\n * ```\n */ function useForm(props = {}) {\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isDirty: false,\n        isValidating: false,\n        isLoading: isFunction(props.defaultValues),\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        submitCount: 0,\n        dirtyFields: {},\n        touchedFields: {},\n        validatingFields: {},\n        errors: props.errors || {},\n        disabled: props.disabled || false,\n        defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues\n    });\n    if (!_formControl.current) {\n        _formControl.current = {\n            ...createFormControl(props),\n            formState\n        };\n    }\n    const control = _formControl.current.control;\n    control._options = props;\n    useSubscribe({\n        subject: control._subjects.state,\n        next: (value1)=>{\n            if (shouldRenderFormState(value1, control._proxyFormState, control._updateFormState, true)) {\n                updateFormState({\n                    ...control._formState\n                });\n            }\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._disableForm(props.disabled), [\n        control,\n        props.disabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (control._proxyFormState.isDirty) {\n            const isDirty = control._getDirty();\n            if (isDirty !== formState.isDirty) {\n                control._subjects.state.next({\n                    isDirty\n                });\n            }\n        }\n    }, [\n        control,\n        formState.isDirty\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.values && !deepEqual(props.values, _values.current)) {\n            control._reset(props.values, control._options.resetOptions);\n            _values.current = props.values;\n            updateFormState((state)=>({\n                    ...state\n                }));\n        } else {\n            control._resetDefaultValues();\n        }\n    }, [\n        props.values,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.errors) {\n            control._setErrors(props.errors);\n        }\n    }, [\n        props.errors,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!control._state.mount) {\n            control._updateValid();\n            control._state.mount = true;\n        }\n        if (control._state.watch) {\n            control._state.watch = false;\n            control._subjects.state.next({\n                ...control._formState\n            });\n        }\n        control._removeUnmounted();\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        props.shouldUnregister && control._subjects.values.next({\n            values: control._getWatch()\n        });\n    }, [\n        props.shouldUnregister,\n        control\n    ]);\n    _formControl.current.formState = getProxyFormState(formState, control);\n    return _formControl.current;\n}\n //# sourceMappingURL=index.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQUFBLGtCQUFlLENBQUNDLFVBQ2RBLFFBQVFDLElBQUksS0FBSztBQ0huQixJQUFBQyxlQUFlLENBQUNDLFNBQWtDQSxrQkFBaUJDO0FDQW5FLElBQUFDLG9CQUFlLENBQUNGLFNBQThDQSxVQUFTO0FDR2hFLE1BQU1HLGVBQWUsQ0FBQ0gsU0FDM0IsT0FBT0EsV0FBVTtBQUVuQixJQUFBSSxXQUFlLENBQW1CSixTQUNoQyxDQUFDRSxrQkFBa0JGLFdBQ25CLENBQUNLLE1BQU1DLE9BQU8sQ0FBQ04sV0FDZkcsYUFBYUgsV0FDYixDQUFDRCxhQUFhQztBQ0xoQixJQUFBTyxnQkFBZSxDQUFDQyxRQUNkSixTQUFTSSxVQUFXQSxNQUFnQkMsTUFBTSxHQUN0Q2IsZ0JBQWlCWSxNQUFnQkMsTUFBTSxJQUNwQ0QsTUFBZ0JDLE1BQU0sQ0FBQ0MsT0FBTyxHQUM5QkYsTUFBZ0JDLE1BQU0sQ0FBQ1QsS0FBSyxHQUMvQlE7QUNWTixJQUFBRyxvQkFBZSxDQUFDQyxPQUNkQSxLQUFLQyxTQUFTLENBQUMsR0FBR0QsS0FBS0UsTUFBTSxDQUFDLG1CQUFtQkY7QUNHbkQsSUFBQUcscUJBQWUsQ0FBQ0MsT0FBK0JKLE9BQzdDSSxNQUFNQyxHQUFHLENBQUNOLGtCQUFrQkM7QUNIOUIsSUFBQU0sZ0JBQWUsQ0FBQ0M7SUFDZCxNQUFNQyxnQkFDSkQsV0FBV0UsV0FBVyxJQUFJRixXQUFXRSxXQUFXLENBQUNDLFNBQVM7SUFFNUQsT0FDRWxCLFNBQVNnQixrQkFBa0JBLGNBQWNHLGNBQWMsQ0FBQztBQUU1RDtBQ1RBLElBQUFDLFFBQWUsTUFDaUIsSUFDOUIsQ0FBb0I7QUNFRSxTQUFBSSxZQUFlQyxJQUFPO0lBQzVDLElBQUlDO0lBQ0osTUFBTXhCLFVBQVVELE1BQU1DLE9BQU8sQ0FBQ3VCO0lBRTlCLElBQUlB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QUNMbEQsUUFBUWdjLG1CQUFtQjs7T0FFNUI7UUFBQ3RjLE1BQU1xRSxNQUFNO1FBQUUvRDtLQUFRO0lBRTFCWCw0Q0FBZSxDQUFDO1FBQ2QsSUFBSUssTUFBTW9ELE1BQU0sRUFBRTtZQUNoQjlDLFFBQVFnVyxVQUFVLENBQUN0VyxNQUFNb0QsTUFBTTs7T0FFaEM7UUFBQ3BELE1BQU1vRCxNQUFNO1FBQUU5QztLQUFRO0lBRTFCWCw0Q0FBZSxDQUFDO1FBQ2QsSUFBSSxDQUFDVyxRQUFRa0YsTUFBTSxDQUFDRCxLQUFLLEVBQUU7WUFDekJqRixRQUFRbUQsWUFBWTtZQUNwQm5ELFFBQVFrRixNQUFNLENBQUNELEtBQUssR0FBRzs7UUFHekIsSUFBSWpGLFFBQVFrRixNQUFNLENBQUN6QixLQUFLLEVBQUU7WUFDeEJ6RCxRQUFRa0YsTUFBTSxDQUFDekIsS0FBSyxHQUFHO1lBQ3ZCekQsUUFBUWlELFNBQVMsQ0FBQ0MsS0FBSyxDQUFDbkIsSUFBSSxDQUFDO2dCQUFFLEdBQUcvQixRQUFRb0MsVUFBVTtZQUFBOztRQUd0RHBDLFFBQVFtRSxnQkFBZ0I7SUFDMUI7SUFFQTlFLDRDQUFlLENBQUM7UUFDZEssTUFBTTJFLGdCQUFnQixJQUNwQnJFLFFBQVFpRCxTQUFTLENBQUNjLE1BQU0sQ0FBQ2hDLElBQUksQ0FBQztZQUM1QmdDLFFBQVEvRCxRQUFRa0UsU0FBUztRQUMxQjtPQUNGO1FBQUN4RSxNQUFNMkUsZ0JBQWdCO1FBQUVyRTtLQUFRO0lBRXBDbWMsYUFBYTFhLE9BQU8sQ0FBQzFCLFNBQVMsR0FBR0Qsa0JBQWtCQyxXQUFXQztJQUU5RCxPQUFPbWMsYUFBYTFhLE9BQU87QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9pc0NoZWNrQm94SW5wdXQudHM/MTJjYiIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9pc0RhdGVPYmplY3QudHM/OTQ2MCIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9pc051bGxPclVuZGVmaW5lZC50cz9jN2EzIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL2lzT2JqZWN0LnRzPzc4MDMiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvbG9naWMvZ2V0RXZlbnRWYWx1ZS50cz82M2YzIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2xvZ2ljL2dldE5vZGVQYXJlbnROYW1lLnRzPzcyYWEiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvbG9naWMvaXNOYW1lSW5GaWVsZEFycmF5LnRzP2FjZTkiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvaXNQbGFpbk9iamVjdC50cz9lOWZhIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL2lzV2ViLnRzPzc1ZGIiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvY2xvbmVPYmplY3QudHM/ZGQ1ZCIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9jb21wYWN0LnRzPzZjMWMiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvaXNVbmRlZmluZWQudHM/YzI4ZSIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9nZXQudHM/Nzk3NSIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9pc0Jvb2xlYW4udHM/M2UwMCIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9pc0tleS50cz82M2Y2Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL3N0cmluZ1RvUGF0aC50cz9mNTk5Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL3NldC50cz9lZmY2Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2NvbnN0YW50cy50cz9iMTNlIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3VzZUZvcm1Db250ZXh0LnRzeD81NTJjIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2xvZ2ljL2dldFByb3h5Rm9ybVN0YXRlLnRzP2FlZTMiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvaXNFbXB0eU9iamVjdC50cz83MDgwIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2xvZ2ljL3Nob3VsZFJlbmRlckZvcm1TdGF0ZS50cz9jYjc0Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL2NvbnZlcnRUb0FycmF5UGF5bG9hZC50cz82NWU5Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2xvZ2ljL3Nob3VsZFN1YnNjcmliZUJ5TmFtZS50cz85NzAzIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3VzZVN1YnNjcmliZS50cz85ZmU3Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3VzZUZvcm1TdGF0ZS50cz8zNzRkIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL2lzU3RyaW5nLnRzP2Q1MzUiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvbG9naWMvZ2VuZXJhdGVXYXRjaE91dHB1dC50cz8xNmI2Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3VzZVdhdGNoLnRzP2UwYjciLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXNlQ29udHJvbGxlci50cz80NzJkIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2NvbnRyb2xsZXIudHN4Pzk0ZDkiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvZm9ybS50c3g/YTkxMCIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9hcHBlbmRFcnJvcnMudHM/NGRiOSIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9nZW5lcmF0ZUlkLnRzP2E3NmIiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvbG9naWMvZ2V0Rm9jdXNGaWVsZE5hbWUudHM/NTkzYiIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9nZXRWYWxpZGF0aW9uTW9kZXMudHM/YjA5NSIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9pc1dhdGNoZWQudHM/ZGExNyIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9pdGVyYXRlRmllbGRzQnlBY3Rpb24udHM/YWQwNyIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy91cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yLnRzP2JkYmUiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvaXNGaWxlSW5wdXQudHM/MTRjMyIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9pc0Z1bmN0aW9uLnRzP2Q1ZWIiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvaXNIVE1MRWxlbWVudC50cz9iM2E1Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL2lzTWVzc2FnZS50cz9kNzA2Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL2lzUmFkaW9JbnB1dC50cz9hNWMxIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL2lzUmVnZXgudHM/ZjllMCIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9nZXRDaGVja2JveFZhbHVlLnRzPzQ3NmYiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvbG9naWMvZ2V0UmFkaW9WYWx1ZS50cz9jODIyIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2xvZ2ljL2dldFZhbGlkYXRlRXJyb3IudHM/MWY5ZCIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9nZXRWYWx1ZUFuZE1lc3NhZ2UudHM/YzliNSIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy92YWxpZGF0ZUZpZWxkLnRzPzkzMzAiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvYXBwZW5kLnRzP2JlZTQiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvZmlsbEVtcHR5QXJyYXkudHM/OWE4MyIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9pbnNlcnQudHM/MDk1ZCIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9tb3ZlLnRzPzAyNDMiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvcHJlcGVuZC50cz8yYmMwIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL3JlbW92ZS50cz82YTVkIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL3N3YXAudHM/Njk3YSIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy91bnNldC50cz82OGI1Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3V0aWxzL3VwZGF0ZS50cz8wMTM0Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL3VzZUZpZWxkQXJyYXkudHM/MWUwMiIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9jcmVhdGVTdWJqZWN0LnRzP2IzMDYiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvaXNQcmltaXRpdmUudHM/NzViYiIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9kZWVwRXF1YWwudHM/YzFkMiIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9pc011bHRpcGxlU2VsZWN0LnRzPzlmNWMiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvaXNSYWRpb09yQ2hlY2tib3gudHM/NTg0NCIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy91dGlscy9saXZlLnRzPzBhNzkiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXRpbHMvb2JqZWN0SGFzRnVuY3Rpb24udHM/ZmExNiIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9nZXREaXJ0eUZpZWxkcy50cz8xNGNiIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2xvZ2ljL2dldEZpZWxkVmFsdWVBcy50cz80OWFmIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2xvZ2ljL2dldEZpZWxkVmFsdWUudHM/NDI2YSIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9nZXRSZXNvbHZlck9wdGlvbnMudHM/ZDI0NSIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9nZXRSdWxlVmFsdWUudHM/N2I0ZSIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9oYXNWYWxpZGF0aW9uLnRzP2M5MTIiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvbG9naWMvc2NoZW1hRXJyb3JMb29rdXAudHM/ZjZhNyIsIndlYnBhY2s6Ly9zaWduYWxjb25zby13ZWJzaXRlLy4uL3NyYy9sb2dpYy9za2lwVmFsaWRhdGlvbi50cz8xMDA0Iiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2xvZ2ljL3Vuc2V0RW1wdHlBcnJheS50cz82ZWUwIiwid2VicGFjazovL3NpZ25hbGNvbnNvLXdlYnNpdGUvLi4vc3JjL2xvZ2ljL2NyZWF0ZUZvcm1Db250cm9sLnRzPzIwZDAiLCJ3ZWJwYWNrOi8vc2lnbmFsY29uc28td2Vic2l0ZS8uLi9zcmMvdXNlRm9ybS50cz9iNzYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZpZWxkRWxlbWVudCB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgKGVsZW1lbnQ6IEZpZWxkRWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTElucHV0RWxlbWVudCA9PlxuICBlbGVtZW50LnR5cGUgPT09ICdjaGVja2JveCc7XG4iLCJleHBvcnQgZGVmYXVsdCAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBEYXRlID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbiIsImV4cG9ydCBkZWZhdWx0ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bGwgfCB1bmRlZmluZWQgPT4gdmFsdWUgPT0gbnVsbDtcbiIsImltcG9ydCBpc0RhdGVPYmplY3QgZnJvbSAnLi9pc0RhdGVPYmplY3QnO1xuaW1wb3J0IGlzTnVsbE9yVW5kZWZpbmVkIGZyb20gJy4vaXNOdWxsT3JVbmRlZmluZWQnO1xuXG5leHBvcnQgY29uc3QgaXNPYmplY3RUeXBlID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgb2JqZWN0ID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IDxUIGV4dGVuZHMgb2JqZWN0Pih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFQgPT5cbiAgIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJlxuICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgaXNPYmplY3RUeXBlKHZhbHVlKSAmJlxuICAhaXNEYXRlT2JqZWN0KHZhbHVlKTtcbiIsImltcG9ydCBpc0NoZWNrQm94SW5wdXQgZnJvbSAnLi4vdXRpbHMvaXNDaGVja0JveElucHV0JztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuLi91dGlscy9pc09iamVjdCc7XG5cbnR5cGUgRXZlbnQgPSB7IHRhcmdldDogYW55IH07XG5cbmV4cG9ydCBkZWZhdWx0IChldmVudDogdW5rbm93bikgPT5cbiAgaXNPYmplY3QoZXZlbnQpICYmIChldmVudCBhcyBFdmVudCkudGFyZ2V0XG4gICAgPyBpc0NoZWNrQm94SW5wdXQoKGV2ZW50IGFzIEV2ZW50KS50YXJnZXQpXG4gICAgICA/IChldmVudCBhcyBFdmVudCkudGFyZ2V0LmNoZWNrZWRcbiAgICAgIDogKGV2ZW50IGFzIEV2ZW50KS50YXJnZXQudmFsdWVcbiAgICA6IGV2ZW50O1xuIiwiZXhwb3J0IGRlZmF1bHQgKG5hbWU6IHN0cmluZykgPT5cbiAgbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5zZWFyY2goL1xcLlxcZCsoXFwufCQpLykpIHx8IG5hbWU7XG4iLCJpbXBvcnQgeyBJbnRlcm5hbEZpZWxkTmFtZSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IGdldE5vZGVQYXJlbnROYW1lIGZyb20gJy4vZ2V0Tm9kZVBhcmVudE5hbWUnO1xuXG5leHBvcnQgZGVmYXVsdCAobmFtZXM6IFNldDxJbnRlcm5hbEZpZWxkTmFtZT4sIG5hbWU6IEludGVybmFsRmllbGROYW1lKSA9PlxuICBuYW1lcy5oYXMoZ2V0Tm9kZVBhcmVudE5hbWUobmFtZSkpO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QnO1xuXG5leHBvcnQgZGVmYXVsdCAodGVtcE9iamVjdDogb2JqZWN0KSA9PiB7XG4gIGNvbnN0IHByb3RvdHlwZUNvcHkgPVxuICAgIHRlbXBPYmplY3QuY29uc3RydWN0b3IgJiYgdGVtcE9iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgcmV0dXJuIChcbiAgICBpc09iamVjdChwcm90b3R5cGVDb3B5KSAmJiBwcm90b3R5cGVDb3B5Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJylcbiAgKTtcbn07XG4iLCJleHBvcnQgZGVmYXVsdCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0JztcbmltcG9ydCBpc1dlYiBmcm9tICcuL2lzV2ViJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xvbmVPYmplY3Q8VD4oZGF0YTogVCk6IFQge1xuICBsZXQgY29weTogYW55O1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShkYXRhKTtcblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBjb3B5ID0gbmV3IERhdGUoZGF0YSk7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFNldCkge1xuICAgIGNvcHkgPSBuZXcgU2V0KGRhdGEpO1xuICB9IGVsc2UgaWYgKFxuICAgICEoaXNXZWIgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IGRhdGEgaW5zdGFuY2VvZiBGaWxlTGlzdCkpICYmXG4gICAgKGlzQXJyYXkgfHwgaXNPYmplY3QoZGF0YSkpXG4gICkge1xuICAgIGNvcHkgPSBpc0FycmF5ID8gW10gOiB7fTtcblxuICAgIGlmICghaXNBcnJheSAmJiAhaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgY29weSA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvcHlba2V5XSA9IGNsb25lT2JqZWN0KGRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IDxUVmFsdWU+KHZhbHVlOiBUVmFsdWVbXSkgPT5cbiAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiIsImV4cG9ydCBkZWZhdWx0ICh2YWw6IHVua25vd24pOiB2YWwgaXMgdW5kZWZpbmVkID0+IHZhbCA9PT0gdW5kZWZpbmVkO1xuIiwiaW1wb3J0IGNvbXBhY3QgZnJvbSAnLi9jb21wYWN0JztcbmltcG9ydCBpc051bGxPclVuZGVmaW5lZCBmcm9tICcuL2lzTnVsbE9yVW5kZWZpbmVkJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0JztcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tICcuL2lzVW5kZWZpbmVkJztcblxuZXhwb3J0IGRlZmF1bHQgPFQ+KG9iamVjdDogVCwgcGF0aD86IHN0cmluZywgZGVmYXVsdFZhbHVlPzogdW5rbm93bik6IGFueSA9PiB7XG4gIGlmICghcGF0aCB8fCAhaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBjb21wYWN0KHBhdGguc3BsaXQoL1ssW1xcXS5dKz8vKSkucmVkdWNlKFxuICAgIChyZXN1bHQsIGtleSkgPT5cbiAgICAgIGlzTnVsbE9yVW5kZWZpbmVkKHJlc3VsdCkgPyByZXN1bHQgOiByZXN1bHRba2V5IGFzIGtleW9mIHt9XSxcbiAgICBvYmplY3QsXG4gICk7XG5cbiAgcmV0dXJuIGlzVW5kZWZpbmVkKHJlc3VsdCkgfHwgcmVzdWx0ID09PSBvYmplY3RcbiAgICA/IGlzVW5kZWZpbmVkKG9iamVjdFtwYXRoIGFzIGtleW9mIFRdKVxuICAgICAgPyBkZWZhdWx0VmFsdWVcbiAgICAgIDogb2JqZWN0W3BhdGggYXMga2V5b2YgVF1cbiAgICA6IHJlc3VsdDtcbn07XG4iLCJleHBvcnQgZGVmYXVsdCAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBib29sZWFuID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuIiwiZXhwb3J0IGRlZmF1bHQgKHZhbHVlOiBzdHJpbmcpID0+IC9eXFx3KiQvLnRlc3QodmFsdWUpO1xuIiwiaW1wb3J0IGNvbXBhY3QgZnJvbSAnLi9jb21wYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgKGlucHV0OiBzdHJpbmcpOiBzdHJpbmdbXSA9PlxuICBjb21wYWN0KGlucHV0LnJlcGxhY2UoL1tcInwnXXxcXF0vZywgJycpLnNwbGl0KC9cXC58XFxbLykpO1xuIiwiaW1wb3J0IHsgRmllbGRWYWx1ZXMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCBpc0tleSBmcm9tICcuL2lzS2V5JztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0JztcbmltcG9ydCBzdHJpbmdUb1BhdGggZnJvbSAnLi9zdHJpbmdUb1BhdGgnO1xuXG5leHBvcnQgZGVmYXVsdCAob2JqZWN0OiBGaWVsZFZhbHVlcywgcGF0aDogc3RyaW5nLCB2YWx1ZT86IHVua25vd24pID0+IHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGNvbnN0IHRlbXBQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCk7XG4gIGNvbnN0IGxlbmd0aCA9IHRlbXBQYXRoLmxlbmd0aDtcbiAgY29uc3QgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGNvbnN0IGtleSA9IHRlbXBQYXRoW2luZGV4XTtcbiAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChpbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICBjb25zdCBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgbmV3VmFsdWUgPVxuICAgICAgICBpc09iamVjdChvYmpWYWx1ZSkgfHwgQXJyYXkuaXNBcnJheShvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAhaXNOYU4oK3RlbXBQYXRoW2luZGV4ICsgMV0pXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDoge307XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvYmplY3Rba2V5XSA9IG5ld1ZhbHVlO1xuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwiZXhwb3J0IGNvbnN0IEVWRU5UUyA9IHtcbiAgQkxVUjogJ2JsdXInLFxuICBGT0NVU19PVVQ6ICdmb2N1c291dCcsXG4gIENIQU5HRTogJ2NoYW5nZScsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgVkFMSURBVElPTl9NT0RFID0ge1xuICBvbkJsdXI6ICdvbkJsdXInLFxuICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcbiAgb25TdWJtaXQ6ICdvblN1Ym1pdCcsXG4gIG9uVG91Y2hlZDogJ29uVG91Y2hlZCcsXG4gIGFsbDogJ2FsbCcsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgSU5QVVRfVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgbWF4OiAnbWF4JyxcbiAgbWluOiAnbWluJyxcbiAgbWF4TGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWluTGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgdmFsaWRhdGU6ICd2YWxpZGF0ZScsXG59IGFzIGNvbnN0O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRmllbGRWYWx1ZXMsIEZvcm1Qcm92aWRlclByb3BzLCBVc2VGb3JtUmV0dXJuIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IEhvb2tGb3JtQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8VXNlRm9ybVJldHVybiB8IG51bGw+KG51bGwpO1xuXG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBhY2Nlc3MgdGhlIGZvcm0gY29udGV4dC4gdXNlRm9ybUNvbnRleHQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBkZWVwbHkgbmVzdGVkIHN0cnVjdHVyZXMsIHdoZXJlIGl0IHdvdWxkIGJlY29tZSBpbmNvbnZlbmllbnQgdG8gcGFzcyB0aGUgY29udGV4dCBhcyBhIHByb3AuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgRm9ybVByb3ZpZGVyfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybWNvbnRleHQpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny1mb3JtLWNvbnRleHQteXR1ZGkpXG4gKlxuICogQHJldHVybnMgcmV0dXJuIGFsbCB1c2VGb3JtIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxuICogICAgICAgPGZvcm0gb25TdWJtaXQ9e21ldGhvZHMuaGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICAgIDxOZXN0ZWRJbnB1dCAvPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgICA8L2Zvcm0+XG4gKiAgICAgPC9Gb3JtUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKlxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB1c2VGb3JtQ29udGV4dCgpOyAvLyByZXRyaWV2ZSBhbGwgaG9vayBtZXRob2RzXG4gKiAgIHJldHVybiA8aW5wdXQgey4uLnJlZ2lzdGVyKFwidGVzdFwiKX0gLz47XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZUZvcm1Db250ZXh0ID0gPFxuICBURmllbGRWYWx1ZXMgZXh0ZW5kcyBGaWVsZFZhbHVlcyxcbiAgVENvbnRleHQgPSBhbnksXG4gIFRyYW5zZm9ybWVkVmFsdWVzIGV4dGVuZHMgRmllbGRWYWx1ZXMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4+KCk6IFVzZUZvcm1SZXR1cm48VEZpZWxkVmFsdWVzLCBUQ29udGV4dCwgVHJhbnNmb3JtZWRWYWx1ZXM+ID0+XG4gIFJlYWN0LnVzZUNvbnRleHQoSG9va0Zvcm1Db250ZXh0KSBhcyBVc2VGb3JtUmV0dXJuPFxuICAgIFRGaWVsZFZhbHVlcyxcbiAgICBUQ29udGV4dCxcbiAgICBUcmFuc2Zvcm1lZFZhbHVlc1xuICA+O1xuXG4vKipcbiAqIEEgcHJvdmlkZXIgY29tcG9uZW50IHRoYXQgcHJvcGFnYXRlcyB0aGUgYHVzZUZvcm1gIG1ldGhvZHMgdG8gYWxsIGNoaWxkcmVuIGNvbXBvbmVudHMgdmlhIFtSZWFjdCBDb250ZXh0XShodHRwczovL3JlYWN0anMub3JnL2RvY3MvY29udGV4dC5odG1sKSBBUEkuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgdXNlRm9ybUNvbnRleHR9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBhbGwgdXNlRm9ybSBtZXRob2RzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBtZXRob2RzID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtUHJvdmlkZXIgey4uLm1ldGhvZHN9ID5cbiAqICAgICAgIDxmb3JtIG9uU3VibWl0PXttZXRob2RzLmhhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgICA8TmVzdGVkSW5wdXQgLz5cbiAqICAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgICAgPC9mb3JtPlxuICogICAgIDwvRm9ybVByb3ZpZGVyPlxuICogICApO1xuICogfVxuICpcbiAqICBmdW5jdGlvbiBOZXN0ZWRJbnB1dCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciB9ID0gdXNlRm9ybUNvbnRleHQoKTsgLy8gcmV0cmlldmUgYWxsIGhvb2sgbWV0aG9kc1xuICogICByZXR1cm4gPGlucHV0IHsuLi5yZWdpc3RlcihcInRlc3RcIil9IC8+O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBGb3JtUHJvdmlkZXIgPSA8XG4gIFRGaWVsZFZhbHVlcyBleHRlbmRzIEZpZWxkVmFsdWVzLFxuICBUQ29udGV4dCA9IGFueSxcbiAgVFRyYW5zZm9ybWVkVmFsdWVzIGV4dGVuZHMgRmllbGRWYWx1ZXMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4+KFxuICBwcm9wczogRm9ybVByb3ZpZGVyUHJvcHM8VEZpZWxkVmFsdWVzLCBUQ29udGV4dCwgVFRyYW5zZm9ybWVkVmFsdWVzPixcbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCAuLi5kYXRhIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8SG9va0Zvcm1Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtkYXRhIGFzIHVua25vd24gYXMgVXNlRm9ybVJldHVybn0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Ib29rRm9ybUNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuIiwiaW1wb3J0IHsgVkFMSURBVElPTl9NT0RFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IENvbnRyb2wsIEZpZWxkVmFsdWVzLCBGb3JtU3RhdGUsIFJlYWRGb3JtU3RhdGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IDxURmllbGRWYWx1ZXMgZXh0ZW5kcyBGaWVsZFZhbHVlcywgVENvbnRleHQgPSBhbnk+KFxuICBmb3JtU3RhdGU6IEZvcm1TdGF0ZTxURmllbGRWYWx1ZXM+LFxuICBjb250cm9sOiBDb250cm9sPFRGaWVsZFZhbHVlcywgVENvbnRleHQ+LFxuICBsb2NhbFByb3h5Rm9ybVN0YXRlPzogUmVhZEZvcm1TdGF0ZSxcbiAgaXNSb290ID0gdHJ1ZSxcbikgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgZGVmYXVsdFZhbHVlczogY29udHJvbC5fZGVmYXVsdFZhbHVlcyxcbiAgfSBhcyB0eXBlb2YgZm9ybVN0YXRlO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGZvcm1TdGF0ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwge1xuICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IF9rZXkgPSBrZXkgYXMga2V5b2YgRm9ybVN0YXRlPFRGaWVsZFZhbHVlcz4gJiBrZXlvZiBSZWFkRm9ybVN0YXRlO1xuXG4gICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSAhPT0gVkFMSURBVElPTl9NT0RFLmFsbCkge1xuICAgICAgICAgIGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlW19rZXldID0gIWlzUm9vdCB8fCBWQUxJREFUSU9OX01PREUuYWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxQcm94eUZvcm1TdGF0ZSAmJiAobG9jYWxQcm94eUZvcm1TdGF0ZVtfa2V5XSA9IHRydWUpO1xuICAgICAgICByZXR1cm4gZm9ybVN0YXRlW19rZXldO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiaW1wb3J0IHsgRW1wdHlPYmplY3QgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgRW1wdHlPYmplY3QgPT5cbiAgaXNPYmplY3QodmFsdWUpICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuIiwiaW1wb3J0IHsgVkFMSURBVElPTl9NT0RFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIENvbnRyb2wsXG4gIEZpZWxkVmFsdWVzLFxuICBGb3JtU3RhdGUsXG4gIEludGVybmFsRmllbGROYW1lLFxuICBSZWFkRm9ybVN0YXRlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgaXNFbXB0eU9iamVjdCBmcm9tICcuLi91dGlscy9pc0VtcHR5T2JqZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgPFQgZXh0ZW5kcyBGaWVsZFZhbHVlcywgSyBleHRlbmRzIFJlYWRGb3JtU3RhdGU+KFxuICBmb3JtU3RhdGVEYXRhOiBQYXJ0aWFsPEZvcm1TdGF0ZTxUPj4gJiB7IG5hbWU/OiBJbnRlcm5hbEZpZWxkTmFtZSB9LFxuICBfcHJveHlGb3JtU3RhdGU6IEssXG4gIHVwZGF0ZUZvcm1TdGF0ZTogQ29udHJvbDxUPlsnX3VwZGF0ZUZvcm1TdGF0ZSddLFxuICBpc1Jvb3Q/OiBib29sZWFuLFxuKSA9PiB7XG4gIHVwZGF0ZUZvcm1TdGF0ZShmb3JtU3RhdGVEYXRhKTtcbiAgY29uc3QgeyBuYW1lLCAuLi5mb3JtU3RhdGUgfSA9IGZvcm1TdGF0ZURhdGE7XG5cbiAgcmV0dXJuIChcbiAgICBpc0VtcHR5T2JqZWN0KGZvcm1TdGF0ZSkgfHxcbiAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmxlbmd0aCA+PSBPYmplY3Qua2V5cyhfcHJveHlGb3JtU3RhdGUpLmxlbmd0aCB8fFxuICAgIE9iamVjdC5rZXlzKGZvcm1TdGF0ZSkuZmluZChcbiAgICAgIChrZXkpID0+XG4gICAgICAgIF9wcm94eUZvcm1TdGF0ZVtrZXkgYXMga2V5b2YgUmVhZEZvcm1TdGF0ZV0gPT09XG4gICAgICAgICghaXNSb290IHx8IFZBTElEQVRJT05fTU9ERS5hbGwpLFxuICAgIClcbiAgKTtcbn07XG4iLCJleHBvcnQgZGVmYXVsdCA8VD4odmFsdWU6IFQpID0+IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSk7XG4iLCJpbXBvcnQgY29udmVydFRvQXJyYXlQYXlsb2FkIGZyb20gJy4uL3V0aWxzL2NvbnZlcnRUb0FycmF5UGF5bG9hZCc7XG5cbmV4cG9ydCBkZWZhdWx0IDxUIGV4dGVuZHMgc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQ+KFxuICBuYW1lPzogVCxcbiAgc2lnbmFsTmFtZT86IHN0cmluZyxcbiAgZXhhY3Q/OiBib29sZWFuLFxuKSA9PlxuICAhbmFtZSB8fFxuICAhc2lnbmFsTmFtZSB8fFxuICBuYW1lID09PSBzaWduYWxOYW1lIHx8XG4gIGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKS5zb21lKFxuICAgIChjdXJyZW50TmFtZSkgPT5cbiAgICAgIGN1cnJlbnROYW1lICYmXG4gICAgICAoZXhhY3RcbiAgICAgICAgPyBjdXJyZW50TmFtZSA9PT0gc2lnbmFsTmFtZVxuICAgICAgICA6IGN1cnJlbnROYW1lLnN0YXJ0c1dpdGgoc2lnbmFsTmFtZSkgfHxcbiAgICAgICAgICBzaWduYWxOYW1lLnN0YXJ0c1dpdGgoY3VycmVudE5hbWUpKSxcbiAgKTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZVN1YmplY3QnO1xuXG50eXBlIFByb3BzPFQ+ID0ge1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG4gIHN1YmplY3Q6IFN1YmplY3Q8VD47XG4gIG5leHQ6ICh2YWx1ZTogVCkgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdWJzY3JpYmU8VD4ocHJvcHM6IFByb3BzPFQ+KSB7XG4gIGNvbnN0IF9wcm9wcyA9IFJlYWN0LnVzZVJlZihwcm9wcyk7XG4gIF9wcm9wcy5jdXJyZW50ID0gcHJvcHM7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPVxuICAgICAgIXByb3BzLmRpc2FibGVkICYmXG4gICAgICBfcHJvcHMuY3VycmVudC5zdWJqZWN0ICYmXG4gICAgICBfcHJvcHMuY3VycmVudC5zdWJqZWN0LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IF9wcm9wcy5jdXJyZW50Lm5leHQsXG4gICAgICB9KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24gJiYgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW3Byb3BzLmRpc2FibGVkXSk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgZ2V0UHJveHlGb3JtU3RhdGUgZnJvbSAnLi9sb2dpYy9nZXRQcm94eUZvcm1TdGF0ZSc7XG5pbXBvcnQgc2hvdWxkUmVuZGVyRm9ybVN0YXRlIGZyb20gJy4vbG9naWMvc2hvdWxkUmVuZGVyRm9ybVN0YXRlJztcbmltcG9ydCBzaG91bGRTdWJzY3JpYmVCeU5hbWUgZnJvbSAnLi9sb2dpYy9zaG91bGRTdWJzY3JpYmVCeU5hbWUnO1xuaW1wb3J0IHtcbiAgRmllbGRWYWx1ZXMsXG4gIEZvcm1TdGF0ZSxcbiAgSW50ZXJuYWxGaWVsZE5hbWUsXG4gIFVzZUZvcm1TdGF0ZVByb3BzLFxuICBVc2VGb3JtU3RhdGVSZXR1cm4sXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgdXNlRm9ybUNvbnRleHQgfSBmcm9tICcuL3VzZUZvcm1Db250ZXh0JztcbmltcG9ydCB7IHVzZVN1YnNjcmliZSB9IGZyb20gJy4vdXNlU3Vic2NyaWJlJztcblxuLyoqXG4gKiBUaGlzIGN1c3RvbSBob29rIGFsbG93cyB5b3UgdG8gc3Vic2NyaWJlIHRvIGVhY2ggZm9ybSBzdGF0ZSwgYW5kIGlzb2xhdGUgdGhlIHJlLXJlbmRlciBhdCB0aGUgY3VzdG9tIGhvb2sgbGV2ZWwuIEl0IGhhcyBpdHMgc2NvcGUgaW4gdGVybXMgb2YgZm9ybSBzdGF0ZSBzdWJzY3JpcHRpb24sIHNvIGl0IHdvdWxkIG5vdCBhZmZlY3Qgb3RoZXIgdXNlRm9ybVN0YXRlIGFuZCB1c2VGb3JtLiBVc2luZyB0aGlzIGhvb2sgY2FuIHJlZHVjZSB0aGUgcmUtcmVuZGVyIGltcGFjdCBvbiBsYXJnZSBhbmQgY29tcGxleCBmb3JtIGFwcGxpY2F0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3Jtc3RhdGUpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3VzZWZvcm1zdGF0ZS03NXhseSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBpbmNsdWRlIG9wdGlvbnMgb24gc3BlY2lmeSBmaWVsZHMgdG8gc3Vic2NyaWJlLiB7QGxpbmsgVXNlRm9ybVN0YXRlUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciwgaGFuZGxlU3VibWl0LCBjb250cm9sIH0gPSB1c2VGb3JtKHtcbiAqICAgICBkZWZhdWx0VmFsdWVzOiB7XG4gKiAgICAgZmlyc3ROYW1lOiBcImZpcnN0TmFtZVwiXG4gKiAgIH19KTtcbiAqICAgY29uc3QgeyBkaXJ0eUZpZWxkcyB9ID0gdXNlRm9ybVN0YXRlKHtcbiAqICAgICBjb250cm9sXG4gKiAgIH0pO1xuICogICBjb25zdCBvblN1Ym1pdCA9IChkYXRhKSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcImZpcnN0TmFtZVwiKX0gcGxhY2Vob2xkZXI9XCJGaXJzdCBOYW1lXCIgLz5cbiAqICAgICAgIHtkaXJ0eUZpZWxkcy5maXJzdE5hbWUgJiYgPHA+RmllbGQgaXMgZGlydHkuPC9wPn1cbiAqICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRm9ybVN0YXRlPFRGaWVsZFZhbHVlcyBleHRlbmRzIEZpZWxkVmFsdWVzID0gRmllbGRWYWx1ZXM+KFxuICBwcm9wcz86IFVzZUZvcm1TdGF0ZVByb3BzPFRGaWVsZFZhbHVlcz4sXG4pOiBVc2VGb3JtU3RhdGVSZXR1cm48VEZpZWxkVmFsdWVzPiB7XG4gIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dDxURmllbGRWYWx1ZXM+KCk7XG4gIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgZGlzYWJsZWQsIG5hbWUsIGV4YWN0IH0gPSBwcm9wcyB8fCB7fTtcbiAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGNvbnRyb2wuX2Zvcm1TdGF0ZSk7XG4gIGNvbnN0IF9tb3VudGVkID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCBfbG9jYWxQcm94eUZvcm1TdGF0ZSA9IFJlYWN0LnVzZVJlZih7XG4gICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBkaXJ0eUZpZWxkczogZmFsc2UsXG4gICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgdmFsaWRhdGluZ0ZpZWxkczogZmFsc2UsXG4gICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICBlcnJvcnM6IGZhbHNlLFxuICB9KTtcbiAgY29uc3QgX25hbWUgPSBSZWFjdC51c2VSZWYobmFtZSk7XG5cbiAgX25hbWUuY3VycmVudCA9IG5hbWU7XG5cbiAgdXNlU3Vic2NyaWJlKHtcbiAgICBkaXNhYmxlZCxcbiAgICBuZXh0OiAoXG4gICAgICB2YWx1ZTogUGFydGlhbDxGb3JtU3RhdGU8VEZpZWxkVmFsdWVzPj4gJiB7IG5hbWU/OiBJbnRlcm5hbEZpZWxkTmFtZSB9LFxuICAgICkgPT5cbiAgICAgIF9tb3VudGVkLmN1cnJlbnQgJiZcbiAgICAgIHNob3VsZFN1YnNjcmliZUJ5TmFtZShcbiAgICAgICAgX25hbWUuY3VycmVudCBhcyBJbnRlcm5hbEZpZWxkTmFtZSxcbiAgICAgICAgdmFsdWUubmFtZSxcbiAgICAgICAgZXhhY3QsXG4gICAgICApICYmXG4gICAgICBzaG91bGRSZW5kZXJGb3JtU3RhdGUoXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LFxuICAgICAgICBjb250cm9sLl91cGRhdGVGb3JtU3RhdGUsXG4gICAgICApICYmXG4gICAgICB1cGRhdGVGb3JtU3RhdGUoe1xuICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICAgIC4uLnZhbHVlLFxuICAgICAgfSksXG4gICAgc3ViamVjdDogY29udHJvbC5fc3ViamVjdHMuc3RhdGUsXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgX21vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudC5pc1ZhbGlkICYmIGNvbnRyb2wuX3VwZGF0ZVZhbGlkKHRydWUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIF9tb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbY29udHJvbF0pO1xuXG4gIHJldHVybiBnZXRQcm94eUZvcm1TdGF0ZShcbiAgICBmb3JtU3RhdGUsXG4gICAgY29udHJvbCxcbiAgICBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LFxuICAgIGZhbHNlLFxuICApO1xufVxuXG5leHBvcnQgeyB1c2VGb3JtU3RhdGUgfTtcbiIsImV4cG9ydCBkZWZhdWx0ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIHN0cmluZyA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuIiwiaW1wb3J0IHsgRGVlcFBhcnRpYWwsIEZpZWxkVmFsdWVzLCBOYW1lcyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXQgZnJvbSAnLi4vdXRpbHMvZ2V0JztcbmltcG9ydCBpc1N0cmluZyBmcm9tICcuLi91dGlscy9pc1N0cmluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IDxUPihcbiAgbmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkLFxuICBfbmFtZXM6IE5hbWVzLFxuICBmb3JtVmFsdWVzPzogRmllbGRWYWx1ZXMsXG4gIGlzR2xvYmFsPzogYm9vbGVhbixcbiAgZGVmYXVsdFZhbHVlPzogRGVlcFBhcnRpYWw8VD4gfCB1bmtub3duLFxuKSA9PiB7XG4gIGlmIChpc1N0cmluZyhuYW1lcykpIHtcbiAgICBpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKG5hbWVzKTtcbiAgICByZXR1cm4gZ2V0KGZvcm1WYWx1ZXMsIG5hbWVzLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmFtZXMpKSB7XG4gICAgcmV0dXJuIG5hbWVzLm1hcChcbiAgICAgIChmaWVsZE5hbWUpID0+IChcbiAgICAgICAgaXNHbG9iYWwgJiYgX25hbWVzLndhdGNoLmFkZChmaWVsZE5hbWUpLCBnZXQoZm9ybVZhbHVlcywgZmllbGROYW1lKVxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgaXNHbG9iYWwgJiYgKF9uYW1lcy53YXRjaEFsbCA9IHRydWUpO1xuXG4gIHJldHVybiBmb3JtVmFsdWVzO1xufTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBnZW5lcmF0ZVdhdGNoT3V0cHV0IGZyb20gJy4vbG9naWMvZ2VuZXJhdGVXYXRjaE91dHB1dCc7XG5pbXBvcnQgc2hvdWxkU3Vic2NyaWJlQnlOYW1lIGZyb20gJy4vbG9naWMvc2hvdWxkU3Vic2NyaWJlQnlOYW1lJztcbmltcG9ydCBjbG9uZU9iamVjdCBmcm9tICcuL3V0aWxzL2Nsb25lT2JqZWN0JztcbmltcG9ydCB7XG4gIENvbnRyb2wsXG4gIERlZXBQYXJ0aWFsU2tpcEFycmF5S2V5LFxuICBGaWVsZFBhdGgsXG4gIEZpZWxkUGF0aFZhbHVlLFxuICBGaWVsZFBhdGhWYWx1ZXMsXG4gIEZpZWxkVmFsdWVzLFxuICBJbnRlcm5hbEZpZWxkTmFtZSxcbiAgVXNlV2F0Y2hQcm9wcyxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyB1c2VGb3JtQ29udGV4dCB9IGZyb20gJy4vdXNlRm9ybUNvbnRleHQnO1xuaW1wb3J0IHsgdXNlU3Vic2NyaWJlIH0gZnJvbSAnLi91c2VTdWJzY3JpYmUnO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byB0aGUgZW50aXJlIGZvcm0gdmFsdWVzIGNoYW5nZSBhbmQgcmUtcmVuZGVyIGF0IHRoZSBob29rIGxldmVsLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNld2F0Y2gpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny10cy11c2V3YXRjaC1oOWk1ZSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBkZWZhdWx0VmFsdWUsIGRpc2FibGUgc3Vic2NyaXB0aW9uIGFuZCBtYXRjaCBleGFjdCBuYW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IHsgY29udHJvbCB9ID0gdXNlRm9ybSgpO1xuICogY29uc3QgdmFsdWVzID0gdXNlV2F0Y2goe1xuICogICBjb250cm9sLFxuICogICBkZWZhdWx0VmFsdWU6IHtcbiAqICAgICBuYW1lOiBcImRhdGFcIlxuICogICB9LFxuICogICBleGFjdDogZmFsc2UsXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VXYXRjaDxcbiAgVEZpZWxkVmFsdWVzIGV4dGVuZHMgRmllbGRWYWx1ZXMgPSBGaWVsZFZhbHVlcyxcbj4ocHJvcHM6IHtcbiAgZGVmYXVsdFZhbHVlPzogRGVlcFBhcnRpYWxTa2lwQXJyYXlLZXk8VEZpZWxkVmFsdWVzPjtcbiAgY29udHJvbD86IENvbnRyb2w8VEZpZWxkVmFsdWVzPjtcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICBleGFjdD86IGJvb2xlYW47XG59KTogRGVlcFBhcnRpYWxTa2lwQXJyYXlLZXk8VEZpZWxkVmFsdWVzPjtcbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gc3Vic2NyaWJlIHRvIGZpZWxkIGNoYW5nZSBhbmQgaXNvbGF0ZSByZS1yZW5kZXJpbmcgYXQgdGhlIGNvbXBvbmVudCBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZXdhdGNoKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctdHMtdXNld2F0Y2gtaDlpNWUpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gZGVmYXVsdFZhbHVlLCBkaXNhYmxlIHN1YnNjcmlwdGlvbiBhbmQgbWF0Y2ggZXhhY3QgbmFtZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm0oKTtcbiAqIGNvbnN0IHZhbHVlcyA9IHVzZVdhdGNoKHtcbiAqICAgY29udHJvbCxcbiAqICAgbmFtZTogXCJmaWVsZEFcIixcbiAqICAgZGVmYXVsdFZhbHVlOiBcImRlZmF1bHQgdmFsdWVcIixcbiAqICAgZXhhY3Q6IGZhbHNlLFxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlV2F0Y2g8XG4gIFRGaWVsZFZhbHVlcyBleHRlbmRzIEZpZWxkVmFsdWVzID0gRmllbGRWYWx1ZXMsXG4gIFRGaWVsZE5hbWUgZXh0ZW5kcyBGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPiA9IEZpZWxkUGF0aDxURmllbGRWYWx1ZXM+LFxuPihwcm9wczoge1xuICBuYW1lOiBURmllbGROYW1lO1xuICBkZWZhdWx0VmFsdWU/OiBGaWVsZFBhdGhWYWx1ZTxURmllbGRWYWx1ZXMsIFRGaWVsZE5hbWU+O1xuICBjb250cm9sPzogQ29udHJvbDxURmllbGRWYWx1ZXM+O1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG4gIGV4YWN0PzogYm9vbGVhbjtcbn0pOiBGaWVsZFBhdGhWYWx1ZTxURmllbGRWYWx1ZXMsIFRGaWVsZE5hbWU+O1xuLyoqXG4gKiBDdXN0b20gaG9vayB0byBzdWJzY3JpYmUgdG8gZmllbGQgY2hhbmdlIGFuZCBpc29sYXRlIHJlLXJlbmRlcmluZyBhdCB0aGUgY29tcG9uZW50IGxldmVsLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNld2F0Y2gpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny10cy11c2V3YXRjaC1oOWk1ZSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBkZWZhdWx0VmFsdWUsIGRpc2FibGUgc3Vic2NyaXB0aW9uIGFuZCBtYXRjaCBleGFjdCBuYW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IHsgY29udHJvbCB9ID0gdXNlRm9ybSgpO1xuICogY29uc3QgdmFsdWVzID0gdXNlV2F0Y2goe1xuICogICBjb250cm9sLFxuICogICBuYW1lOiBbXCJmaWVsZEFcIiwgXCJmaWVsZEJcIl0sXG4gKiAgIGRlZmF1bHRWYWx1ZToge1xuICogICAgIGZpZWxkQTogXCJkYXRhXCIsXG4gKiAgICAgZmllbGRCOiBcImRhdGFcIlxuICogICB9LFxuICogICBleGFjdDogZmFsc2UsXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VXYXRjaDxcbiAgVEZpZWxkVmFsdWVzIGV4dGVuZHMgRmllbGRWYWx1ZXMgPSBGaWVsZFZhbHVlcyxcbiAgVEZpZWxkTmFtZXMgZXh0ZW5kcyByZWFkb25seSBGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPltdID0gcmVhZG9ubHkgRmllbGRQYXRoPFRGaWVsZFZhbHVlcz5bXSxcbj4ocHJvcHM6IHtcbiAgbmFtZTogcmVhZG9ubHkgWy4uLlRGaWVsZE5hbWVzXTtcbiAgZGVmYXVsdFZhbHVlPzogRGVlcFBhcnRpYWxTa2lwQXJyYXlLZXk8VEZpZWxkVmFsdWVzPjtcbiAgY29udHJvbD86IENvbnRyb2w8VEZpZWxkVmFsdWVzPjtcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICBleGFjdD86IGJvb2xlYW47XG59KTogRmllbGRQYXRoVmFsdWVzPFRGaWVsZFZhbHVlcywgVEZpZWxkTmFtZXM+O1xuLyoqXG4gKiBDdXN0b20gaG9vayB0byBzdWJzY3JpYmUgdG8gZmllbGQgY2hhbmdlIGFuZCBpc29sYXRlIHJlLXJlbmRlcmluZyBhdCB0aGUgY29tcG9uZW50IGxldmVsLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNld2F0Y2gpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny10cy11c2V3YXRjaC1oOWk1ZSlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiAvLyBjYW4gc2tpcCBwYXNzaW5nIGRvd24gdGhlIGNvbnRyb2wgaW50byB1c2VXYXRjaCBpZiB0aGUgZm9ybSBpcyB3cmFwcGVkIHdpdGggdGhlIEZvcm1Qcm92aWRlclxuICogY29uc3QgdmFsdWVzID0gdXNlV2F0Y2goKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VXYXRjaDxcbiAgVEZpZWxkVmFsdWVzIGV4dGVuZHMgRmllbGRWYWx1ZXMgPSBGaWVsZFZhbHVlcyxcbj4oKTogRGVlcFBhcnRpYWxTa2lwQXJyYXlLZXk8VEZpZWxkVmFsdWVzPjtcbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gc3Vic2NyaWJlIHRvIGZpZWxkIGNoYW5nZSBhbmQgaXNvbGF0ZSByZS1yZW5kZXJpbmcgYXQgdGhlIGNvbXBvbmVudCBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZXdhdGNoKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctdHMtdXNld2F0Y2gtaDlpNWUpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgeyBjb250cm9sIH0gPSB1c2VGb3JtKCk7XG4gKiBjb25zdCB2YWx1ZXMgPSB1c2VXYXRjaCh7XG4gKiAgIG5hbWU6IFwiZmllbGROYW1lXCJcbiAqICAgY29udHJvbCxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVdhdGNoPFRGaWVsZFZhbHVlcyBleHRlbmRzIEZpZWxkVmFsdWVzPihcbiAgcHJvcHM/OiBVc2VXYXRjaFByb3BzPFRGaWVsZFZhbHVlcz4sXG4pIHtcbiAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XG4gIGNvbnN0IHtcbiAgICBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLFxuICAgIG5hbWUsXG4gICAgZGVmYXVsdFZhbHVlLFxuICAgIGRpc2FibGVkLFxuICAgIGV4YWN0LFxuICB9ID0gcHJvcHMgfHwge307XG4gIGNvbnN0IF9uYW1lID0gUmVhY3QudXNlUmVmKG5hbWUpO1xuXG4gIF9uYW1lLmN1cnJlbnQgPSBuYW1lO1xuXG4gIHVzZVN1YnNjcmliZSh7XG4gICAgZGlzYWJsZWQsXG4gICAgc3ViamVjdDogY29udHJvbC5fc3ViamVjdHMudmFsdWVzLFxuICAgIG5leHQ6IChmb3JtU3RhdGU6IHsgbmFtZT86IEludGVybmFsRmllbGROYW1lOyB2YWx1ZXM/OiBGaWVsZFZhbHVlcyB9KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHNob3VsZFN1YnNjcmliZUJ5TmFtZShcbiAgICAgICAgICBfbmFtZS5jdXJyZW50IGFzIEludGVybmFsRmllbGROYW1lLFxuICAgICAgICAgIGZvcm1TdGF0ZS5uYW1lLFxuICAgICAgICAgIGV4YWN0LFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgdXBkYXRlVmFsdWUoXG4gICAgICAgICAgY2xvbmVPYmplY3QoXG4gICAgICAgICAgICBnZW5lcmF0ZVdhdGNoT3V0cHV0KFxuICAgICAgICAgICAgICBfbmFtZS5jdXJyZW50IGFzIEludGVybmFsRmllbGROYW1lIHwgSW50ZXJuYWxGaWVsZE5hbWVbXSxcbiAgICAgICAgICAgICAgY29udHJvbC5fbmFtZXMsXG4gICAgICAgICAgICAgIGZvcm1TdGF0ZS52YWx1ZXMgfHwgY29udHJvbC5fZm9ybVZhbHVlcyxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcblxuICBjb25zdCBbdmFsdWUsIHVwZGF0ZVZhbHVlXSA9IFJlYWN0LnVzZVN0YXRlKFxuICAgIGNvbnRyb2wuX2dldFdhdGNoKFxuICAgICAgbmFtZSBhcyBJbnRlcm5hbEZpZWxkTmFtZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSBhcyBEZWVwUGFydGlhbFNraXBBcnJheUtleTxURmllbGRWYWx1ZXM+LFxuICAgICksXG4gICk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IGNvbnRyb2wuX3JlbW92ZVVubW91bnRlZCgpKTtcblxuICByZXR1cm4gdmFsdWU7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgZ2V0RXZlbnRWYWx1ZSBmcm9tICcuL2xvZ2ljL2dldEV2ZW50VmFsdWUnO1xuaW1wb3J0IGlzTmFtZUluRmllbGRBcnJheSBmcm9tICcuL2xvZ2ljL2lzTmFtZUluRmllbGRBcnJheSc7XG5pbXBvcnQgY2xvbmVPYmplY3QgZnJvbSAnLi91dGlscy9jbG9uZU9iamVjdCc7XG5pbXBvcnQgZ2V0IGZyb20gJy4vdXRpbHMvZ2V0JztcbmltcG9ydCBpc0Jvb2xlYW4gZnJvbSAnLi91dGlscy9pc0Jvb2xlYW4nO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gJy4vdXRpbHMvaXNVbmRlZmluZWQnO1xuaW1wb3J0IHNldCBmcm9tICcuL3V0aWxzL3NldCc7XG5pbXBvcnQgeyBFVkVOVFMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBDb250cm9sbGVyRmllbGRTdGF0ZSxcbiAgRmllbGQsXG4gIEZpZWxkUGF0aCxcbiAgRmllbGRQYXRoVmFsdWUsXG4gIEZpZWxkVmFsdWVzLFxuICBJbnRlcm5hbEZpZWxkTmFtZSxcbiAgVXNlQ29udHJvbGxlclByb3BzLFxuICBVc2VDb250cm9sbGVyUmV0dXJuLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHVzZUZvcm1Db250ZXh0IH0gZnJvbSAnLi91c2VGb3JtQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VGb3JtU3RhdGUgfSBmcm9tICcuL3VzZUZvcm1TdGF0ZSc7XG5pbXBvcnQgeyB1c2VXYXRjaCB9IGZyb20gJy4vdXNlV2F0Y2gnO1xuXG4vKipcbiAqIEN1c3RvbSBob29rIHRvIHdvcmsgd2l0aCBjb250cm9sbGVkIGNvbXBvbmVudCwgdGhpcyBmdW5jdGlvbiBwcm92aWRlIHlvdSB3aXRoIGJvdGggZm9ybSBhbmQgZmllbGQgbGV2ZWwgc3RhdGUuIFJlLXJlbmRlciBpcyBpc29sYXRlZCBhdCB0aGUgaG9vayBsZXZlbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlY29udHJvbGxlcikg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdXNlY29udHJvbGxlci0wbzhweClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0aGUgcGF0aCBuYW1lIHRvIHRoZSBmb3JtIGZpZWxkIHZhbHVlLCBhbmQgdmFsaWRhdGlvbiBydWxlcy5cbiAqXG4gKiBAcmV0dXJucyBmaWVsZCBwcm9wZXJ0aWVzLCBmaWVsZCBhbmQgZm9ybSBzdGF0ZS4ge0BsaW5rIFVzZUNvbnRyb2xsZXJSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gSW5wdXQocHJvcHMpIHtcbiAqICAgY29uc3QgeyBmaWVsZCwgZmllbGRTdGF0ZSwgZm9ybVN0YXRlIH0gPSB1c2VDb250cm9sbGVyKHByb3BzKTtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPGlucHV0IHsuLi5maWVsZH0gcGxhY2Vob2xkZXI9e3Byb3BzLm5hbWV9IC8+XG4gKiAgICAgICA8cD57ZmllbGRTdGF0ZS5pc1RvdWNoZWQgJiYgXCJUb3VjaGVkXCJ9PC9wPlxuICogICAgICAgPHA+e2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCA/IFwic3VibWl0dGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udHJvbGxlcjxcbiAgVEZpZWxkVmFsdWVzIGV4dGVuZHMgRmllbGRWYWx1ZXMgPSBGaWVsZFZhbHVlcyxcbiAgVE5hbWUgZXh0ZW5kcyBGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPiA9IEZpZWxkUGF0aDxURmllbGRWYWx1ZXM+LFxuPihcbiAgcHJvcHM6IFVzZUNvbnRyb2xsZXJQcm9wczxURmllbGRWYWx1ZXMsIFROYW1lPixcbik6IFVzZUNvbnRyb2xsZXJSZXR1cm48VEZpZWxkVmFsdWVzLCBUTmFtZT4ge1xuICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQ8VEZpZWxkVmFsdWVzPigpO1xuICBjb25zdCB7IG5hbWUsIGRpc2FibGVkLCBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBzaG91bGRVbnJlZ2lzdGVyIH0gPSBwcm9wcztcbiAgY29uc3QgaXNBcnJheUZpZWxkID0gaXNOYW1lSW5GaWVsZEFycmF5KGNvbnRyb2wuX25hbWVzLmFycmF5LCBuYW1lKTtcbiAgY29uc3QgdmFsdWUgPSB1c2VXYXRjaCh7XG4gICAgY29udHJvbCxcbiAgICBuYW1lLFxuICAgIGRlZmF1bHRWYWx1ZTogZ2V0KFxuICAgICAgY29udHJvbC5fZm9ybVZhbHVlcyxcbiAgICAgIG5hbWUsXG4gICAgICBnZXQoY29udHJvbC5fZGVmYXVsdFZhbHVlcywgbmFtZSwgcHJvcHMuZGVmYXVsdFZhbHVlKSxcbiAgICApLFxuICAgIGV4YWN0OiB0cnVlLFxuICB9KSBhcyBGaWVsZFBhdGhWYWx1ZTxURmllbGRWYWx1ZXMsIFROYW1lPjtcbiAgY29uc3QgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKHtcbiAgICBjb250cm9sLFxuICAgIG5hbWUsXG4gIH0pO1xuXG4gIGNvbnN0IF9yZWdpc3RlclByb3BzID0gUmVhY3QudXNlUmVmKFxuICAgIGNvbnRyb2wucmVnaXN0ZXIobmFtZSwge1xuICAgICAgLi4ucHJvcHMucnVsZXMsXG4gICAgICB2YWx1ZSxcbiAgICAgIC4uLihpc0Jvb2xlYW4ocHJvcHMuZGlzYWJsZWQpID8geyBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfSA6IHt9KSxcbiAgICB9KSxcbiAgKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQgPVxuICAgICAgY29udHJvbC5fb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IHNob3VsZFVucmVnaXN0ZXI7XG5cbiAgICBjb25zdCB1cGRhdGVNb3VudGVkID0gKG5hbWU6IEludGVybmFsRmllbGROYW1lLCB2YWx1ZTogYm9vbGVhbikgPT4ge1xuICAgICAgY29uc3QgZmllbGQ6IEZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG5cbiAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICBmaWVsZC5fZi5tb3VudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB1cGRhdGVNb3VudGVkKG5hbWUsIHRydWUpO1xuXG4gICAgaWYgKF9zaG91bGRVbnJlZ2lzdGVyRmllbGQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY2xvbmVPYmplY3QoZ2V0KGNvbnRyb2wuX29wdGlvbnMuZGVmYXVsdFZhbHVlcywgbmFtZSkpO1xuICAgICAgc2V0KGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSkpKSB7XG4gICAgICAgIHNldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIChcbiAgICAgICAgaXNBcnJheUZpZWxkXG4gICAgICAgICAgPyBfc2hvdWxkVW5yZWdpc3RlckZpZWxkICYmICFjb250cm9sLl9zdGF0ZS5hY3Rpb25cbiAgICAgICAgICA6IF9zaG91bGRVbnJlZ2lzdGVyRmllbGRcbiAgICAgIClcbiAgICAgICAgPyBjb250cm9sLnVucmVnaXN0ZXIobmFtZSlcbiAgICAgICAgOiB1cGRhdGVNb3VudGVkKG5hbWUsIGZhbHNlKTtcbiAgICB9O1xuICB9LCBbbmFtZSwgY29udHJvbCwgaXNBcnJheUZpZWxkLCBzaG91bGRVbnJlZ2lzdGVyXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSkpIHtcbiAgICAgIGNvbnRyb2wuX3VwZGF0ZURpc2FibGVkRmllbGQoe1xuICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgZmllbGRzOiBjb250cm9sLl9maWVsZHMsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKS5fZi52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCBuYW1lLCBjb250cm9sXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBmaWVsZDoge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgLi4uKGlzQm9vbGVhbihkaXNhYmxlZCkgfHwgZm9ybVN0YXRlLmRpc2FibGVkXG4gICAgICAgID8geyBkaXNhYmxlZDogZm9ybVN0YXRlLmRpc2FibGVkIHx8IGRpc2FibGVkIH1cbiAgICAgICAgOiB7fSksXG4gICAgICBvbkNoYW5nZTogUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgIChldmVudCkgPT5cbiAgICAgICAgICBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQ2hhbmdlKHtcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0RXZlbnRWYWx1ZShldmVudCksXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUgYXMgSW50ZXJuYWxGaWVsZE5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogRVZFTlRTLkNIQU5HRSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgW25hbWVdLFxuICAgICAgKSxcbiAgICAgIG9uQmx1cjogUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAgICgpID0+XG4gICAgICAgICAgX3JlZ2lzdGVyUHJvcHMuY3VycmVudC5vbkJsdXIoe1xuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSksXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUgYXMgSW50ZXJuYWxGaWVsZE5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogRVZFTlRTLkJMVVIsXG4gICAgICAgICAgfSksXG4gICAgICAgIFtuYW1lLCBjb250cm9sXSxcbiAgICAgICksXG4gICAgICByZWY6IChlbG0pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcblxuICAgICAgICBpZiAoZmllbGQgJiYgZWxtKSB7XG4gICAgICAgICAgZmllbGQuX2YucmVmID0ge1xuICAgICAgICAgICAgZm9jdXM6ICgpID0+IGVsbS5mb2N1cygpLFxuICAgICAgICAgICAgc2VsZWN0OiAoKSA9PiBlbG0uc2VsZWN0KCksXG4gICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eTogKG1lc3NhZ2U6IHN0cmluZykgPT5cbiAgICAgICAgICAgICAgZWxtLnNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpLFxuICAgICAgICAgICAgcmVwb3J0VmFsaWRpdHk6ICgpID0+IGVsbS5yZXBvcnRWYWxpZGl0eSgpLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcbiAgICBmb3JtU3RhdGUsXG4gICAgZmllbGRTdGF0ZTogT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgICB7fSxcbiAgICAgIHtcbiAgICAgICAgaW52YWxpZDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNEaXJ0eToge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc1RvdWNoZWQ6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogKCkgPT4gISFnZXQoZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogKCkgPT4gISFnZXQoZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiAoKSA9PiBnZXQoZm9ybVN0YXRlLmVycm9ycywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICkgYXMgQ29udHJvbGxlckZpZWxkU3RhdGUsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBDb250cm9sbGVyUHJvcHMsIEZpZWxkUGF0aCwgRmllbGRWYWx1ZXMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHVzZUNvbnRyb2xsZXIgfSBmcm9tICcuL3VzZUNvbnRyb2xsZXInO1xuXG4vKipcbiAqIENvbXBvbmVudCBiYXNlZCBvbiBgdXNlQ29udHJvbGxlcmAgaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIvY29udHJvbGxlcikg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY2LWNvbnRyb2xsZXItdHMtand5encpIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9TjJVTmtfVUNWeUEpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgcHJvdmlkZSBmaWVsZCBoYW5kbGVyIGZ1bmN0aW9ucywgZmllbGQgYW5kIGZvcm0gc3RhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm08Rm9ybVZhbHVlcz4oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICAgIHRlc3Q6IFwiXCJcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybT5cbiAqICAgICAgIDxDb250cm9sbGVyXG4gKiAgICAgICAgIGNvbnRyb2w9e2NvbnRyb2x9XG4gKiAgICAgICAgIG5hbWU9XCJ0ZXN0XCJcbiAqICAgICAgICAgcmVuZGVyPXsoeyBmaWVsZDogeyBvbkNoYW5nZSwgb25CbHVyLCB2YWx1ZSwgcmVmIH0sIGZvcm1TdGF0ZSwgZmllbGRTdGF0ZSB9KSA9PiAoXG4gKiAgICAgICAgICAgPD5cbiAqICAgICAgICAgICAgIDxpbnB1dFxuICogICAgICAgICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9IC8vIHNlbmQgdmFsdWUgdG8gaG9vayBmb3JtXG4gKiAgICAgICAgICAgICAgIG9uQmx1cj17b25CbHVyfSAvLyBub3RpZnkgd2hlbiBpbnB1dCBpcyB0b3VjaGVkXG4gKiAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX0gLy8gcmV0dXJuIHVwZGF0ZWQgdmFsdWVcbiAqICAgICAgICAgICAgICAgcmVmPXtyZWZ9IC8vIHNldCByZWYgZm9yIGZvY3VzIG1hbmFnZW1lbnRcbiAqICAgICAgICAgICAgIC8+XG4gKiAgICAgICAgICAgICA8cD57Zm9ybVN0YXRlLmlzU3VibWl0dGVkID8gXCJzdWJtaXR0ZWRcIiA6IFwiXCJ9PC9wPlxuICogICAgICAgICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkID8gXCJ0b3VjaGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICAgICAgICA8Lz5cbiAqICAgICAgICAgKX1cbiAqICAgICAgIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IENvbnRyb2xsZXIgPSA8XG4gIFRGaWVsZFZhbHVlcyBleHRlbmRzIEZpZWxkVmFsdWVzID0gRmllbGRWYWx1ZXMsXG4gIFROYW1lIGV4dGVuZHMgRmllbGRQYXRoPFRGaWVsZFZhbHVlcz4gPSBGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPixcbj4oXG4gIHByb3BzOiBDb250cm9sbGVyUHJvcHM8VEZpZWxkVmFsdWVzLCBUTmFtZT4sXG4pID0+IHByb3BzLnJlbmRlcih1c2VDb250cm9sbGVyPFRGaWVsZFZhbHVlcywgVE5hbWU+KHByb3BzKSk7XG5cbmV4cG9ydCB7IENvbnRyb2xsZXIgfTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBnZXQgZnJvbSAnLi91dGlscy9nZXQnO1xuaW1wb3J0IHsgRmllbGRWYWx1ZXMsIEZvcm1Qcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgdXNlRm9ybUNvbnRleHQgfSBmcm9tICcuL3VzZUZvcm1Db250ZXh0JztcblxuY29uc3QgUE9TVF9SRVFVRVNUID0gJ3Bvc3QnO1xuXG4vKipcbiAqIEZvcm0gY29tcG9uZW50IHRvIG1hbmFnZSBzdWJtaXNzaW9uLlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIHRvIHNldHVwIHN1Ym1pc3Npb24gZGV0YWlsLiB7QGxpbmsgRm9ybVByb3BzfVxuICpcbiAqIEByZXR1cm5zIGZvcm0gY29tcG9uZW50IG9yIGhlYWRsZXNzIHJlbmRlciBwcm9wLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyBjb250cm9sLCBmb3JtU3RhdGU6IHsgZXJyb3JzIH0gfSA9IHVzZUZvcm0oKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm0gYWN0aW9uPVwiL2FwaVwiIGNvbnRyb2w9e2NvbnRyb2x9PlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcIm5hbWVcIil9IC8+XG4gKiAgICAgICA8cD57ZXJyb3JzPy5yb290Py5zZXJ2ZXIgJiYgJ1NlcnZlciBlcnJvcid9PC9wPlxuICogICAgICAgPGJ1dHRvbj5TdWJtaXQ8L2J1dHRvbj5cbiAqICAgICA8L0Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gRm9ybTxcbiAgVCBleHRlbmRzIEZpZWxkVmFsdWVzLFxuICBVIGV4dGVuZHMgRmllbGRWYWx1ZXMgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXG4+KHByb3BzOiBGb3JtUHJvcHM8VCwgVT4pIHtcbiAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0PFQ+KCk7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3Qge1xuICAgIGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsXG4gICAgb25TdWJtaXQsXG4gICAgY2hpbGRyZW4sXG4gICAgYWN0aW9uLFxuICAgIG1ldGhvZCA9IFBPU1RfUkVRVUVTVCxcbiAgICBoZWFkZXJzLFxuICAgIGVuY1R5cGUsXG4gICAgb25FcnJvcixcbiAgICByZW5kZXIsXG4gICAgb25TdWNjZXNzLFxuICAgIHZhbGlkYXRlU3RhdHVzLFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IHN1Ym1pdCA9IGFzeW5jIChldmVudD86IFJlYWN0LkJhc2VTeW50aGV0aWNFdmVudCkgPT4ge1xuICAgIGxldCBoYXNFcnJvciA9IGZhbHNlO1xuICAgIGxldCB0eXBlID0gJyc7XG5cbiAgICBhd2FpdCBjb250cm9sLmhhbmRsZVN1Ym1pdChhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGxldCBmb3JtRGF0YUpzb24gPSAnJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9ybURhdGFKc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICB9IGNhdGNoIHt9XG5cbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBjb250cm9sLl9uYW1lcy5tb3VudCkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgZ2V0KGRhdGEsIG5hbWUpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9uU3VibWl0KSB7XG4gICAgICAgIGF3YWl0IG9uU3VibWl0KHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICBmb3JtRGF0YUpzb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEgPSBbXG4gICAgICAgICAgICBoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddLFxuICAgICAgICAgICAgZW5jVHlwZSxcbiAgICAgICAgICBdLnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSAmJiB2YWx1ZS5pbmNsdWRlcygnanNvbicpKTtcblxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYWN0aW9uLCB7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgICAgIC4uLihlbmNUeXBlID8geyAnQ29udGVudC1UeXBlJzogZW5jVHlwZSB9IDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IHNob3VsZFN0cmluZ2lmeVN1Ym1pc3Npb25EYXRhID8gZm9ybURhdGFKc29uIDogZm9ybURhdGEsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXNwb25zZSAmJlxuICAgICAgICAgICAgKHZhbGlkYXRlU3RhdHVzXG4gICAgICAgICAgICAgID8gIXZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cylcbiAgICAgICAgICAgICAgOiByZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID49IDMwMClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uRXJyb3IgJiYgb25FcnJvcih7IHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgdHlwZSA9IFN0cmluZyhyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3MgJiYgb25TdWNjZXNzKHsgcmVzcG9uc2UgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKGV2ZW50KTtcblxuICAgIGlmIChoYXNFcnJvciAmJiBwcm9wcy5jb250cm9sKSB7XG4gICAgICBwcm9wcy5jb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgcHJvcHMuY29udHJvbC5zZXRFcnJvcigncm9vdC5zZXJ2ZXInLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRNb3VudGVkKHRydWUpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHJlbmRlciA/IChcbiAgICA8PlxuICAgICAge3JlbmRlcih7XG4gICAgICAgIHN1Ym1pdCxcbiAgICAgIH0pfVxuICAgIDwvPlxuICApIDogKFxuICAgIDxmb3JtXG4gICAgICBub1ZhbGlkYXRlPXttb3VudGVkfVxuICAgICAgYWN0aW9uPXthY3Rpb259XG4gICAgICBtZXRob2Q9e21ldGhvZH1cbiAgICAgIGVuY1R5cGU9e2VuY1R5cGV9XG4gICAgICBvblN1Ym1pdD17c3VibWl0fVxuICAgICAgey4uLnJlc3R9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvZm9ybT5cbiAgKTtcbn1cblxuZXhwb3J0IHsgRm9ybSB9O1xuIiwiaW1wb3J0IHtcbiAgSW50ZXJuYWxGaWVsZEVycm9ycyxcbiAgSW50ZXJuYWxGaWVsZE5hbWUsXG4gIFZhbGlkYXRlUmVzdWx0LFxufSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChcbiAgbmFtZTogSW50ZXJuYWxGaWVsZE5hbWUsXG4gIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYTogYm9vbGVhbixcbiAgZXJyb3JzOiBJbnRlcm5hbEZpZWxkRXJyb3JzLFxuICB0eXBlOiBzdHJpbmcsXG4gIG1lc3NhZ2U6IFZhbGlkYXRlUmVzdWx0LFxuKSA9PlxuICB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWFcbiAgICA/IHtcbiAgICAgICAgLi4uZXJyb3JzW25hbWVdLFxuICAgICAgICB0eXBlczoge1xuICAgICAgICAgIC4uLihlcnJvcnNbbmFtZV0gJiYgZXJyb3JzW25hbWVdIS50eXBlcyA/IGVycm9yc1tuYW1lXSEudHlwZXMgOiB7fSksXG4gICAgICAgICAgW3R5cGVdOiBtZXNzYWdlIHx8IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgOiB7fTtcbiIsImV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgY29uc3QgZCA9XG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJyA/IERhdGUubm93KCkgOiBwZXJmb3JtYW5jZS5ub3coKSAqIDEwMDA7XG5cbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNiArIGQpICUgMTYgfCAwO1xuXG4gICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59O1xuIiwiaW1wb3J0IHsgRmllbGRBcnJheU1ldGhvZFByb3BzLCBJbnRlcm5hbEZpZWxkTmFtZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tICcuLi91dGlscy9pc1VuZGVmaW5lZCc7XG5cbmV4cG9ydCBkZWZhdWx0IChcbiAgbmFtZTogSW50ZXJuYWxGaWVsZE5hbWUsXG4gIGluZGV4OiBudW1iZXIsXG4gIG9wdGlvbnM6IEZpZWxkQXJyYXlNZXRob2RQcm9wcyA9IHt9LFxuKTogc3RyaW5nID0+XG4gIG9wdGlvbnMuc2hvdWxkRm9jdXMgfHwgaXNVbmRlZmluZWQob3B0aW9ucy5zaG91bGRGb2N1cylcbiAgICA/IG9wdGlvbnMuZm9jdXNOYW1lIHx8XG4gICAgICBgJHtuYW1lfS4ke2lzVW5kZWZpbmVkKG9wdGlvbnMuZm9jdXNJbmRleCkgPyBpbmRleCA6IG9wdGlvbnMuZm9jdXNJbmRleH0uYFxuICAgIDogJyc7XG4iLCJpbXBvcnQgeyBWQUxJREFUSU9OX01PREUgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgTW9kZSwgVmFsaWRhdGlvbk1vZGVGbGFncyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgKG1vZGU/OiBNb2RlKTogVmFsaWRhdGlvbk1vZGVGbGFncyA9PiAoe1xuICBpc09uU3VibWl0OiAhbW9kZSB8fCBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25TdWJtaXQsXG4gIGlzT25CbHVyOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25CbHVyLFxuICBpc09uQ2hhbmdlOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsXG4gIGlzT25BbGw6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGwsXG4gIGlzT25Ub3VjaDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uVG91Y2hlZCxcbn0pO1xuIiwiaW1wb3J0IHsgSW50ZXJuYWxGaWVsZE5hbWUsIE5hbWVzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCAoXG4gIG5hbWU6IEludGVybmFsRmllbGROYW1lLFxuICBfbmFtZXM6IE5hbWVzLFxuICBpc0JsdXJFdmVudD86IGJvb2xlYW4sXG4pID0+XG4gICFpc0JsdXJFdmVudCAmJlxuICAoX25hbWVzLndhdGNoQWxsIHx8XG4gICAgX25hbWVzLndhdGNoLmhhcyhuYW1lKSB8fFxuICAgIFsuLi5fbmFtZXMud2F0Y2hdLnNvbWUoXG4gICAgICAod2F0Y2hOYW1lKSA9PlxuICAgICAgICBuYW1lLnN0YXJ0c1dpdGgod2F0Y2hOYW1lKSAmJlxuICAgICAgICAvXlxcLlxcdysvLnRlc3QobmFtZS5zbGljZSh3YXRjaE5hbWUubGVuZ3RoKSksXG4gICAgKSk7XG4iLCJpbXBvcnQgeyBGaWVsZFJlZnMsIEludGVybmFsRmllbGROYW1lLCBSZWYgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi4vdXRpbHMvaXNPYmplY3QnO1xuXG5jb25zdCBpdGVyYXRlRmllbGRzQnlBY3Rpb24gPSAoXG4gIGZpZWxkczogRmllbGRSZWZzLFxuICBhY3Rpb246IChyZWY6IFJlZiwgbmFtZTogc3RyaW5nKSA9PiAxIHwgdW5kZWZpbmVkIHwgdm9pZCxcbiAgZmllbGRzTmFtZXM/OiBTZXQ8SW50ZXJuYWxGaWVsZE5hbWU+IHwgSW50ZXJuYWxGaWVsZE5hbWVbXSB8IDAsXG4gIGFib3J0RWFybHk/OiBib29sZWFuLFxuKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIGZpZWxkc05hbWVzIHx8IE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHMsIGtleSk7XG5cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIGNvbnN0IHsgX2YsIC4uLmN1cnJlbnRGaWVsZCB9ID0gZmllbGQ7XG5cbiAgICAgIGlmIChfZikge1xuICAgICAgICBpZiAoX2YucmVmcyAmJiBfZi5yZWZzWzBdICYmIGFjdGlvbihfZi5yZWZzWzBdLCBrZXkpICYmICFhYm9ydEVhcmx5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoX2YucmVmICYmIGFjdGlvbihfZi5yZWYsIF9mLm5hbWUpICYmICFhYm9ydEVhcmx5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGN1cnJlbnRGaWVsZCwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChjdXJyZW50RmllbGQpKSB7XG4gICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihjdXJyZW50RmllbGQsIGFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpdGVyYXRlRmllbGRzQnlBY3Rpb247XG4iLCJpbXBvcnQge1xuICBGaWVsZEVycm9yLFxuICBGaWVsZEVycm9ycyxcbiAgRmllbGRWYWx1ZXMsXG4gIEludGVybmFsRmllbGROYW1lLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgY29tcGFjdCBmcm9tICcuLi91dGlscy9jb21wYWN0JztcbmltcG9ydCBnZXQgZnJvbSAnLi4vdXRpbHMvZ2V0JztcbmltcG9ydCBzZXQgZnJvbSAnLi4vdXRpbHMvc2V0JztcblxuZXhwb3J0IGRlZmF1bHQgPFQgZXh0ZW5kcyBGaWVsZFZhbHVlcyA9IEZpZWxkVmFsdWVzPihcbiAgZXJyb3JzOiBGaWVsZEVycm9yczxUPixcbiAgZXJyb3I6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgRmllbGRFcnJvcj4+LFxuICBuYW1lOiBJbnRlcm5hbEZpZWxkTmFtZSxcbik6IEZpZWxkRXJyb3JzPFQ+ID0+IHtcbiAgY29uc3QgZmllbGRBcnJheUVycm9ycyA9IGNvbXBhY3QoZ2V0KGVycm9ycywgbmFtZSkpO1xuICBzZXQoZmllbGRBcnJheUVycm9ycywgJ3Jvb3QnLCBlcnJvcltuYW1lXSk7XG4gIHNldChlcnJvcnMsIG5hbWUsIGZpZWxkQXJyYXlFcnJvcnMpO1xuICByZXR1cm4gZXJyb3JzO1xufTtcbiIsImltcG9ydCB7IEZpZWxkRWxlbWVudCB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgKGVsZW1lbnQ6IEZpZWxkRWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTElucHV0RWxlbWVudCA9PlxuICBlbGVtZW50LnR5cGUgPT09ICdmaWxlJztcbiIsImV4cG9ydCBkZWZhdWx0ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEZ1bmN0aW9uID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiIsImltcG9ydCBpc1dlYiBmcm9tICcuL2lzV2ViJztcblxuZXhwb3J0IGRlZmF1bHQgKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgSFRNTEVsZW1lbnQgPT4ge1xuICBpZiAoIWlzV2ViKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgb3duZXIgPSB2YWx1ZSA/ICgodmFsdWUgYXMgSFRNTEVsZW1lbnQpLm93bmVyRG9jdW1lbnQgYXMgRG9jdW1lbnQpIDogMDtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSBpbnN0YW5jZW9mXG4gICAgKG93bmVyICYmIG93bmVyLmRlZmF1bHRWaWV3ID8gb3duZXIuZGVmYXVsdFZpZXcuSFRNTEVsZW1lbnQgOiBIVE1MRWxlbWVudClcbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gJy4uL3V0aWxzL2lzU3RyaW5nJztcblxuZXhwb3J0IGRlZmF1bHQgKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgTWVzc2FnZSA9PiBpc1N0cmluZyh2YWx1ZSk7XG4iLCJpbXBvcnQgeyBGaWVsZEVsZW1lbnQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChlbGVtZW50OiBGaWVsZEVsZW1lbnQpOiBlbGVtZW50IGlzIEhUTUxJbnB1dEVsZW1lbnQgPT5cbiAgZWxlbWVudC50eXBlID09PSAncmFkaW8nO1xuIiwiZXhwb3J0IGRlZmF1bHQgKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgUmVnRXhwID0+IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuIiwiaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gJy4uL3V0aWxzL2lzVW5kZWZpbmVkJztcblxudHlwZSBDaGVja2JveEZpZWxkUmVzdWx0ID0ge1xuICBpc1ZhbGlkOiBib29sZWFuO1xuICB2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10gfCBib29sZWFuIHwgdW5kZWZpbmVkO1xufTtcblxuY29uc3QgZGVmYXVsdFJlc3VsdDogQ2hlY2tib3hGaWVsZFJlc3VsdCA9IHtcbiAgdmFsdWU6IGZhbHNlLFxuICBpc1ZhbGlkOiBmYWxzZSxcbn07XG5cbmNvbnN0IHZhbGlkUmVzdWx0ID0geyB2YWx1ZTogdHJ1ZSwgaXNWYWxpZDogdHJ1ZSB9O1xuXG5leHBvcnQgZGVmYXVsdCAob3B0aW9ucz86IEhUTUxJbnB1dEVsZW1lbnRbXSk6IENoZWNrYm94RmllbGRSZXN1bHQgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdGlvbnNcbiAgICAgICAgLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZClcbiAgICAgICAgLm1hcCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUpO1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlcywgaXNWYWxpZDogISF2YWx1ZXMubGVuZ3RoIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNbMF0uY2hlY2tlZCAmJiAhb3B0aW9uc1swXS5kaXNhYmxlZFxuICAgICAgPyAvLyBAdHMtZXhwZWN0LWVycm9yIGV4cGVjdGVkIHRvIHdvcmsgaW4gdGhlIGJyb3dzZXJcbiAgICAgICAgb3B0aW9uc1swXS5hdHRyaWJ1dGVzICYmICFpc1VuZGVmaW5lZChvcHRpb25zWzBdLmF0dHJpYnV0ZXMudmFsdWUpXG4gICAgICAgID8gaXNVbmRlZmluZWQob3B0aW9uc1swXS52YWx1ZSkgfHwgb3B0aW9uc1swXS52YWx1ZSA9PT0gJydcbiAgICAgICAgICA/IHZhbGlkUmVzdWx0XG4gICAgICAgICAgOiB7IHZhbHVlOiBvcHRpb25zWzBdLnZhbHVlLCBpc1ZhbGlkOiB0cnVlIH1cbiAgICAgICAgOiB2YWxpZFJlc3VsdFxuICAgICAgOiBkZWZhdWx0UmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XG59O1xuIiwidHlwZSBSYWRpb0ZpZWxkUmVzdWx0ID0ge1xuICBpc1ZhbGlkOiBib29sZWFuO1xuICB2YWx1ZTogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbDtcbn07XG5cbmNvbnN0IGRlZmF1bHRSZXR1cm46IFJhZGlvRmllbGRSZXN1bHQgPSB7XG4gIGlzVmFsaWQ6IGZhbHNlLFxuICB2YWx1ZTogbnVsbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IChvcHRpb25zPzogSFRNTElucHV0RWxlbWVudFtdKTogUmFkaW9GaWVsZFJlc3VsdCA9PlxuICBBcnJheS5pc0FycmF5KG9wdGlvbnMpXG4gICAgPyBvcHRpb25zLnJlZHVjZShcbiAgICAgICAgKHByZXZpb3VzLCBvcHRpb24pOiBSYWRpb0ZpZWxkUmVzdWx0ID0+XG4gICAgICAgICAgb3B0aW9uICYmIG9wdGlvbi5jaGVja2VkICYmICFvcHRpb24uZGlzYWJsZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBwcmV2aW91cyxcbiAgICAgICAgZGVmYXVsdFJldHVybixcbiAgICAgIClcbiAgICA6IGRlZmF1bHRSZXR1cm47XG4iLCJpbXBvcnQgeyBGaWVsZEVycm9yLCBSZWYsIFZhbGlkYXRlUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGlzQm9vbGVhbiBmcm9tICcuLi91dGlscy9pc0Jvb2xlYW4nO1xuaW1wb3J0IGlzTWVzc2FnZSBmcm9tICcuLi91dGlscy9pc01lc3NhZ2UnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYWxpZGF0ZUVycm9yKFxuICByZXN1bHQ6IFZhbGlkYXRlUmVzdWx0LFxuICByZWY6IFJlZixcbiAgdHlwZSA9ICd2YWxpZGF0ZScsXG4pOiBGaWVsZEVycm9yIHwgdm9pZCB7XG4gIGlmIChcbiAgICBpc01lc3NhZ2UocmVzdWx0KSB8fFxuICAgIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0LmV2ZXJ5KGlzTWVzc2FnZSkpIHx8XG4gICAgKGlzQm9vbGVhbihyZXN1bHQpICYmICFyZXN1bHQpXG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgbWVzc2FnZTogaXNNZXNzYWdlKHJlc3VsdCkgPyByZXN1bHQgOiAnJyxcbiAgICAgIHJlZixcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBWYWxpZGF0aW9uUnVsZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuLi91dGlscy9pc09iamVjdCc7XG5pbXBvcnQgaXNSZWdleCBmcm9tICcuLi91dGlscy9pc1JlZ2V4JztcblxuZXhwb3J0IGRlZmF1bHQgKHZhbGlkYXRpb25EYXRhPzogVmFsaWRhdGlvblJ1bGUpID0+XG4gIGlzT2JqZWN0KHZhbGlkYXRpb25EYXRhKSAmJiAhaXNSZWdleCh2YWxpZGF0aW9uRGF0YSlcbiAgICA/IHZhbGlkYXRpb25EYXRhXG4gICAgOiB7XG4gICAgICAgIHZhbHVlOiB2YWxpZGF0aW9uRGF0YSxcbiAgICAgICAgbWVzc2FnZTogJycsXG4gICAgICB9O1xuIiwiaW1wb3J0IHsgSU5QVVRfVkFMSURBVElPTl9SVUxFUyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBGaWVsZCxcbiAgRmllbGRFcnJvcixcbiAgRmllbGRWYWx1ZXMsXG4gIEludGVybmFsRmllbGRFcnJvcnMsXG4gIE1heFR5cGUsXG4gIE1lc3NhZ2UsXG4gIE1pblR5cGUsXG4gIE5hdGl2ZUZpZWxkVmFsdWUsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXQgZnJvbSAnLi4vdXRpbHMvZ2V0JztcbmltcG9ydCBpc0Jvb2xlYW4gZnJvbSAnLi4vdXRpbHMvaXNCb29sZWFuJztcbmltcG9ydCBpc0NoZWNrQm94SW5wdXQgZnJvbSAnLi4vdXRpbHMvaXNDaGVja0JveElucHV0JztcbmltcG9ydCBpc0VtcHR5T2JqZWN0IGZyb20gJy4uL3V0aWxzL2lzRW1wdHlPYmplY3QnO1xuaW1wb3J0IGlzRmlsZUlucHV0IGZyb20gJy4uL3V0aWxzL2lzRmlsZUlucHV0JztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4uL3V0aWxzL2lzRnVuY3Rpb24nO1xuaW1wb3J0IGlzSFRNTEVsZW1lbnQgZnJvbSAnLi4vdXRpbHMvaXNIVE1MRWxlbWVudCc7XG5pbXBvcnQgaXNNZXNzYWdlIGZyb20gJy4uL3V0aWxzL2lzTWVzc2FnZSc7XG5pbXBvcnQgaXNOdWxsT3JVbmRlZmluZWQgZnJvbSAnLi4vdXRpbHMvaXNOdWxsT3JVbmRlZmluZWQnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4uL3V0aWxzL2lzT2JqZWN0JztcbmltcG9ydCBpc1JhZGlvSW5wdXQgZnJvbSAnLi4vdXRpbHMvaXNSYWRpb0lucHV0JztcbmltcG9ydCBpc1JlZ2V4IGZyb20gJy4uL3V0aWxzL2lzUmVnZXgnO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gJy4uL3V0aWxzL2lzU3RyaW5nJztcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tICcuLi91dGlscy9pc1VuZGVmaW5lZCc7XG5cbmltcG9ydCBhcHBlbmRFcnJvcnMgZnJvbSAnLi9hcHBlbmRFcnJvcnMnO1xuaW1wb3J0IGdldENoZWNrYm94VmFsdWUgZnJvbSAnLi9nZXRDaGVja2JveFZhbHVlJztcbmltcG9ydCBnZXRSYWRpb1ZhbHVlIGZyb20gJy4vZ2V0UmFkaW9WYWx1ZSc7XG5pbXBvcnQgZ2V0VmFsaWRhdGVFcnJvciBmcm9tICcuL2dldFZhbGlkYXRlRXJyb3InO1xuaW1wb3J0IGdldFZhbHVlQW5kTWVzc2FnZSBmcm9tICcuL2dldFZhbHVlQW5kTWVzc2FnZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIDxUIGV4dGVuZHMgRmllbGRWYWx1ZXM+KFxuICBmaWVsZDogRmllbGQsXG4gIGZvcm1WYWx1ZXM6IFQsXG4gIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYTogYm9vbGVhbixcbiAgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbj86IGJvb2xlYW4sXG4gIGlzRmllbGRBcnJheT86IGJvb2xlYW4sXG4pOiBQcm9taXNlPEludGVybmFsRmllbGRFcnJvcnM+ID0+IHtcbiAgY29uc3Qge1xuICAgIHJlZixcbiAgICByZWZzLFxuICAgIHJlcXVpcmVkLFxuICAgIG1heExlbmd0aCxcbiAgICBtaW5MZW5ndGgsXG4gICAgbWluLFxuICAgIG1heCxcbiAgICBwYXR0ZXJuLFxuICAgIHZhbGlkYXRlLFxuICAgIG5hbWUsXG4gICAgdmFsdWVBc051bWJlcixcbiAgICBtb3VudCxcbiAgICBkaXNhYmxlZCxcbiAgfSA9IGZpZWxkLl9mO1xuICBjb25zdCBpbnB1dFZhbHVlOiBOYXRpdmVGaWVsZFZhbHVlID0gZ2V0KGZvcm1WYWx1ZXMsIG5hbWUpO1xuICBpZiAoIW1vdW50IHx8IGRpc2FibGVkKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IGlucHV0UmVmOiBIVE1MSW5wdXRFbGVtZW50ID0gcmVmcyA/IHJlZnNbMF0gOiAocmVmIGFzIEhUTUxJbnB1dEVsZW1lbnQpO1xuICBjb25zdCBzZXRDdXN0b21WYWxpZGl0eSA9IChtZXNzYWdlPzogc3RyaW5nIHwgYm9vbGVhbikgPT4ge1xuICAgIGlmIChzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uICYmIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KSB7XG4gICAgICBpbnB1dFJlZi5zZXRDdXN0b21WYWxpZGl0eShpc0Jvb2xlYW4obWVzc2FnZSkgPyAnJyA6IG1lc3NhZ2UgfHwgJycpO1xuICAgICAgaW5wdXRSZWYucmVwb3J0VmFsaWRpdHkoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGVycm9yOiBJbnRlcm5hbEZpZWxkRXJyb3JzID0ge307XG4gIGNvbnN0IGlzUmFkaW8gPSBpc1JhZGlvSW5wdXQocmVmKTtcbiAgY29uc3QgaXNDaGVja0JveCA9IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xuICBjb25zdCBpc1JhZGlvT3JDaGVja2JveCA9IGlzUmFkaW8gfHwgaXNDaGVja0JveDtcbiAgY29uc3QgaXNFbXB0eSA9XG4gICAgKCh2YWx1ZUFzTnVtYmVyIHx8IGlzRmlsZUlucHV0KHJlZikpICYmXG4gICAgICBpc1VuZGVmaW5lZChyZWYudmFsdWUpICYmXG4gICAgICBpc1VuZGVmaW5lZChpbnB1dFZhbHVlKSkgfHxcbiAgICAoaXNIVE1MRWxlbWVudChyZWYpICYmIHJlZi52YWx1ZSA9PT0gJycpIHx8XG4gICAgaW5wdXRWYWx1ZSA9PT0gJycgfHxcbiAgICAoQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5sZW5ndGgpO1xuICBjb25zdCBhcHBlbmRFcnJvcnNDdXJyeSA9IGFwcGVuZEVycm9ycy5iaW5kKFxuICAgIG51bGwsXG4gICAgbmFtZSxcbiAgICB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsXG4gICAgZXJyb3IsXG4gICk7XG4gIGNvbnN0IGdldE1pbk1heE1lc3NhZ2UgPSAoXG4gICAgZXhjZWVkTWF4OiBib29sZWFuLFxuICAgIG1heExlbmd0aE1lc3NhZ2U6IE1lc3NhZ2UsXG4gICAgbWluTGVuZ3RoTWVzc2FnZTogTWVzc2FnZSxcbiAgICBtYXhUeXBlOiBNYXhUeXBlID0gSU5QVVRfVkFMSURBVElPTl9SVUxFUy5tYXhMZW5ndGgsXG4gICAgbWluVHlwZTogTWluVHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluTGVuZ3RoLFxuICApID0+IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXhjZWVkTWF4ID8gbWF4TGVuZ3RoTWVzc2FnZSA6IG1pbkxlbmd0aE1lc3NhZ2U7XG4gICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICB0eXBlOiBleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICByZWYsXG4gICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSwgbWVzc2FnZSksXG4gICAgfTtcbiAgfTtcblxuICBpZiAoXG4gICAgaXNGaWVsZEFycmF5XG4gICAgICA/ICFBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpIHx8ICFpbnB1dFZhbHVlLmxlbmd0aFxuICAgICAgOiByZXF1aXJlZCAmJlxuICAgICAgICAoKCFpc1JhZGlvT3JDaGVja2JveCAmJiAoaXNFbXB0eSB8fCBpc051bGxPclVuZGVmaW5lZChpbnB1dFZhbHVlKSkpIHx8XG4gICAgICAgICAgKGlzQm9vbGVhbihpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZSkgfHxcbiAgICAgICAgICAoaXNDaGVja0JveCAmJiAhZ2V0Q2hlY2tib3hWYWx1ZShyZWZzKS5pc1ZhbGlkKSB8fFxuICAgICAgICAgIChpc1JhZGlvICYmICFnZXRSYWRpb1ZhbHVlKHJlZnMpLmlzVmFsaWQpKVxuICApIHtcbiAgICBjb25zdCB7IHZhbHVlLCBtZXNzYWdlIH0gPSBpc01lc3NhZ2UocmVxdWlyZWQpXG4gICAgICA/IHsgdmFsdWU6ICEhcmVxdWlyZWQsIG1lc3NhZ2U6IHJlcXVpcmVkIH1cbiAgICAgIDogZ2V0VmFsdWVBbmRNZXNzYWdlKHJlcXVpcmVkKTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgIHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsIG1lc3NhZ2UpLFxuICAgICAgfTtcbiAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0VtcHR5ICYmICghaXNOdWxsT3JVbmRlZmluZWQobWluKSB8fCAhaXNOdWxsT3JVbmRlZmluZWQobWF4KSkpIHtcbiAgICBsZXQgZXhjZWVkTWF4O1xuICAgIGxldCBleGNlZWRNaW47XG4gICAgY29uc3QgbWF4T3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heCk7XG4gICAgY29uc3QgbWluT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1pbik7XG5cbiAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGlucHV0VmFsdWUpICYmICFpc05hTihpbnB1dFZhbHVlIGFzIG51bWJlcikpIHtcbiAgICAgIGNvbnN0IHZhbHVlTnVtYmVyID1cbiAgICAgICAgKHJlZiBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAgIChpbnB1dFZhbHVlID8gK2lucHV0VmFsdWUgOiBpbnB1dFZhbHVlKTtcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWF4T3V0cHV0LnZhbHVlKSkge1xuICAgICAgICBleGNlZWRNYXggPSB2YWx1ZU51bWJlciA+IG1heE91dHB1dC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWluT3V0cHV0LnZhbHVlKSkge1xuICAgICAgICBleGNlZWRNaW4gPSB2YWx1ZU51bWJlciA8IG1pbk91dHB1dC52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWVEYXRlID1cbiAgICAgICAgKHJlZiBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZUFzRGF0ZSB8fCBuZXcgRGF0ZShpbnB1dFZhbHVlIGFzIHN0cmluZyk7XG4gICAgICBjb25zdCBjb252ZXJ0VGltZVRvRGF0ZSA9ICh0aW1lOiB1bmtub3duKSA9PlxuICAgICAgICBuZXcgRGF0ZShuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpICsgJyAnICsgdGltZSk7XG4gICAgICBjb25zdCBpc1RpbWUgPSByZWYudHlwZSA9PSAndGltZSc7XG4gICAgICBjb25zdCBpc1dlZWsgPSByZWYudHlwZSA9PSAnd2Vlayc7XG5cbiAgICAgIGlmIChpc1N0cmluZyhtYXhPdXRwdXQudmFsdWUpICYmIGlucHV0VmFsdWUpIHtcbiAgICAgICAgZXhjZWVkTWF4ID0gaXNUaW1lXG4gICAgICAgICAgPyBjb252ZXJ0VGltZVRvRGF0ZShpbnB1dFZhbHVlKSA+IGNvbnZlcnRUaW1lVG9EYXRlKG1heE91dHB1dC52YWx1ZSlcbiAgICAgICAgICA6IGlzV2Vla1xuICAgICAgICAgID8gaW5wdXRWYWx1ZSA+IG1heE91dHB1dC52YWx1ZVxuICAgICAgICAgIDogdmFsdWVEYXRlID4gbmV3IERhdGUobWF4T3V0cHV0LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKG1pbk91dHB1dC52YWx1ZSkgJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICBleGNlZWRNaW4gPSBpc1RpbWVcbiAgICAgICAgICA/IGNvbnZlcnRUaW1lVG9EYXRlKGlucHV0VmFsdWUpIDwgY29udmVydFRpbWVUb0RhdGUobWluT3V0cHV0LnZhbHVlKVxuICAgICAgICAgIDogaXNXZWVrXG4gICAgICAgICAgPyBpbnB1dFZhbHVlIDwgbWluT3V0cHV0LnZhbHVlXG4gICAgICAgICAgOiB2YWx1ZURhdGUgPCBuZXcgRGF0ZShtaW5PdXRwdXQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleGNlZWRNYXggfHwgZXhjZWVkTWluKSB7XG4gICAgICBnZXRNaW5NYXhNZXNzYWdlKFxuICAgICAgICAhIWV4Y2VlZE1heCxcbiAgICAgICAgbWF4T3V0cHV0Lm1lc3NhZ2UsXG4gICAgICAgIG1pbk91dHB1dC5tZXNzYWdlLFxuICAgICAgICBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heCxcbiAgICAgICAgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW4sXG4gICAgICApO1xuICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3JbbmFtZV0hLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKFxuICAgIChtYXhMZW5ndGggfHwgbWluTGVuZ3RoKSAmJlxuICAgICFpc0VtcHR5ICYmXG4gICAgKGlzU3RyaW5nKGlucHV0VmFsdWUpIHx8IChpc0ZpZWxkQXJyYXkgJiYgQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSkpXG4gICkge1xuICAgIGNvbnN0IG1heExlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXhMZW5ndGgpO1xuICAgIGNvbnN0IG1pbkxlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW5MZW5ndGgpO1xuICAgIGNvbnN0IGV4Y2VlZE1heCA9XG4gICAgICAhaXNOdWxsT3JVbmRlZmluZWQobWF4TGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPiArbWF4TGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgIGNvbnN0IGV4Y2VlZE1pbiA9XG4gICAgICAhaXNOdWxsT3JVbmRlZmluZWQobWluTGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPCArbWluTGVuZ3RoT3V0cHV0LnZhbHVlO1xuXG4gICAgaWYgKGV4Y2VlZE1heCB8fCBleGNlZWRNaW4pIHtcbiAgICAgIGdldE1pbk1heE1lc3NhZ2UoXG4gICAgICAgIGV4Y2VlZE1heCxcbiAgICAgICAgbWF4TGVuZ3RoT3V0cHV0Lm1lc3NhZ2UsXG4gICAgICAgIG1pbkxlbmd0aE91dHB1dC5tZXNzYWdlLFxuICAgICAgKTtcbiAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdIS5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXR0ZXJuICYmICFpc0VtcHR5ICYmIGlzU3RyaW5nKGlucHV0VmFsdWUpKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogcGF0dGVyblZhbHVlLCBtZXNzYWdlIH0gPSBnZXRWYWx1ZUFuZE1lc3NhZ2UocGF0dGVybik7XG5cbiAgICBpZiAoaXNSZWdleChwYXR0ZXJuVmFsdWUpICYmICFpbnB1dFZhbHVlLm1hdGNoKHBhdHRlcm5WYWx1ZSkpIHtcbiAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHJlZixcbiAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLCBtZXNzYWdlKSxcbiAgICAgIH07XG4gICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRlKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGUoaW5wdXRWYWx1ZSwgZm9ybVZhbHVlcyk7XG4gICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIGlucHV0UmVmKTtcblxuICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcbiAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgLi4udmFsaWRhdGVFcnJvcixcbiAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShcbiAgICAgICAgICAgIElOUFVUX1ZBTElEQVRJT05fUlVMRVMudmFsaWRhdGUsXG4gICAgICAgICAgICB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eSh2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsaWRhdGUpKSB7XG4gICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdCA9IHt9IGFzIEZpZWxkRXJyb3I7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbGlkYXRlKSB7XG4gICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSAmJiAhdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihcbiAgICAgICAgICBhd2FpdCB2YWxpZGF0ZVtrZXldKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpLFxuICAgICAgICAgIGlucHV0UmVmLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodmFsaWRhdGVFcnJvcikge1xuICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSB7XG4gICAgICAgICAgICAuLi52YWxpZGF0ZUVycm9yLFxuICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3Vycnkoa2V5LCB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eSh2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgaWYgKHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB2YWxpZGF0aW9uUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkpIHtcbiAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgcmVmOiBpbnB1dFJlZixcbiAgICAgICAgICAuLi52YWxpZGF0aW9uUmVzdWx0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldEN1c3RvbVZhbGlkaXR5KHRydWUpO1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiaW1wb3J0IGNvbnZlcnRUb0FycmF5UGF5bG9hZCBmcm9tICcuL2NvbnZlcnRUb0FycmF5UGF5bG9hZCc7XG5cbmV4cG9ydCBkZWZhdWx0IDxUPihkYXRhOiBUW10sIHZhbHVlOiBUIHwgVFtdKTogVFtdID0+IFtcbiAgLi4uZGF0YSxcbiAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbl07XG4iLCJleHBvcnQgZGVmYXVsdCA8VD4odmFsdWU6IFQgfCBUW10pOiB1bmRlZmluZWRbXSB8IHVuZGVmaW5lZCA9PlxuICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgoKSA9PiB1bmRlZmluZWQpIDogdW5kZWZpbmVkO1xuIiwiaW1wb3J0IGNvbnZlcnRUb0FycmF5UGF5bG9hZCBmcm9tICcuL2NvbnZlcnRUb0FycmF5UGF5bG9hZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluc2VydDxUPihkYXRhOiBUW10sIGluZGV4OiBudW1iZXIpOiAoVCB8IHVuZGVmaW5lZClbXTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluc2VydDxUPihcbiAgZGF0YTogVFtdLFxuICBpbmRleDogbnVtYmVyLFxuICB2YWx1ZTogVCB8IFRbXSxcbik6IFRbXTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluc2VydDxUPihcbiAgZGF0YTogVFtdLFxuICBpbmRleDogbnVtYmVyLFxuICB2YWx1ZT86IFQgfCBUW10sXG4pOiAoVCB8IHVuZGVmaW5lZClbXSB7XG4gIHJldHVybiBbXG4gICAgLi4uZGF0YS5zbGljZSgwLCBpbmRleCksXG4gICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbiAgICAuLi5kYXRhLnNsaWNlKGluZGV4KSxcbiAgXTtcbn1cbiIsImltcG9ydCBpc1VuZGVmaW5lZCBmcm9tICcuL2lzVW5kZWZpbmVkJztcblxuZXhwb3J0IGRlZmF1bHQgPFQ+KFxuICBkYXRhOiAoVCB8IHVuZGVmaW5lZClbXSxcbiAgZnJvbTogbnVtYmVyLFxuICB0bzogbnVtYmVyLFxuKTogKFQgfCB1bmRlZmluZWQpW10gPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAoaXNVbmRlZmluZWQoZGF0YVt0b10pKSB7XG4gICAgZGF0YVt0b10gPSB1bmRlZmluZWQ7XG4gIH1cbiAgZGF0YS5zcGxpY2UodG8sIDAsIGRhdGEuc3BsaWNlKGZyb20sIDEpWzBdKTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCJpbXBvcnQgY29udmVydFRvQXJyYXlQYXlsb2FkIGZyb20gJy4vY29udmVydFRvQXJyYXlQYXlsb2FkJztcblxuZXhwb3J0IGRlZmF1bHQgPFQ+KGRhdGE6IFRbXSwgdmFsdWU6IFQgfCBUW10pOiBUW10gPT4gW1xuICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLFxuICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQoZGF0YSksXG5dO1xuIiwiaW1wb3J0IGNvbXBhY3QgZnJvbSAnLi9jb21wYWN0JztcbmltcG9ydCBjb252ZXJ0VG9BcnJheVBheWxvYWQgZnJvbSAnLi9jb252ZXJ0VG9BcnJheVBheWxvYWQnO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gJy4vaXNVbmRlZmluZWQnO1xuXG5mdW5jdGlvbiByZW1vdmVBdEluZGV4ZXM8VD4oZGF0YTogVFtdLCBpbmRleGVzOiBudW1iZXJbXSk6IFRbXSB7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgdGVtcCA9IFsuLi5kYXRhXTtcblxuICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICB0ZW1wLnNwbGljZShpbmRleCAtIGksIDEpO1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBjb21wYWN0KHRlbXApLmxlbmd0aCA/IHRlbXAgOiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgPFQ+KGRhdGE6IFRbXSwgaW5kZXg/OiBudW1iZXIgfCBudW1iZXJbXSk6IFRbXSA9PlxuICBpc1VuZGVmaW5lZChpbmRleClcbiAgICA/IFtdXG4gICAgOiByZW1vdmVBdEluZGV4ZXMoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIChjb252ZXJ0VG9BcnJheVBheWxvYWQoaW5kZXgpIGFzIG51bWJlcltdKS5zb3J0KChhLCBiKSA9PiBhIC0gYiksXG4gICAgICApO1xuIiwiZXhwb3J0IGRlZmF1bHQgPFQ+KGRhdGE6IFRbXSwgaW5kZXhBOiBudW1iZXIsIGluZGV4QjogbnVtYmVyKTogdm9pZCA9PiB7XG4gIFtkYXRhW2luZGV4QV0sIGRhdGFbaW5kZXhCXV0gPSBbZGF0YVtpbmRleEJdLCBkYXRhW2luZGV4QV1dO1xufTtcbiIsImltcG9ydCBpc0VtcHR5T2JqZWN0IGZyb20gJy4vaXNFbXB0eU9iamVjdCc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9pc0tleSc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdCc7XG5pbXBvcnQgaXNVbmRlZmluZWQgZnJvbSAnLi9pc1VuZGVmaW5lZCc7XG5pbXBvcnQgc3RyaW5nVG9QYXRoIGZyb20gJy4vc3RyaW5nVG9QYXRoJztcblxuZnVuY3Rpb24gYmFzZUdldChvYmplY3Q6IGFueSwgdXBkYXRlUGF0aDogKHN0cmluZyB8IG51bWJlcilbXSkge1xuICBjb25zdCBsZW5ndGggPSB1cGRhdGVQYXRoLnNsaWNlKDAsIC0xKS5sZW5ndGg7XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gaXNVbmRlZmluZWQob2JqZWN0KSA/IGluZGV4KysgOiBvYmplY3RbdXBkYXRlUGF0aFtpbmRleCsrXV07XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5QXJyYXkob2JqOiB1bmtub3duW10pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuc2V0KG9iamVjdDogYW55LCBwYXRoOiBzdHJpbmcgfCAoc3RyaW5nIHwgbnVtYmVyKVtdKSB7XG4gIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRoKVxuICAgID8gcGF0aFxuICAgIDogaXNLZXkocGF0aClcbiAgICA/IFtwYXRoXVxuICAgIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuXG4gIGNvbnN0IGNoaWxkT2JqZWN0ID0gcGF0aHMubGVuZ3RoID09PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIHBhdGhzKTtcblxuICBjb25zdCBpbmRleCA9IHBhdGhzLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGtleSA9IHBhdGhzW2luZGV4XTtcblxuICBpZiAoY2hpbGRPYmplY3QpIHtcbiAgICBkZWxldGUgY2hpbGRPYmplY3Rba2V5XTtcbiAgfVxuXG4gIGlmIChcbiAgICBpbmRleCAhPT0gMCAmJlxuICAgICgoaXNPYmplY3QoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlPYmplY3QoY2hpbGRPYmplY3QpKSB8fFxuICAgICAgKEFycmF5LmlzQXJyYXkoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlBcnJheShjaGlsZE9iamVjdCkpKVxuICApIHtcbiAgICB1bnNldChvYmplY3QsIHBhdGhzLnNsaWNlKDAsIC0xKSk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgPFQ+KGZpZWxkVmFsdWVzOiBUW10sIGluZGV4OiBudW1iZXIsIHZhbHVlOiBUKSA9PiB7XG4gIGZpZWxkVmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICByZXR1cm4gZmllbGRWYWx1ZXM7XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IGdlbmVyYXRlSWQgZnJvbSAnLi9sb2dpYy9nZW5lcmF0ZUlkJztcbmltcG9ydCBnZXRGb2N1c0ZpZWxkTmFtZSBmcm9tICcuL2xvZ2ljL2dldEZvY3VzRmllbGROYW1lJztcbmltcG9ydCBnZXRWYWxpZGF0aW9uTW9kZXMgZnJvbSAnLi9sb2dpYy9nZXRWYWxpZGF0aW9uTW9kZXMnO1xuaW1wb3J0IGlzV2F0Y2hlZCBmcm9tICcuL2xvZ2ljL2lzV2F0Y2hlZCc7XG5pbXBvcnQgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uIGZyb20gJy4vbG9naWMvaXRlcmF0ZUZpZWxkc0J5QWN0aW9uJztcbmltcG9ydCB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yIGZyb20gJy4vbG9naWMvdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcic7XG5pbXBvcnQgdmFsaWRhdGVGaWVsZCBmcm9tICcuL2xvZ2ljL3ZhbGlkYXRlRmllbGQnO1xuaW1wb3J0IGFwcGVuZEF0IGZyb20gJy4vdXRpbHMvYXBwZW5kJztcbmltcG9ydCBjbG9uZU9iamVjdCBmcm9tICcuL3V0aWxzL2Nsb25lT2JqZWN0JztcbmltcG9ydCBjb252ZXJ0VG9BcnJheVBheWxvYWQgZnJvbSAnLi91dGlscy9jb252ZXJ0VG9BcnJheVBheWxvYWQnO1xuaW1wb3J0IGZpbGxFbXB0eUFycmF5IGZyb20gJy4vdXRpbHMvZmlsbEVtcHR5QXJyYXknO1xuaW1wb3J0IGdldCBmcm9tICcuL3V0aWxzL2dldCc7XG5pbXBvcnQgaW5zZXJ0QXQgZnJvbSAnLi91dGlscy9pbnNlcnQnO1xuaW1wb3J0IGlzRW1wdHlPYmplY3QgZnJvbSAnLi91dGlscy9pc0VtcHR5T2JqZWN0JztcbmltcG9ydCBtb3ZlQXJyYXlBdCBmcm9tICcuL3V0aWxzL21vdmUnO1xuaW1wb3J0IHByZXBlbmRBdCBmcm9tICcuL3V0aWxzL3ByZXBlbmQnO1xuaW1wb3J0IHJlbW92ZUFycmF5QXQgZnJvbSAnLi91dGlscy9yZW1vdmUnO1xuaW1wb3J0IHNldCBmcm9tICcuL3V0aWxzL3NldCc7XG5pbXBvcnQgc3dhcEFycmF5QXQgZnJvbSAnLi91dGlscy9zd2FwJztcbmltcG9ydCB1bnNldCBmcm9tICcuL3V0aWxzL3Vuc2V0JztcbmltcG9ydCB1cGRhdGVBdCBmcm9tICcuL3V0aWxzL3VwZGF0ZSc7XG5pbXBvcnQgeyBWQUxJREFUSU9OX01PREUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBDb250cm9sLFxuICBGaWVsZCxcbiAgRmllbGRBcnJheSxcbiAgRmllbGRBcnJheU1ldGhvZFByb3BzLFxuICBGaWVsZEFycmF5UGF0aCxcbiAgRmllbGRBcnJheVdpdGhJZCxcbiAgRmllbGRFcnJvcnMsXG4gIEZpZWxkUGF0aCxcbiAgRmllbGRWYWx1ZXMsXG4gIEZvcm1TdGF0ZSxcbiAgSW50ZXJuYWxGaWVsZE5hbWUsXG4gIFJlZ2lzdGVyT3B0aW9ucyxcbiAgVXNlRmllbGRBcnJheVByb3BzLFxuICBVc2VGaWVsZEFycmF5UmV0dXJuLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHVzZUZvcm1Db250ZXh0IH0gZnJvbSAnLi91c2VGb3JtQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VTdWJzY3JpYmUgfSBmcm9tICcuL3VzZVN1YnNjcmliZSc7XG5cbi8qKlxuICogQSBjdXN0b20gaG9vayB0aGF0IGV4cG9zZXMgY29udmVuaWVudCBtZXRob2RzIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyB3aXRoIGEgbGlzdCBvZiBkeW5hbWljIGlucHV0cyB0aGF0IG5lZWQgdG8gYmUgYXBwZW5kZWQsIHVwZGF0ZWQsIHJlbW92ZWQgZXRjLiDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdXNlZmllbGRhcnJheS1zc3Vnbikg4oCiIFtWaWRlb10oaHR0cHM6Ly95b3V0dS5iZS80TXJiZkdTRlkyQSlcbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZmllbGRhcnJheSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXVzZWZpZWxkYXJyYXktc3N1Z24pXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdXNlRmllbGRBcnJheSBwcm9wc1xuICpcbiAqIEByZXR1cm5zIG1ldGhvZHMgLSBmdW5jdGlvbnMgdG8gbWFuaXB1bGF0ZSB3aXRoIHRoZSBGaWVsZCBBcnJheXMgKGR5bmFtaWMgaW5wdXRzKSB7QGxpbmsgVXNlRmllbGRBcnJheVJldHVybn1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIsIGNvbnRyb2wsIGhhbmRsZVN1Ym1pdCwgcmVzZXQsIHRyaWdnZXIsIHNldEVycm9yIH0gPSB1c2VGb3JtKHtcbiAqICAgICBkZWZhdWx0VmFsdWVzOiB7XG4gKiAgICAgICB0ZXN0OiBbXVxuICogICAgIH1cbiAqICAgfSk7XG4gKiAgIGNvbnN0IHsgZmllbGRzLCBhcHBlbmQgfSA9IHVzZUZpZWxkQXJyYXkoe1xuICogICAgIGNvbnRyb2wsXG4gKiAgICAgbmFtZTogXCJ0ZXN0XCJcbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXQoZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKSl9PlxuICogICAgICAge2ZpZWxkcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gKiAgICAgICAgICA8aW5wdXQga2V5PXtpdGVtLmlkfSB7Li4ucmVnaXN0ZXIoYHRlc3QuJHtpbmRleH0uZmlyc3ROYW1lYCl9ICAvPlxuICogICAgICAgKSl9XG4gKiAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXsoKSA9PiBhcHBlbmQoeyBmaXJzdE5hbWU6IFwiYmlsbFwiIH0pfT5cbiAqICAgICAgICAgYXBwZW5kXG4gKiAgICAgICA8L2J1dHRvbj5cbiAqICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZpZWxkQXJyYXk8XG4gIFRGaWVsZFZhbHVlcyBleHRlbmRzIEZpZWxkVmFsdWVzID0gRmllbGRWYWx1ZXMsXG4gIFRGaWVsZEFycmF5TmFtZSBleHRlbmRzIEZpZWxkQXJyYXlQYXRoPFRGaWVsZFZhbHVlcz4gPSBGaWVsZEFycmF5UGF0aDxURmllbGRWYWx1ZXM+LFxuICBUS2V5TmFtZSBleHRlbmRzIHN0cmluZyA9ICdpZCcsXG4+KFxuICBwcm9wczogVXNlRmllbGRBcnJheVByb3BzPFRGaWVsZFZhbHVlcywgVEZpZWxkQXJyYXlOYW1lLCBUS2V5TmFtZT4sXG4pOiBVc2VGaWVsZEFycmF5UmV0dXJuPFRGaWVsZFZhbHVlcywgVEZpZWxkQXJyYXlOYW1lLCBUS2V5TmFtZT4ge1xuICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgY29uc3Qge1xuICAgIGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsXG4gICAgbmFtZSxcbiAgICBrZXlOYW1lID0gJ2lkJyxcbiAgICBzaG91bGRVbnJlZ2lzdGVyLFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtmaWVsZHMsIHNldEZpZWxkc10gPSBSZWFjdC51c2VTdGF0ZShjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpKTtcbiAgY29uc3QgaWRzID0gUmVhY3QudXNlUmVmPHN0cmluZ1tdPihcbiAgICBjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLm1hcChnZW5lcmF0ZUlkKSxcbiAgKTtcbiAgY29uc3QgX2ZpZWxkSWRzID0gUmVhY3QudXNlUmVmKGZpZWxkcyk7XG4gIGNvbnN0IF9uYW1lID0gUmVhY3QudXNlUmVmKG5hbWUpO1xuICBjb25zdCBfYWN0aW9uZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuXG4gIF9uYW1lLmN1cnJlbnQgPSBuYW1lO1xuICBfZmllbGRJZHMuY3VycmVudCA9IGZpZWxkcztcbiAgY29udHJvbC5fbmFtZXMuYXJyYXkuYWRkKG5hbWUpO1xuXG4gIHByb3BzLnJ1bGVzICYmXG4gICAgKGNvbnRyb2wgYXMgQ29udHJvbDxURmllbGRWYWx1ZXM+KS5yZWdpc3RlcihcbiAgICAgIG5hbWUgYXMgRmllbGRQYXRoPFRGaWVsZFZhbHVlcz4sXG4gICAgICBwcm9wcy5ydWxlcyBhcyBSZWdpc3Rlck9wdGlvbnM8VEZpZWxkVmFsdWVzPixcbiAgICApO1xuXG4gIHVzZVN1YnNjcmliZSh7XG4gICAgbmV4dDogKHtcbiAgICAgIHZhbHVlcyxcbiAgICAgIG5hbWU6IGZpZWxkQXJyYXlOYW1lLFxuICAgIH06IHtcbiAgICAgIHZhbHVlcz86IEZpZWxkVmFsdWVzO1xuICAgICAgbmFtZT86IEludGVybmFsRmllbGROYW1lO1xuICAgIH0pID0+IHtcbiAgICAgIGlmIChmaWVsZEFycmF5TmFtZSA9PT0gX25hbWUuY3VycmVudCB8fCAhZmllbGRBcnJheU5hbWUpIHtcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXQodmFsdWVzLCBfbmFtZS5jdXJyZW50KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZXMpKSB7XG4gICAgICAgICAgc2V0RmllbGRzKGZpZWxkVmFsdWVzKTtcbiAgICAgICAgICBpZHMuY3VycmVudCA9IGZpZWxkVmFsdWVzLm1hcChnZW5lcmF0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3ViamVjdDogY29udHJvbC5fc3ViamVjdHMuYXJyYXksXG4gIH0pO1xuXG4gIGNvbnN0IHVwZGF0ZVZhbHVlcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIDxcbiAgICAgIFQgZXh0ZW5kcyBQYXJ0aWFsPFxuICAgICAgICBGaWVsZEFycmF5V2l0aElkPFRGaWVsZFZhbHVlcywgVEZpZWxkQXJyYXlOYW1lLCBUS2V5TmFtZT5cbiAgICAgID5bXSxcbiAgICA+KFxuICAgICAgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXM6IFQsXG4gICAgKSA9PiB7XG4gICAgICBfYWN0aW9uZWQuY3VycmVudCA9IHRydWU7XG4gICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICB9LFxuICAgIFtjb250cm9sLCBuYW1lXSxcbiAgKTtcblxuICBjb25zdCBhcHBlbmQgPSAoXG4gICAgdmFsdWU6XG4gICAgICB8IFBhcnRpYWw8RmllbGRBcnJheTxURmllbGRWYWx1ZXMsIFRGaWVsZEFycmF5TmFtZT4+XG4gICAgICB8IFBhcnRpYWw8RmllbGRBcnJheTxURmllbGRWYWx1ZXMsIFRGaWVsZEFycmF5TmFtZT4+W10sXG4gICAgb3B0aW9ucz86IEZpZWxkQXJyYXlNZXRob2RQcm9wcyxcbiAgKSA9PiB7XG4gICAgY29uc3QgYXBwZW5kVmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGFwcGVuZEF0KFxuICAgICAgY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSxcbiAgICAgIGFwcGVuZFZhbHVlLFxuICAgICk7XG4gICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShcbiAgICAgIG5hbWUsXG4gICAgICB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5sZW5ndGggLSAxLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIGlkcy5jdXJyZW50ID0gYXBwZW5kQXQoaWRzLmN1cnJlbnQsIGFwcGVuZFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGFwcGVuZEF0LCB7XG4gICAgICBhcmdBOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgcHJlcGVuZCA9IChcbiAgICB2YWx1ZTpcbiAgICAgIHwgUGFydGlhbDxGaWVsZEFycmF5PFRGaWVsZFZhbHVlcywgVEZpZWxkQXJyYXlOYW1lPj5cbiAgICAgIHwgUGFydGlhbDxGaWVsZEFycmF5PFRGaWVsZFZhbHVlcywgVEZpZWxkQXJyYXlOYW1lPj5bXSxcbiAgICBvcHRpb25zPzogRmllbGRBcnJheU1ldGhvZFByb3BzLFxuICApID0+IHtcbiAgICBjb25zdCBwcmVwZW5kVmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHByZXBlbmRBdChcbiAgICAgIGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksXG4gICAgICBwcmVwZW5kVmFsdWUsXG4gICAgKTtcbiAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9IGdldEZvY3VzRmllbGROYW1lKG5hbWUsIDAsIG9wdGlvbnMpO1xuICAgIGlkcy5jdXJyZW50ID0gcHJlcGVuZEF0KGlkcy5jdXJyZW50LCBwcmVwZW5kVmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgcHJlcGVuZEF0LCB7XG4gICAgICBhcmdBOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgcmVtb3ZlID0gKGluZGV4PzogbnVtYmVyIHwgbnVtYmVyW10pID0+IHtcbiAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlczogUGFydGlhbDxcbiAgICAgIEZpZWxkQXJyYXlXaXRoSWQ8VEZpZWxkVmFsdWVzLCBURmllbGRBcnJheU5hbWUsIFRLZXlOYW1lPlxuICAgID5bXSA9IHJlbW92ZUFycmF5QXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgpO1xuICAgIGlkcy5jdXJyZW50ID0gcmVtb3ZlQXJyYXlBdChpZHMuY3VycmVudCwgaW5kZXgpO1xuICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCByZW1vdmVBcnJheUF0LCB7XG4gICAgICBhcmdBOiBpbmRleCxcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBpbnNlcnQgPSAoXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICB2YWx1ZTpcbiAgICAgIHwgUGFydGlhbDxGaWVsZEFycmF5PFRGaWVsZFZhbHVlcywgVEZpZWxkQXJyYXlOYW1lPj5cbiAgICAgIHwgUGFydGlhbDxGaWVsZEFycmF5PFRGaWVsZFZhbHVlcywgVEZpZWxkQXJyYXlOYW1lPj5bXSxcbiAgICBvcHRpb25zPzogRmllbGRBcnJheU1ldGhvZFByb3BzLFxuICApID0+IHtcbiAgICBjb25zdCBpbnNlcnRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gaW5zZXJ0QXQoXG4gICAgICBjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLFxuICAgICAgaW5kZXgsXG4gICAgICBpbnNlcnRWYWx1ZSxcbiAgICApO1xuICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gZ2V0Rm9jdXNGaWVsZE5hbWUobmFtZSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgIGlkcy5jdXJyZW50ID0gaW5zZXJ0QXQoaWRzLmN1cnJlbnQsIGluZGV4LCBpbnNlcnRWYWx1ZS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBpbnNlcnRBdCwge1xuICAgICAgYXJnQTogaW5kZXgsXG4gICAgICBhcmdCOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3Qgc3dhcCA9IChpbmRleEE6IG51bWJlciwgaW5kZXhCOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgc3dhcEFycmF5QXQodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGluZGV4QSwgaW5kZXhCKTtcbiAgICBzd2FwQXJyYXlBdChpZHMuY3VycmVudCwgaW5kZXhBLCBpbmRleEIpO1xuICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KFxuICAgICAgbmFtZSxcbiAgICAgIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLFxuICAgICAgc3dhcEFycmF5QXQsXG4gICAgICB7XG4gICAgICAgIGFyZ0E6IGluZGV4QSxcbiAgICAgICAgYXJnQjogaW5kZXhCLFxuICAgICAgfSxcbiAgICAgIGZhbHNlLFxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgbW92ZSA9IChmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgbW92ZUFycmF5QXQodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGZyb20sIHRvKTtcbiAgICBtb3ZlQXJyYXlBdChpZHMuY3VycmVudCwgZnJvbSwgdG8pO1xuICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KFxuICAgICAgbmFtZSxcbiAgICAgIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLFxuICAgICAgbW92ZUFycmF5QXQsXG4gICAgICB7XG4gICAgICAgIGFyZ0E6IGZyb20sXG4gICAgICAgIGFyZ0I6IHRvLFxuICAgICAgfSxcbiAgICAgIGZhbHNlLFxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlID0gKFxuICAgIGluZGV4OiBudW1iZXIsXG4gICAgdmFsdWU6IEZpZWxkQXJyYXk8VEZpZWxkVmFsdWVzLCBURmllbGRBcnJheU5hbWU+LFxuICApID0+IHtcbiAgICBjb25zdCB1cGRhdGVWYWx1ZSA9IGNsb25lT2JqZWN0KHZhbHVlKTtcbiAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHVwZGF0ZUF0KFxuICAgICAgY29udHJvbC5fZ2V0RmllbGRBcnJheTxcbiAgICAgICAgRmllbGRBcnJheVdpdGhJZDxURmllbGRWYWx1ZXMsIFRGaWVsZEFycmF5TmFtZSwgVEtleU5hbWU+XG4gICAgICA+KG5hbWUpLFxuICAgICAgaW5kZXgsXG4gICAgICB1cGRhdGVWYWx1ZSBhcyBGaWVsZEFycmF5V2l0aElkPFRGaWVsZFZhbHVlcywgVEZpZWxkQXJyYXlOYW1lLCBUS2V5TmFtZT4sXG4gICAgKTtcbiAgICBpZHMuY3VycmVudCA9IFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10ubWFwKChpdGVtLCBpKSA9PlxuICAgICAgIWl0ZW0gfHwgaSA9PT0gaW5kZXggPyBnZW5lcmF0ZUlkKCkgOiBpZHMuY3VycmVudFtpXSxcbiAgICApO1xuICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgc2V0RmllbGRzKFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10pO1xuICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkoXG4gICAgICBuYW1lLFxuICAgICAgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsXG4gICAgICB1cGRhdGVBdCxcbiAgICAgIHtcbiAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgIGFyZ0I6IHVwZGF0ZVZhbHVlLFxuICAgICAgfSxcbiAgICAgIHRydWUsXG4gICAgICBmYWxzZSxcbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IHJlcGxhY2UgPSAoXG4gICAgdmFsdWU6XG4gICAgICB8IFBhcnRpYWw8RmllbGRBcnJheTxURmllbGRWYWx1ZXMsIFRGaWVsZEFycmF5TmFtZT4+XG4gICAgICB8IFBhcnRpYWw8RmllbGRBcnJheTxURmllbGRWYWx1ZXMsIFRGaWVsZEFycmF5TmFtZT4+W10sXG4gICkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgaWRzLmN1cnJlbnQgPSB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5tYXAoZ2VuZXJhdGVJZCk7XG4gICAgdXBkYXRlVmFsdWVzKFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10pO1xuICAgIHNldEZpZWxkcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KFxuICAgICAgbmFtZSxcbiAgICAgIFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10sXG4gICAgICA8VD4oZGF0YTogVCk6IFQgPT4gZGF0YSxcbiAgICAgIHt9LFxuICAgICAgdHJ1ZSxcbiAgICAgIGZhbHNlLFxuICAgICk7XG4gIH07XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb250cm9sLl9zdGF0ZS5hY3Rpb24gPSBmYWxzZTtcblxuICAgIGlzV2F0Y2hlZChuYW1lLCBjb250cm9sLl9uYW1lcykgJiZcbiAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICB9IGFzIEZvcm1TdGF0ZTxURmllbGRWYWx1ZXM+KTtcblxuICAgIGlmIChcbiAgICAgIF9hY3Rpb25lZC5jdXJyZW50ICYmXG4gICAgICAoIWdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLm1vZGUpLmlzT25TdWJtaXQgfHxcbiAgICAgICAgY29udHJvbC5fZm9ybVN0YXRlLmlzU3VibWl0dGVkKVxuICAgICkge1xuICAgICAgaWYgKGNvbnRyb2wuX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgICAgY29udHJvbC5fZXhlY3V0ZVNjaGVtYShbbmFtZV0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0KHJlc3VsdC5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXJyb3IgPSBnZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBleGlzdGluZ0Vycm9yXG4gICAgICAgICAgICAgID8gKCFlcnJvciAmJiBleGlzdGluZ0Vycm9yLnR5cGUpIHx8XG4gICAgICAgICAgICAgICAgKGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAoZXhpc3RpbmdFcnJvci50eXBlICE9PSBlcnJvci50eXBlIHx8XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRXJyb3IubWVzc2FnZSAhPT0gZXJyb3IubWVzc2FnZSkpXG4gICAgICAgICAgICAgIDogZXJyb3IgJiYgZXJyb3IudHlwZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgPyBzZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXG4gICAgICAgICAgICAgIDogdW5zZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgZXJyb3JzOiBjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzIGFzIEZpZWxkRXJyb3JzPFRGaWVsZFZhbHVlcz4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmllbGQ6IEZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBmaWVsZCAmJlxuICAgICAgICAgIGZpZWxkLl9mICYmXG4gICAgICAgICAgIShcbiAgICAgICAgICAgIGdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLnJlVmFsaWRhdGVNb2RlKS5pc09uU3VibWl0ICYmXG4gICAgICAgICAgICBnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5tb2RlKS5pc09uU3VibWl0XG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB2YWxpZGF0ZUZpZWxkKFxuICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICBjb250cm9sLl9mb3JtVmFsdWVzLFxuICAgICAgICAgICAgY29udHJvbC5fb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGwsXG4gICAgICAgICAgICBjb250cm9sLl9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICkudGhlbihcbiAgICAgICAgICAgIChlcnJvcikgPT5cbiAgICAgICAgICAgICAgIWlzRW1wdHlPYmplY3QoZXJyb3IpICYmXG4gICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGVycm9yczogdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcihcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMgYXMgRmllbGRFcnJvcnM8VEZpZWxkVmFsdWVzPixcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICApIGFzIEZpZWxkRXJyb3JzPFRGaWVsZFZhbHVlcz4sXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250cm9sLl9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICBuYW1lLFxuICAgICAgdmFsdWVzOiB7IC4uLmNvbnRyb2wuX2Zvcm1WYWx1ZXMgfSxcbiAgICB9KTtcblxuICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzICYmXG4gICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oY29udHJvbC5fZmllbGRzLCAocmVmLCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgJiZcbiAgICAgICAgICBrZXkuc3RhcnRzV2l0aChjb250cm9sLl9uYW1lcy5mb2N1cykgJiZcbiAgICAgICAgICByZWYuZm9jdXNcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVmLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSk7XG5cbiAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9ICcnO1xuXG4gICAgY29udHJvbC5fdXBkYXRlVmFsaWQoKTtcbiAgICBfYWN0aW9uZWQuY3VycmVudCA9IGZhbHNlO1xuICB9LCBbZmllbGRzLCBuYW1lLCBjb250cm9sXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAhZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUpICYmIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgKGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBzaG91bGRVbnJlZ2lzdGVyKSAmJlxuICAgICAgICBjb250cm9sLnVucmVnaXN0ZXIobmFtZSBhcyBGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPik7XG4gICAgfTtcbiAgfSwgW25hbWUsIGNvbnRyb2wsIGtleU5hbWUsIHNob3VsZFVucmVnaXN0ZXJdKTtcblxuICByZXR1cm4ge1xuICAgIHN3YXA6IFJlYWN0LnVzZUNhbGxiYWNrKHN3YXAsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICBtb3ZlOiBSZWFjdC51c2VDYWxsYmFjayhtb3ZlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgcHJlcGVuZDogUmVhY3QudXNlQ2FsbGJhY2socHJlcGVuZCwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgIGFwcGVuZDogUmVhY3QudXNlQ2FsbGJhY2soYXBwZW5kLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgcmVtb3ZlOiBSZWFjdC51c2VDYWxsYmFjayhyZW1vdmUsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICBpbnNlcnQ6IFJlYWN0LnVzZUNhbGxiYWNrKGluc2VydCwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgIHVwZGF0ZTogUmVhY3QudXNlQ2FsbGJhY2sodXBkYXRlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgcmVwbGFjZTogUmVhY3QudXNlQ2FsbGJhY2socmVwbGFjZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgIGZpZWxkczogUmVhY3QudXNlTWVtbyhcbiAgICAgICgpID0+XG4gICAgICAgIGZpZWxkcy5tYXAoKGZpZWxkLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICBba2V5TmFtZV06IGlkcy5jdXJyZW50W2luZGV4XSB8fCBnZW5lcmF0ZUlkKCksXG4gICAgICAgIH0pKSBhcyBGaWVsZEFycmF5V2l0aElkPFRGaWVsZFZhbHVlcywgVEZpZWxkQXJyYXlOYW1lLCBUS2V5TmFtZT5bXSxcbiAgICAgIFtmaWVsZHMsIGtleU5hbWVdLFxuICAgICksXG4gIH07XG59XG4iLCJpbXBvcnQgeyBOb29wIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBPYnNlcnZlcjxUPiA9IHtcbiAgbmV4dDogKHZhbHVlOiBUKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IHR5cGUgU3Vic2NyaXB0aW9uID0ge1xuICB1bnN1YnNjcmliZTogTm9vcDtcbn07XG5cbmV4cG9ydCB0eXBlIFN1YmplY3Q8VD4gPSB7XG4gIHJlYWRvbmx5IG9ic2VydmVyczogT2JzZXJ2ZXI8VD5bXTtcbiAgc3Vic2NyaWJlOiAodmFsdWU6IE9ic2VydmVyPFQ+KSA9PiBTdWJzY3JpcHRpb247XG4gIHVuc3Vic2NyaWJlOiBOb29wO1xufSAmIE9ic2VydmVyPFQ+O1xuXG5leHBvcnQgZGVmYXVsdCA8VD4oKTogU3ViamVjdDxUPiA9PiB7XG4gIGxldCBfb2JzZXJ2ZXJzOiBPYnNlcnZlcjxUPltdID0gW107XG5cbiAgY29uc3QgbmV4dCA9ICh2YWx1ZTogVCkgPT4ge1xuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgX29ic2VydmVycykge1xuICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3Vic2NyaWJlID0gKG9ic2VydmVyOiBPYnNlcnZlcjxUPik6IFN1YnNjcmlwdGlvbiA9PiB7XG4gICAgX29ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgX29ic2VydmVycyA9IF9vYnNlcnZlcnMuZmlsdGVyKChvKSA9PiBvICE9PSBvYnNlcnZlcik7XG4gICAgICB9LFxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgX29ic2VydmVycyA9IFtdO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBfb2JzZXJ2ZXJzO1xuICAgIH0sXG4gICAgbmV4dCxcbiAgICBzdWJzY3JpYmUsXG4gICAgdW5zdWJzY3JpYmUsXG4gIH07XG59O1xuIiwiaW1wb3J0IHsgUHJpbWl0aXZlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgaXNOdWxsT3JVbmRlZmluZWQgZnJvbSAnLi9pc051bGxPclVuZGVmaW5lZCc7XG5pbXBvcnQgeyBpc09iamVjdFR5cGUgfSBmcm9tICcuL2lzT2JqZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgUHJpbWl0aXZlID0+XG4gIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCAhaXNPYmplY3RUeXBlKHZhbHVlKTtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuLi91dGlscy9pc09iamVjdCc7XG5cbmltcG9ydCBpc0RhdGVPYmplY3QgZnJvbSAnLi9pc0RhdGVPYmplY3QnO1xuaW1wb3J0IGlzUHJpbWl0aXZlIGZyb20gJy4vaXNQcmltaXRpdmUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWVwRXF1YWwob2JqZWN0MTogYW55LCBvYmplY3QyOiBhbnkpIHtcbiAgaWYgKGlzUHJpbWl0aXZlKG9iamVjdDEpIHx8IGlzUHJpbWl0aXZlKG9iamVjdDIpKSB7XG4gICAgcmV0dXJuIG9iamVjdDEgPT09IG9iamVjdDI7XG4gIH1cblxuICBpZiAoaXNEYXRlT2JqZWN0KG9iamVjdDEpICYmIGlzRGF0ZU9iamVjdChvYmplY3QyKSkge1xuICAgIHJldHVybiBvYmplY3QxLmdldFRpbWUoKSA9PT0gb2JqZWN0Mi5nZXRUaW1lKCk7XG4gIH1cblxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iamVjdDEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuXG4gIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgY29uc3QgdmFsMSA9IG9iamVjdDFba2V5XTtcblxuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChrZXkgIT09ICdyZWYnKSB7XG4gICAgICBjb25zdCB2YWwyID0gb2JqZWN0MltrZXldO1xuXG4gICAgICBpZiAoXG4gICAgICAgIChpc0RhdGVPYmplY3QodmFsMSkgJiYgaXNEYXRlT2JqZWN0KHZhbDIpKSB8fFxuICAgICAgICAoaXNPYmplY3QodmFsMSkgJiYgaXNPYmplY3QodmFsMikpIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KHZhbDEpICYmIEFycmF5LmlzQXJyYXkodmFsMikpXG4gICAgICAgICAgPyAhZGVlcEVxdWFsKHZhbDEsIHZhbDIpXG4gICAgICAgICAgOiB2YWwxICE9PSB2YWwyXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgRmllbGRFbGVtZW50IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCAoZWxlbWVudDogRmllbGRFbGVtZW50KTogZWxlbWVudCBpcyBIVE1MU2VsZWN0RWxlbWVudCA9PlxuICBlbGVtZW50LnR5cGUgPT09IGBzZWxlY3QtbXVsdGlwbGVgO1xuIiwiaW1wb3J0IHsgRmllbGRFbGVtZW50IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgaXNDaGVja0JveElucHV0IGZyb20gJy4vaXNDaGVja0JveElucHV0JztcbmltcG9ydCBpc1JhZGlvSW5wdXQgZnJvbSAnLi9pc1JhZGlvSW5wdXQnO1xuXG5leHBvcnQgZGVmYXVsdCAocmVmOiBGaWVsZEVsZW1lbnQpOiByZWYgaXMgSFRNTElucHV0RWxlbWVudCA9PlxuICBpc1JhZGlvSW5wdXQocmVmKSB8fCBpc0NoZWNrQm94SW5wdXQocmVmKTtcbiIsImltcG9ydCB7IFJlZiB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IGlzSFRNTEVsZW1lbnQgZnJvbSAnLi9pc0hUTUxFbGVtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgKHJlZjogUmVmKSA9PiBpc0hUTUxFbGVtZW50KHJlZikgJiYgcmVmLmlzQ29ubmVjdGVkO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgPFQ+KGRhdGE6IFQpOiBib29sZWFuID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKGRhdGFba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiaW1wb3J0IGRlZXBFcXVhbCBmcm9tICcuLi91dGlscy9kZWVwRXF1YWwnO1xuaW1wb3J0IGlzTnVsbE9yVW5kZWZpbmVkIGZyb20gJy4uL3V0aWxzL2lzTnVsbE9yVW5kZWZpbmVkJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuLi91dGlscy9pc09iamVjdCc7XG5pbXBvcnQgaXNQcmltaXRpdmUgZnJvbSAnLi4vdXRpbHMvaXNQcmltaXRpdmUnO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gJy4uL3V0aWxzL2lzVW5kZWZpbmVkJztcbmltcG9ydCBvYmplY3RIYXNGdW5jdGlvbiBmcm9tICcuLi91dGlscy9vYmplY3RIYXNGdW5jdGlvbic7XG5cbmZ1bmN0aW9uIG1hcmtGaWVsZHNEaXJ0eTxUPihkYXRhOiBULCBmaWVsZHM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSkge1xuICBjb25zdCBpc1BhcmVudE5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG5cbiAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IGlzUGFyZW50Tm9kZUFycmF5KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgfHxcbiAgICAgICAgKGlzT2JqZWN0KGRhdGFba2V5XSkgJiYgIW9iamVjdEhhc0Z1bmN0aW9uKGRhdGFba2V5XSkpXG4gICAgICApIHtcbiAgICAgICAgZmllbGRzW2tleV0gPSBBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgPyBbXSA6IHt9O1xuICAgICAgICBtYXJrRmllbGRzRGlydHkoZGF0YVtrZXldLCBmaWVsZHNba2V5XSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChkYXRhW2tleV0pKSB7XG4gICAgICAgIGZpZWxkc1trZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBnZXREaXJ0eUZpZWxkc0Zyb21EZWZhdWx0VmFsdWVzPFQ+KFxuICBkYXRhOiBULFxuICBmb3JtVmFsdWVzOiBULFxuICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXM6IFJlY29yZDxcbiAgICBFeHRyYWN0PGtleW9mIFQsIHN0cmluZz4sXG4gICAgUmV0dXJuVHlwZTx0eXBlb2YgbWFya0ZpZWxkc0RpcnR5PiB8IGJvb2xlYW5cbiAgPixcbikge1xuICBjb25zdCBpc1BhcmVudE5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG5cbiAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IGlzUGFyZW50Tm9kZUFycmF5KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgfHxcbiAgICAgICAgKGlzT2JqZWN0KGRhdGFba2V5XSkgJiYgIW9iamVjdEhhc0Z1bmN0aW9uKGRhdGFba2V5XSkpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpIHx8XG4gICAgICAgICAgaXNQcmltaXRpdmUoZGlydHlGaWVsZHNGcm9tVmFsdWVzW2tleV0pXG4gICAgICAgICkge1xuICAgICAgICAgIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldID0gQXJyYXkuaXNBcnJheShkYXRhW2tleV0pXG4gICAgICAgICAgICA/IG1hcmtGaWVsZHNEaXJ0eShkYXRhW2tleV0sIFtdKVxuICAgICAgICAgICAgOiB7IC4uLm1hcmtGaWVsZHNEaXJ0eShkYXRhW2tleV0pIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyhcbiAgICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICAgIGlzTnVsbE9yVW5kZWZpbmVkKGZvcm1WYWx1ZXMpID8ge30gOiBmb3JtVmFsdWVzW2tleV0sXG4gICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9ICFkZWVwRXF1YWwoZGF0YVtrZXldLCBmb3JtVmFsdWVzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IDxUPihkZWZhdWx0VmFsdWVzOiBULCBmb3JtVmFsdWVzOiBUKSA9PlxuICBnZXREaXJ0eUZpZWxkc0Zyb21EZWZhdWx0VmFsdWVzKFxuICAgIGRlZmF1bHRWYWx1ZXMsXG4gICAgZm9ybVZhbHVlcyxcbiAgICBtYXJrRmllbGRzRGlydHkoZm9ybVZhbHVlcyksXG4gICk7XG4iLCJpbXBvcnQgeyBGaWVsZCwgTmF0aXZlRmllbGRWYWx1ZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBpc1N0cmluZyBmcm9tICcuLi91dGlscy9pc1N0cmluZyc7XG5pbXBvcnQgaXNVbmRlZmluZWQgZnJvbSAnLi4vdXRpbHMvaXNVbmRlZmluZWQnO1xuXG5leHBvcnQgZGVmYXVsdCA8VCBleHRlbmRzIE5hdGl2ZUZpZWxkVmFsdWU+KFxuICB2YWx1ZTogVCxcbiAgeyB2YWx1ZUFzTnVtYmVyLCB2YWx1ZUFzRGF0ZSwgc2V0VmFsdWVBcyB9OiBGaWVsZFsnX2YnXSxcbikgPT5cbiAgaXNVbmRlZmluZWQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogdmFsdWVBc051bWJlclxuICAgID8gdmFsdWUgPT09ICcnXG4gICAgICA/IE5hTlxuICAgICAgOiB2YWx1ZVxuICAgICAgPyArdmFsdWVcbiAgICAgIDogdmFsdWVcbiAgICA6IHZhbHVlQXNEYXRlICYmIGlzU3RyaW5nKHZhbHVlKVxuICAgID8gbmV3IERhdGUodmFsdWUpXG4gICAgOiBzZXRWYWx1ZUFzXG4gICAgPyBzZXRWYWx1ZUFzKHZhbHVlKVxuICAgIDogdmFsdWU7XG4iLCJpbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBpc0NoZWNrQm94IGZyb20gJy4uL3V0aWxzL2lzQ2hlY2tCb3hJbnB1dCc7XG5pbXBvcnQgaXNGaWxlSW5wdXQgZnJvbSAnLi4vdXRpbHMvaXNGaWxlSW5wdXQnO1xuaW1wb3J0IGlzTXVsdGlwbGVTZWxlY3QgZnJvbSAnLi4vdXRpbHMvaXNNdWx0aXBsZVNlbGVjdCc7XG5pbXBvcnQgaXNSYWRpb0lucHV0IGZyb20gJy4uL3V0aWxzL2lzUmFkaW9JbnB1dCc7XG5pbXBvcnQgaXNVbmRlZmluZWQgZnJvbSAnLi4vdXRpbHMvaXNVbmRlZmluZWQnO1xuXG5pbXBvcnQgZ2V0Q2hlY2tib3hWYWx1ZSBmcm9tICcuL2dldENoZWNrYm94VmFsdWUnO1xuaW1wb3J0IGdldEZpZWxkVmFsdWVBcyBmcm9tICcuL2dldEZpZWxkVmFsdWVBcyc7XG5pbXBvcnQgZ2V0UmFkaW9WYWx1ZSBmcm9tICcuL2dldFJhZGlvVmFsdWUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGaWVsZFZhbHVlKF9mOiBGaWVsZFsnX2YnXSkge1xuICBjb25zdCByZWYgPSBfZi5yZWY7XG5cbiAgaWYgKF9mLnJlZnMgPyBfZi5yZWZzLmV2ZXJ5KChyZWYpID0+IHJlZi5kaXNhYmxlZCkgOiByZWYuZGlzYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNGaWxlSW5wdXQocmVmKSkge1xuICAgIHJldHVybiByZWYuZmlsZXM7XG4gIH1cblxuICBpZiAoaXNSYWRpb0lucHV0KHJlZikpIHtcbiAgICByZXR1cm4gZ2V0UmFkaW9WYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgfVxuXG4gIGlmIChpc011bHRpcGxlU2VsZWN0KHJlZikpIHtcbiAgICByZXR1cm4gWy4uLnJlZi5zZWxlY3RlZE9wdGlvbnNdLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG4gIH1cblxuICBpZiAoaXNDaGVja0JveChyZWYpKSB7XG4gICAgcmV0dXJuIGdldENoZWNrYm94VmFsdWUoX2YucmVmcykudmFsdWU7XG4gIH1cblxuICByZXR1cm4gZ2V0RmllbGRWYWx1ZUFzKGlzVW5kZWZpbmVkKHJlZi52YWx1ZSkgPyBfZi5yZWYudmFsdWUgOiByZWYudmFsdWUsIF9mKTtcbn1cbiIsImltcG9ydCB7XG4gIENyaXRlcmlhTW9kZSxcbiAgRmllbGQsXG4gIEZpZWxkTmFtZSxcbiAgRmllbGRSZWZzLFxuICBGaWVsZFZhbHVlcyxcbiAgSW50ZXJuYWxGaWVsZE5hbWUsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBzZXQgZnJvbSAnLi4vdXRpbHMvc2V0JztcblxuZXhwb3J0IGRlZmF1bHQgPFRGaWVsZFZhbHVlcyBleHRlbmRzIEZpZWxkVmFsdWVzPihcbiAgZmllbGRzTmFtZXM6IFNldDxJbnRlcm5hbEZpZWxkTmFtZT4gfCBJbnRlcm5hbEZpZWxkTmFtZVtdLFxuICBfZmllbGRzOiBGaWVsZFJlZnMsXG4gIGNyaXRlcmlhTW9kZT86IENyaXRlcmlhTW9kZSxcbiAgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbj86IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4pID0+IHtcbiAgY29uc3QgZmllbGRzOiBSZWNvcmQ8SW50ZXJuYWxGaWVsZE5hbWUsIEZpZWxkWydfZiddPiA9IHt9O1xuXG4gIGZvciAoY29uc3QgbmFtZSBvZiBmaWVsZHNOYW1lcykge1xuICAgIGNvbnN0IGZpZWxkOiBGaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcblxuICAgIGZpZWxkICYmIHNldChmaWVsZHMsIG5hbWUsIGZpZWxkLl9mKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JpdGVyaWFNb2RlLFxuICAgIG5hbWVzOiBbLi4uZmllbGRzTmFtZXNdIGFzIEZpZWxkTmFtZTxURmllbGRWYWx1ZXM+W10sXG4gICAgZmllbGRzLFxuICAgIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sXG4gIH07XG59O1xuIiwiaW1wb3J0IHtcbiAgVmFsaWRhdGlvblJ1bGUsXG4gIFZhbGlkYXRpb25WYWx1ZSxcbiAgVmFsaWRhdGlvblZhbHVlTWVzc2FnZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4uL3V0aWxzL2lzT2JqZWN0JztcbmltcG9ydCBpc1JlZ2V4IGZyb20gJy4uL3V0aWxzL2lzUmVnZXgnO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gJy4uL3V0aWxzL2lzVW5kZWZpbmVkJztcblxuZXhwb3J0IGRlZmF1bHQgPFQgZXh0ZW5kcyBWYWxpZGF0aW9uVmFsdWU+KFxuICBydWxlPzogVmFsaWRhdGlvblJ1bGU8VD4gfCBWYWxpZGF0aW9uVmFsdWVNZXNzYWdlPFQ+LFxuKSA9PlxuICBpc1VuZGVmaW5lZChydWxlKVxuICAgID8gcnVsZVxuICAgIDogaXNSZWdleChydWxlKVxuICAgID8gcnVsZS5zb3VyY2VcbiAgICA6IGlzT2JqZWN0KHJ1bGUpXG4gICAgPyBpc1JlZ2V4KHJ1bGUudmFsdWUpXG4gICAgICA/IHJ1bGUudmFsdWUuc291cmNlXG4gICAgICA6IHJ1bGUudmFsdWVcbiAgICA6IHJ1bGU7XG4iLCJpbXBvcnQgeyBGaWVsZCB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgKG9wdGlvbnM6IEZpZWxkWydfZiddKSA9PlxuICBvcHRpb25zLm1vdW50ICYmXG4gIChvcHRpb25zLnJlcXVpcmVkIHx8XG4gICAgb3B0aW9ucy5taW4gfHxcbiAgICBvcHRpb25zLm1heCB8fFxuICAgIG9wdGlvbnMubWF4TGVuZ3RoIHx8XG4gICAgb3B0aW9ucy5taW5MZW5ndGggfHxcbiAgICBvcHRpb25zLnBhdHRlcm4gfHxcbiAgICBvcHRpb25zLnZhbGlkYXRlKTtcbiIsImltcG9ydCB7IEZpZWxkRXJyb3IsIEZpZWxkRXJyb3JzLCBGaWVsZFZhbHVlcyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXQgZnJvbSAnLi4vdXRpbHMvZ2V0JztcbmltcG9ydCBpc0tleSBmcm9tICcuLi91dGlscy9pc0tleSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNjaGVtYUVycm9yTG9va3VwPFQgZXh0ZW5kcyBGaWVsZFZhbHVlcyA9IEZpZWxkVmFsdWVzPihcbiAgZXJyb3JzOiBGaWVsZEVycm9yczxUPixcbiAgX2ZpZWxkczogRmllbGRWYWx1ZXMsXG4gIG5hbWU6IHN0cmluZyxcbik6IHtcbiAgZXJyb3I/OiBGaWVsZEVycm9yO1xuICBuYW1lOiBzdHJpbmc7XG59IHtcbiAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKTtcblxuICBpZiAoZXJyb3IgfHwgaXNLZXkobmFtZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3IsXG4gICAgICBuYW1lLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcblxuICB3aGlsZSAobmFtZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgZmllbGROYW1lID0gbmFtZXMuam9pbignLicpO1xuICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgY29uc3QgZm91bmRFcnJvciA9IGdldChlcnJvcnMsIGZpZWxkTmFtZSk7XG5cbiAgICBpZiAoZmllbGQgJiYgIUFycmF5LmlzQXJyYXkoZmllbGQpICYmIG5hbWUgIT09IGZpZWxkTmFtZSkge1xuICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgIH1cblxuICAgIGlmIChmb3VuZEVycm9yICYmIGZvdW5kRXJyb3IudHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZmllbGROYW1lLFxuICAgICAgICBlcnJvcjogZm91bmRFcnJvcixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmFtZXMucG9wKCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBWYWxpZGF0aW9uTW9kZUZsYWdzIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCAoXG4gIGlzQmx1ckV2ZW50OiBib29sZWFuLFxuICBpc1RvdWNoZWQ6IGJvb2xlYW4sXG4gIGlzU3VibWl0dGVkOiBib29sZWFuLFxuICByZVZhbGlkYXRlTW9kZToge1xuICAgIGlzT25CbHVyOiBib29sZWFuO1xuICAgIGlzT25DaGFuZ2U6IGJvb2xlYW47XG4gIH0sXG4gIG1vZGU6IFBhcnRpYWw8VmFsaWRhdGlvbk1vZGVGbGFncz4sXG4pID0+IHtcbiAgaWYgKG1vZGUuaXNPbkFsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICghaXNTdWJtaXR0ZWQgJiYgbW9kZS5pc09uVG91Y2gpIHtcbiAgICByZXR1cm4gIShpc1RvdWNoZWQgfHwgaXNCbHVyRXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzU3VibWl0dGVkID8gcmVWYWxpZGF0ZU1vZGUuaXNPbkJsdXIgOiBtb2RlLmlzT25CbHVyKSB7XG4gICAgcmV0dXJuICFpc0JsdXJFdmVudDtcbiAgfSBlbHNlIGlmIChpc1N1Ym1pdHRlZCA/IHJlVmFsaWRhdGVNb2RlLmlzT25DaGFuZ2UgOiBtb2RlLmlzT25DaGFuZ2UpIHtcbiAgICByZXR1cm4gaXNCbHVyRXZlbnQ7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiaW1wb3J0IGNvbXBhY3QgZnJvbSAnLi4vdXRpbHMvY29tcGFjdCc7XG5pbXBvcnQgZ2V0IGZyb20gJy4uL3V0aWxzL2dldCc7XG5pbXBvcnQgdW5zZXQgZnJvbSAnLi4vdXRpbHMvdW5zZXQnO1xuXG5leHBvcnQgZGVmYXVsdCA8VD4ocmVmOiBULCBuYW1lOiBzdHJpbmcpID0+XG4gICFjb21wYWN0KGdldChyZWYsIG5hbWUpKS5sZW5ndGggJiYgdW5zZXQocmVmLCBuYW1lKTtcbiIsImltcG9ydCB7IEVWRU5UUywgVkFMSURBVElPTl9NT0RFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIEJhdGNoRmllbGRBcnJheVVwZGF0ZSxcbiAgQ2hhbmdlSGFuZGxlcixcbiAgQ29udHJvbCxcbiAgRGVlcFBhcnRpYWwsXG4gIERlbGF5Q2FsbGJhY2ssXG4gIEV2ZW50VHlwZSxcbiAgRmllbGQsXG4gIEZpZWxkRXJyb3IsXG4gIEZpZWxkRXJyb3JzLFxuICBGaWVsZE5hbWVzTWFya2VkQm9vbGVhbixcbiAgRmllbGRQYXRoLFxuICBGaWVsZFJlZnMsXG4gIEZpZWxkVmFsdWVzLFxuICBGb3JtU3RhdGUsXG4gIEdldElzRGlydHksXG4gIEludGVybmFsRmllbGROYW1lLFxuICBOYW1lcyxcbiAgUGF0aCxcbiAgUGF0aFZhbHVlLFxuICBSZWFkRm9ybVN0YXRlLFxuICBSZWYsXG4gIFNldEZpZWxkVmFsdWUsXG4gIFNldFZhbHVlQ29uZmlnLFxuICBTdWJqZWN0cyxcbiAgVXNlRm9ybUNsZWFyRXJyb3JzLFxuICBVc2VGb3JtR2V0RmllbGRTdGF0ZSxcbiAgVXNlRm9ybUdldFZhbHVlcyxcbiAgVXNlRm9ybUhhbmRsZVN1Ym1pdCxcbiAgVXNlRm9ybVByb3BzLFxuICBVc2VGb3JtUmVnaXN0ZXIsXG4gIFVzZUZvcm1SZXNldCxcbiAgVXNlRm9ybVJlc2V0RmllbGQsXG4gIFVzZUZvcm1SZXR1cm4sXG4gIFVzZUZvcm1TZXRFcnJvcixcbiAgVXNlRm9ybVNldEZvY3VzLFxuICBVc2VGb3JtU2V0VmFsdWUsXG4gIFVzZUZvcm1UcmlnZ2VyLFxuICBVc2VGb3JtVW5yZWdpc3RlcixcbiAgVXNlRm9ybVdhdGNoLFxuICBXYXRjaEludGVybmFsLFxuICBXYXRjaE9ic2VydmVyLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgY2xvbmVPYmplY3QgZnJvbSAnLi4vdXRpbHMvY2xvbmVPYmplY3QnO1xuaW1wb3J0IGNvbXBhY3QgZnJvbSAnLi4vdXRpbHMvY29tcGFjdCc7XG5pbXBvcnQgY29udmVydFRvQXJyYXlQYXlsb2FkIGZyb20gJy4uL3V0aWxzL2NvbnZlcnRUb0FycmF5UGF5bG9hZCc7XG5pbXBvcnQgY3JlYXRlU3ViamVjdCBmcm9tICcuLi91dGlscy9jcmVhdGVTdWJqZWN0JztcbmltcG9ydCBkZWVwRXF1YWwgZnJvbSAnLi4vdXRpbHMvZGVlcEVxdWFsJztcbmltcG9ydCBnZXQgZnJvbSAnLi4vdXRpbHMvZ2V0JztcbmltcG9ydCBpc0Jvb2xlYW4gZnJvbSAnLi4vdXRpbHMvaXNCb29sZWFuJztcbmltcG9ydCBpc0NoZWNrQm94SW5wdXQgZnJvbSAnLi4vdXRpbHMvaXNDaGVja0JveElucHV0JztcbmltcG9ydCBpc0RhdGVPYmplY3QgZnJvbSAnLi4vdXRpbHMvaXNEYXRlT2JqZWN0JztcbmltcG9ydCBpc0VtcHR5T2JqZWN0IGZyb20gJy4uL3V0aWxzL2lzRW1wdHlPYmplY3QnO1xuaW1wb3J0IGlzRmlsZUlucHV0IGZyb20gJy4uL3V0aWxzL2lzRmlsZUlucHV0JztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4uL3V0aWxzL2lzRnVuY3Rpb24nO1xuaW1wb3J0IGlzSFRNTEVsZW1lbnQgZnJvbSAnLi4vdXRpbHMvaXNIVE1MRWxlbWVudCc7XG5pbXBvcnQgaXNNdWx0aXBsZVNlbGVjdCBmcm9tICcuLi91dGlscy9pc011bHRpcGxlU2VsZWN0JztcbmltcG9ydCBpc051bGxPclVuZGVmaW5lZCBmcm9tICcuLi91dGlscy9pc051bGxPclVuZGVmaW5lZCc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi4vdXRpbHMvaXNPYmplY3QnO1xuaW1wb3J0IGlzUHJpbWl0aXZlIGZyb20gJy4uL3V0aWxzL2lzUHJpbWl0aXZlJztcbmltcG9ydCBpc1JhZGlvT3JDaGVja2JveCBmcm9tICcuLi91dGlscy9pc1JhZGlvT3JDaGVja2JveCc7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSAnLi4vdXRpbHMvaXNTdHJpbmcnO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gJy4uL3V0aWxzL2lzVW5kZWZpbmVkJztcbmltcG9ydCBpc1dlYiBmcm9tICcuLi91dGlscy9pc1dlYic7XG5pbXBvcnQgbGl2ZSBmcm9tICcuLi91dGlscy9saXZlJztcbmltcG9ydCBzZXQgZnJvbSAnLi4vdXRpbHMvc2V0JztcbmltcG9ydCB1bnNldCBmcm9tICcuLi91dGlscy91bnNldCc7XG5cbmltcG9ydCBnZW5lcmF0ZVdhdGNoT3V0cHV0IGZyb20gJy4vZ2VuZXJhdGVXYXRjaE91dHB1dCc7XG5pbXBvcnQgZ2V0RGlydHlGaWVsZHMgZnJvbSAnLi9nZXREaXJ0eUZpZWxkcyc7XG5pbXBvcnQgZ2V0RXZlbnRWYWx1ZSBmcm9tICcuL2dldEV2ZW50VmFsdWUnO1xuaW1wb3J0IGdldEZpZWxkVmFsdWUgZnJvbSAnLi9nZXRGaWVsZFZhbHVlJztcbmltcG9ydCBnZXRGaWVsZFZhbHVlQXMgZnJvbSAnLi9nZXRGaWVsZFZhbHVlQXMnO1xuaW1wb3J0IGdldFJlc29sdmVyT3B0aW9ucyBmcm9tICcuL2dldFJlc29sdmVyT3B0aW9ucyc7XG5pbXBvcnQgZ2V0UnVsZVZhbHVlIGZyb20gJy4vZ2V0UnVsZVZhbHVlJztcbmltcG9ydCBnZXRWYWxpZGF0aW9uTW9kZXMgZnJvbSAnLi9nZXRWYWxpZGF0aW9uTW9kZXMnO1xuaW1wb3J0IGhhc1ZhbGlkYXRpb24gZnJvbSAnLi9oYXNWYWxpZGF0aW9uJztcbmltcG9ydCBpc05hbWVJbkZpZWxkQXJyYXkgZnJvbSAnLi9pc05hbWVJbkZpZWxkQXJyYXknO1xuaW1wb3J0IGlzV2F0Y2hlZCBmcm9tICcuL2lzV2F0Y2hlZCc7XG5pbXBvcnQgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uIGZyb20gJy4vaXRlcmF0ZUZpZWxkc0J5QWN0aW9uJztcbmltcG9ydCBzY2hlbWFFcnJvckxvb2t1cCBmcm9tICcuL3NjaGVtYUVycm9yTG9va3VwJztcbmltcG9ydCBza2lwVmFsaWRhdGlvbiBmcm9tICcuL3NraXBWYWxpZGF0aW9uJztcbmltcG9ydCB1bnNldEVtcHR5QXJyYXkgZnJvbSAnLi91bnNldEVtcHR5QXJyYXknO1xuaW1wb3J0IHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IgZnJvbSAnLi91cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yJztcbmltcG9ydCB2YWxpZGF0ZUZpZWxkIGZyb20gJy4vdmFsaWRhdGVGaWVsZCc7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBtb2RlOiBWQUxJREFUSU9OX01PREUub25TdWJtaXQsXG4gIHJlVmFsaWRhdGVNb2RlOiBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsXG4gIHNob3VsZEZvY3VzRXJyb3I6IHRydWUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9ybUNvbnRyb2w8XG4gIFRGaWVsZFZhbHVlcyBleHRlbmRzIEZpZWxkVmFsdWVzID0gRmllbGRWYWx1ZXMsXG4gIFRDb250ZXh0ID0gYW55LFxuPihcbiAgcHJvcHM6IFVzZUZvcm1Qcm9wczxURmllbGRWYWx1ZXMsIFRDb250ZXh0PiA9IHt9LFxuKTogT21pdDxVc2VGb3JtUmV0dXJuPFRGaWVsZFZhbHVlcywgVENvbnRleHQ+LCAnZm9ybVN0YXRlJz4ge1xuICBsZXQgX29wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ucHJvcHMsXG4gIH07XG4gIGxldCBfZm9ybVN0YXRlOiBGb3JtU3RhdGU8VEZpZWxkVmFsdWVzPiA9IHtcbiAgICBzdWJtaXRDb3VudDogMCxcbiAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICBpc0xvYWRpbmc6IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcyksXG4gICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICBpc1N1Ym1pdHRlZDogZmFsc2UsXG4gICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgIHRvdWNoZWRGaWVsZHM6IHt9LFxuICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICB2YWxpZGF0aW5nRmllbGRzOiB7fSxcbiAgICBlcnJvcnM6IF9vcHRpb25zLmVycm9ycyB8fCB7fSxcbiAgICBkaXNhYmxlZDogX29wdGlvbnMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gIH07XG4gIGxldCBfZmllbGRzOiBGaWVsZFJlZnMgPSB7fTtcbiAgbGV0IF9kZWZhdWx0VmFsdWVzID1cbiAgICBpc09iamVjdChfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSB8fCBpc09iamVjdChfb3B0aW9ucy52YWx1ZXMpXG4gICAgICA/IGNsb25lT2JqZWN0KF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMgfHwgX29wdGlvbnMudmFsdWVzKSB8fCB7fVxuICAgICAgOiB7fTtcbiAgbGV0IF9mb3JtVmFsdWVzID0gX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlclxuICAgID8ge31cbiAgICA6IGNsb25lT2JqZWN0KF9kZWZhdWx0VmFsdWVzKTtcbiAgbGV0IF9zdGF0ZSA9IHtcbiAgICBhY3Rpb246IGZhbHNlLFxuICAgIG1vdW50OiBmYWxzZSxcbiAgICB3YXRjaDogZmFsc2UsXG4gIH07XG4gIGxldCBfbmFtZXM6IE5hbWVzID0ge1xuICAgIG1vdW50OiBuZXcgU2V0KCksXG4gICAgdW5Nb3VudDogbmV3IFNldCgpLFxuICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgd2F0Y2g6IG5ldyBTZXQoKSxcbiAgfTtcbiAgbGV0IGRlbGF5RXJyb3JDYWxsYmFjazogRGVsYXlDYWxsYmFjayB8IG51bGw7XG4gIGxldCB0aW1lciA9IDA7XG4gIGNvbnN0IF9wcm94eUZvcm1TdGF0ZTogUmVhZEZvcm1TdGF0ZSA9IHtcbiAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICBkaXJ0eUZpZWxkczogZmFsc2UsXG4gICAgdmFsaWRhdGluZ0ZpZWxkczogZmFsc2UsXG4gICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICBlcnJvcnM6IGZhbHNlLFxuICB9O1xuICBjb25zdCBfc3ViamVjdHM6IFN1YmplY3RzPFRGaWVsZFZhbHVlcz4gPSB7XG4gICAgdmFsdWVzOiBjcmVhdGVTdWJqZWN0KCksXG4gICAgYXJyYXk6IGNyZWF0ZVN1YmplY3QoKSxcbiAgICBzdGF0ZTogY3JlYXRlU3ViamVjdCgpLFxuICB9O1xuICBjb25zdCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5tb2RlKTtcbiAgY29uc3QgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSk7XG4gIGNvbnN0IHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzID1cbiAgICBfb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGw7XG5cbiAgY29uc3QgZGVib3VuY2UgPVxuICAgIDxUIGV4dGVuZHMgRnVuY3Rpb24+KGNhbGxiYWNrOiBUKSA9PlxuICAgICh3YWl0OiBudW1iZXIpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHdhaXQpO1xuICAgIH07XG5cbiAgY29uc3QgX3VwZGF0ZVZhbGlkID0gYXN5bmMgKHNob3VsZFVwZGF0ZVZhbGlkPzogYm9vbGVhbikgPT4ge1xuICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCBzaG91bGRVcGRhdGVWYWxpZCkge1xuICAgICAgY29uc3QgaXNWYWxpZCA9IF9vcHRpb25zLnJlc29sdmVyXG4gICAgICAgID8gaXNFbXB0eU9iamVjdCgoYXdhaXQgX2V4ZWN1dGVTY2hlbWEoKSkuZXJyb3JzKVxuICAgICAgICA6IGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzLCB0cnVlKTtcblxuICAgICAgaWYgKGlzVmFsaWQgIT09IF9mb3JtU3RhdGUuaXNWYWxpZCkge1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IF91cGRhdGVJc1ZhbGlkYXRpbmcgPSAobmFtZXM/OiBzdHJpbmdbXSwgaXNWYWxpZGF0aW5nPzogYm9vbGVhbikgPT4ge1xuICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZGF0aW5nIHx8IF9wcm94eUZvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzKSB7XG4gICAgICAobmFtZXMgfHwgQXJyYXkuZnJvbShfbmFtZXMubW91bnQpKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgaXNWYWxpZGF0aW5nXG4gICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUsIGlzVmFsaWRhdGluZylcbiAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczogX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6ICFpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyksXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgX3VwZGF0ZUZpZWxkQXJyYXk6IEJhdGNoRmllbGRBcnJheVVwZGF0ZSA9IChcbiAgICBuYW1lLFxuICAgIHZhbHVlcyA9IFtdLFxuICAgIG1ldGhvZCxcbiAgICBhcmdzLFxuICAgIHNob3VsZFNldFZhbHVlcyA9IHRydWUsXG4gICAgc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgPSB0cnVlLFxuICApID0+IHtcbiAgICBpZiAoYXJncyAmJiBtZXRob2QpIHtcbiAgICAgIF9zdGF0ZS5hY3Rpb24gPSB0cnVlO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmIEFycmF5LmlzQXJyYXkoZ2V0KF9maWVsZHMsIG5hbWUpKSkge1xuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IG1ldGhvZChnZXQoX2ZpZWxkcywgbmFtZSksIGFyZ3MuYXJnQSwgYXJncy5hcmdCKTtcbiAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZmllbGRzLCBuYW1lLCBmaWVsZFZhbHVlcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IG1ldGhvZChcbiAgICAgICAgICBnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICAgIGFyZ3MuYXJnQSxcbiAgICAgICAgICBhcmdzLmFyZ0IsXG4gICAgICAgICk7XG4gICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9ycyk7XG4gICAgICAgIHVuc2V0RW1wdHlBcnJheShfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMgJiZcbiAgICAgICAgc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICBjb25zdCB0b3VjaGVkRmllbGRzID0gbWV0aG9kKFxuICAgICAgICAgIGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLFxuICAgICAgICAgIGFyZ3MuYXJnQSxcbiAgICAgICAgICBhcmdzLmFyZ0IsXG4gICAgICAgICk7XG4gICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lLCB0b3VjaGVkRmllbGRzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcykge1xuICAgICAgICBfZm9ybVN0YXRlLmRpcnR5RmllbGRzID0gZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKTtcbiAgICAgIH1cblxuICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBpc0RpcnR5OiBfZ2V0RGlydHkobmFtZSwgdmFsdWVzKSxcbiAgICAgICAgZGlydHlGaWVsZHM6IF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsXG4gICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgIGlzVmFsaWQ6IF9mb3JtU3RhdGUuaXNWYWxpZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHZhbHVlcyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZUVycm9ycyA9IChuYW1lOiBJbnRlcm5hbEZpZWxkTmFtZSwgZXJyb3I6IEZpZWxkRXJyb3IpID0+IHtcbiAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKTtcbiAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IF9zZXRFcnJvcnMgPSAoZXJyb3JzOiBGaWVsZEVycm9yczxURmllbGRWYWx1ZXM+KSA9PiB7XG4gICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZVZhbGlkQW5kVmFsdWUgPSAoXG4gICAgbmFtZTogSW50ZXJuYWxGaWVsZE5hbWUsXG4gICAgc2hvdWxkU2tpcFNldFZhbHVlQXM6IGJvb2xlYW4sXG4gICAgdmFsdWU/OiB1bmtub3duLFxuICAgIHJlZj86IFJlZixcbiAgKSA9PiB7XG4gICAgY29uc3QgZmllbGQ6IEZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuXG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBnZXQoXG4gICAgICAgIF9mb3JtVmFsdWVzLFxuICAgICAgICBuYW1lLFxuICAgICAgICBpc1VuZGVmaW5lZCh2YWx1ZSkgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpIDogdmFsdWUsXG4gICAgICApO1xuXG4gICAgICBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpIHx8XG4gICAgICAocmVmICYmIChyZWYgYXMgSFRNTElucHV0RWxlbWVudCkuZGVmYXVsdENoZWNrZWQpIHx8XG4gICAgICBzaG91bGRTa2lwU2V0VmFsdWVBc1xuICAgICAgICA/IHNldChcbiAgICAgICAgICAgIF9mb3JtVmFsdWVzLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHNob3VsZFNraXBTZXRWYWx1ZUFzID8gZGVmYXVsdFZhbHVlIDogZ2V0RmllbGRWYWx1ZShmaWVsZC5fZiksXG4gICAgICAgICAgKVxuICAgICAgICA6IHNldEZpZWxkVmFsdWUobmFtZSwgZGVmYXVsdFZhbHVlKTtcblxuICAgICAgX3N0YXRlLm1vdW50ICYmIF91cGRhdGVWYWxpZCgpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGRhdGVUb3VjaEFuZERpcnR5ID0gKFxuICAgIG5hbWU6IEludGVybmFsRmllbGROYW1lLFxuICAgIGZpZWxkVmFsdWU6IHVua25vd24sXG4gICAgaXNCbHVyRXZlbnQ/OiBib29sZWFuLFxuICAgIHNob3VsZERpcnR5PzogYm9vbGVhbixcbiAgICBzaG91bGRSZW5kZXI/OiBib29sZWFuLFxuICApOiBQYXJ0aWFsPFxuICAgIFBpY2s8Rm9ybVN0YXRlPFRGaWVsZFZhbHVlcz4sICdkaXJ0eUZpZWxkcycgfCAnaXNEaXJ0eScgfCAndG91Y2hlZEZpZWxkcyc+XG4gID4gPT4ge1xuICAgIGxldCBzaG91bGRVcGRhdGVGaWVsZCA9IGZhbHNlO1xuICAgIGxldCBpc1ByZXZpb3VzRGlydHkgPSBmYWxzZTtcbiAgICBjb25zdCBvdXRwdXQ6IFBhcnRpYWw8Rm9ybVN0YXRlPFRGaWVsZFZhbHVlcz4+ICYgeyBuYW1lOiBzdHJpbmcgfSA9IHtcbiAgICAgIG5hbWUsXG4gICAgfTtcbiAgICBjb25zdCBkaXNhYmxlZEZpZWxkID0gISEoXG4gICAgICBnZXQoX2ZpZWxkcywgbmFtZSkgJiYgZ2V0KF9maWVsZHMsIG5hbWUpLl9mLmRpc2FibGVkXG4gICAgKTtcblxuICAgIGlmICghaXNCbHVyRXZlbnQgfHwgc2hvdWxkRGlydHkpIHtcbiAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSBfZm9ybVN0YXRlLmlzRGlydHk7XG4gICAgICAgIF9mb3JtU3RhdGUuaXNEaXJ0eSA9IG91dHB1dC5pc0RpcnR5ID0gX2dldERpcnR5KCk7XG4gICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID0gaXNQcmV2aW91c0RpcnR5ICE9PSBvdXRwdXQuaXNEaXJ0eTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNDdXJyZW50RmllbGRQcmlzdGluZSA9XG4gICAgICAgIGRpc2FibGVkRmllbGQgfHwgZGVlcEVxdWFsKGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSksIGZpZWxkVmFsdWUpO1xuXG4gICAgICBpc1ByZXZpb3VzRGlydHkgPSAhISghZGlzYWJsZWRGaWVsZCAmJiBnZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSkpO1xuICAgICAgaXNDdXJyZW50RmllbGRQcmlzdGluZSB8fCBkaXNhYmxlZEZpZWxkXG4gICAgICAgID8gdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSlcbiAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSwgdHJ1ZSk7XG4gICAgICBvdXRwdXQuZGlydHlGaWVsZHMgPSBfZm9ybVN0YXRlLmRpcnR5RmllbGRzO1xuICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPVxuICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCB8fFxuICAgICAgICAoX3Byb3h5Rm9ybVN0YXRlLmRpcnR5RmllbGRzICYmXG4gICAgICAgICAgaXNQcmV2aW91c0RpcnR5ICE9PSAhaXNDdXJyZW50RmllbGRQcmlzdGluZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQmx1ckV2ZW50KSB7XG4gICAgICBjb25zdCBpc1ByZXZpb3VzRmllbGRUb3VjaGVkID0gZ2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSk7XG5cbiAgICAgIGlmICghaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCkge1xuICAgICAgICBzZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lLCBpc0JsdXJFdmVudCk7XG4gICAgICAgIG91dHB1dC50b3VjaGVkRmllbGRzID0gX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzO1xuICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9XG4gICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgfHxcbiAgICAgICAgICAoX3Byb3h5Rm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMgJiZcbiAgICAgICAgICAgIGlzUHJldmlvdXNGaWVsZFRvdWNoZWQgIT09IGlzQmx1ckV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzaG91bGRVcGRhdGVGaWVsZCAmJiBzaG91bGRSZW5kZXIgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQob3V0cHV0KTtcblxuICAgIHJldHVybiBzaG91bGRVcGRhdGVGaWVsZCA/IG91dHB1dCA6IHt9O1xuICB9O1xuXG4gIGNvbnN0IHNob3VsZFJlbmRlckJ5RXJyb3IgPSAoXG4gICAgbmFtZTogSW50ZXJuYWxGaWVsZE5hbWUsXG4gICAgaXNWYWxpZD86IGJvb2xlYW4sXG4gICAgZXJyb3I/OiBGaWVsZEVycm9yLFxuICAgIGZpZWxkU3RhdGU/OiB7XG4gICAgICBkaXJ0eT86IEZpZWxkTmFtZXNNYXJrZWRCb29sZWFuPFRGaWVsZFZhbHVlcz47XG4gICAgICBpc0RpcnR5PzogYm9vbGVhbjtcbiAgICAgIHRvdWNoZWQ/OiBGaWVsZE5hbWVzTWFya2VkQm9vbGVhbjxURmllbGRWYWx1ZXM+O1xuICAgIH0sXG4gICkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzRmllbGRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlVmFsaWQgPVxuICAgICAgX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiZcbiAgICAgIGlzQm9vbGVhbihpc1ZhbGlkKSAmJlxuICAgICAgX2Zvcm1TdGF0ZS5pc1ZhbGlkICE9PSBpc1ZhbGlkO1xuXG4gICAgaWYgKHByb3BzLmRlbGF5RXJyb3IgJiYgZXJyb3IpIHtcbiAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayA9IGRlYm91bmNlKCgpID0+IHVwZGF0ZUVycm9ycyhuYW1lLCBlcnJvcikpO1xuICAgICAgZGVsYXlFcnJvckNhbGxiYWNrKHByb3BzLmRlbGF5RXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGVycm9yXG4gICAgICAgID8gc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcilcbiAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgKGVycm9yID8gIWRlZXBFcXVhbChwcmV2aW91c0ZpZWxkRXJyb3IsIGVycm9yKSA6IHByZXZpb3VzRmllbGRFcnJvcikgfHxcbiAgICAgICFpc0VtcHR5T2JqZWN0KGZpZWxkU3RhdGUpIHx8XG4gICAgICBzaG91bGRVcGRhdGVWYWxpZFxuICAgICkge1xuICAgICAgY29uc3QgdXBkYXRlZEZvcm1TdGF0ZSA9IHtcbiAgICAgICAgLi4uZmllbGRTdGF0ZSxcbiAgICAgICAgLi4uKHNob3VsZFVwZGF0ZVZhbGlkICYmIGlzQm9vbGVhbihpc1ZhbGlkKSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICBuYW1lLFxuICAgICAgfTtcblxuICAgICAgX2Zvcm1TdGF0ZSA9IHtcbiAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcbiAgICAgIH07XG5cbiAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHVwZGF0ZWRGb3JtU3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBfZXhlY3V0ZVNjaGVtYSA9IGFzeW5jIChuYW1lPzogSW50ZXJuYWxGaWVsZE5hbWVbXSkgPT4ge1xuICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcobmFtZSwgdHJ1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX29wdGlvbnMucmVzb2x2ZXIhKFxuICAgICAgX2Zvcm1WYWx1ZXMgYXMgVEZpZWxkVmFsdWVzLFxuICAgICAgX29wdGlvbnMuY29udGV4dCxcbiAgICAgIGdldFJlc29sdmVyT3B0aW9ucyhcbiAgICAgICAgbmFtZSB8fCBfbmFtZXMubW91bnQsXG4gICAgICAgIF9maWVsZHMsXG4gICAgICAgIF9vcHRpb25zLmNyaXRlcmlhTW9kZSxcbiAgICAgICAgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbixcbiAgICAgICksXG4gICAgKTtcbiAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKG5hbWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgY29uc3QgZXhlY3V0ZVNjaGVtYUFuZFVwZGF0ZVN0YXRlID0gYXN5bmMgKG5hbWVzPzogSW50ZXJuYWxGaWVsZE5hbWVbXSkgPT4ge1xuICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBhd2FpdCBfZXhlY3V0ZVNjaGVtYShuYW1lcyk7XG5cbiAgICBpZiAobmFtZXMpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xuICAgICAgICBlcnJvclxuICAgICAgICAgID8gc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcilcbiAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycztcbiAgfTtcblxuICBjb25zdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24gPSBhc3luYyAoXG4gICAgZmllbGRzOiBGaWVsZFJlZnMsXG4gICAgc2hvdWxkT25seUNoZWNrVmFsaWQ/OiBib29sZWFuLFxuICAgIGNvbnRleHQ6IHtcbiAgICAgIHZhbGlkOiBib29sZWFuO1xuICAgIH0gPSB7XG4gICAgICB2YWxpZDogdHJ1ZSxcbiAgICB9LFxuICApID0+IHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcblxuICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHsgX2YsIC4uLmZpZWxkVmFsdWUgfSA9IGZpZWxkO1xuXG4gICAgICAgIGlmIChfZikge1xuICAgICAgICAgIGNvbnN0IGlzRmllbGRBcnJheVJvb3QgPSBfbmFtZXMuYXJyYXkuaGFzKF9mLm5hbWUpO1xuICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW25hbWVdLCB0cnVlKTtcbiAgICAgICAgICBjb25zdCBmaWVsZEVycm9yID0gYXdhaXQgdmFsaWRhdGVGaWVsZChcbiAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgX2Zvcm1WYWx1ZXMsXG4gICAgICAgICAgICBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycyxcbiAgICAgICAgICAgIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24gJiYgIXNob3VsZE9ubHlDaGVja1ZhbGlkLFxuICAgICAgICAgICAgaXNGaWVsZEFycmF5Um9vdCxcbiAgICAgICAgICApO1xuICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW25hbWVdKTtcblxuICAgICAgICAgIGlmIChmaWVsZEVycm9yW19mLm5hbWVdKSB7XG4gICAgICAgICAgICBjb250ZXh0LnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2hvdWxkT25seUNoZWNrVmFsaWQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgIXNob3VsZE9ubHlDaGVja1ZhbGlkICYmXG4gICAgICAgICAgICAoZ2V0KGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgID8gaXNGaWVsZEFycmF5Um9vdFxuICAgICAgICAgICAgICAgID8gdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIF9mLm5hbWUsXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUsIGZpZWxkRXJyb3JbX2YubmFtZV0pXG4gICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkVmFsdWUgJiZcbiAgICAgICAgICAoYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKFxuICAgICAgICAgICAgZmllbGRWYWx1ZSxcbiAgICAgICAgICAgIHNob3VsZE9ubHlDaGVja1ZhbGlkLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dC52YWxpZDtcbiAgfTtcblxuICBjb25zdCBfcmVtb3ZlVW5tb3VudGVkID0gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMudW5Nb3VudCkge1xuICAgICAgY29uc3QgZmllbGQ6IEZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuXG4gICAgICBmaWVsZCAmJlxuICAgICAgICAoZmllbGQuX2YucmVmc1xuICAgICAgICAgID8gZmllbGQuX2YucmVmcy5ldmVyeSgocmVmKSA9PiAhbGl2ZShyZWYpKVxuICAgICAgICAgIDogIWxpdmUoZmllbGQuX2YucmVmKSkgJiZcbiAgICAgICAgdW5yZWdpc3RlcihuYW1lIGFzIEZpZWxkUGF0aDxURmllbGRWYWx1ZXM+KTtcbiAgICB9XG5cbiAgICBfbmFtZXMudW5Nb3VudCA9IG5ldyBTZXQoKTtcbiAgfTtcblxuICBjb25zdCBfZ2V0RGlydHk6IEdldElzRGlydHkgPSAobmFtZSwgZGF0YSkgPT4gKFxuICAgIG5hbWUgJiYgZGF0YSAmJiBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGRhdGEpLFxuICAgICFkZWVwRXF1YWwoZ2V0VmFsdWVzKCksIF9kZWZhdWx0VmFsdWVzKVxuICApO1xuXG4gIGNvbnN0IF9nZXRXYXRjaDogV2F0Y2hJbnRlcm5hbDxURmllbGRWYWx1ZXM+ID0gKFxuICAgIG5hbWVzLFxuICAgIGRlZmF1bHRWYWx1ZSxcbiAgICBpc0dsb2JhbCxcbiAgKSA9PlxuICAgIGdlbmVyYXRlV2F0Y2hPdXRwdXQoXG4gICAgICBuYW1lcyxcbiAgICAgIF9uYW1lcyxcbiAgICAgIHtcbiAgICAgICAgLi4uKF9zdGF0ZS5tb3VudFxuICAgICAgICAgID8gX2Zvcm1WYWx1ZXNcbiAgICAgICAgICA6IGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICA/IF9kZWZhdWx0VmFsdWVzXG4gICAgICAgICAgOiBpc1N0cmluZyhuYW1lcylcbiAgICAgICAgICA/IHsgW25hbWVzXTogZGVmYXVsdFZhbHVlIH1cbiAgICAgICAgICA6IGRlZmF1bHRWYWx1ZSksXG4gICAgICB9LFxuICAgICAgaXNHbG9iYWwsXG4gICAgICBkZWZhdWx0VmFsdWUsXG4gICAgKTtcblxuICBjb25zdCBfZ2V0RmllbGRBcnJheSA9IDxURmllbGRBcnJheVZhbHVlcz4oXG4gICAgbmFtZTogSW50ZXJuYWxGaWVsZE5hbWUsXG4gICk6IFBhcnRpYWw8VEZpZWxkQXJyYXlWYWx1ZXM+W10gPT5cbiAgICBjb21wYWN0KFxuICAgICAgZ2V0KFxuICAgICAgICBfc3RhdGUubW91bnQgPyBfZm9ybVZhbHVlcyA6IF9kZWZhdWx0VmFsdWVzLFxuICAgICAgICBuYW1lLFxuICAgICAgICBwcm9wcy5zaG91bGRVbnJlZ2lzdGVyID8gZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lLCBbXSkgOiBbXSxcbiAgICAgICksXG4gICAgKTtcblxuICBjb25zdCBzZXRGaWVsZFZhbHVlID0gKFxuICAgIG5hbWU6IEludGVybmFsRmllbGROYW1lLFxuICAgIHZhbHVlOiBTZXRGaWVsZFZhbHVlPFRGaWVsZFZhbHVlcz4sXG4gICAgb3B0aW9uczogU2V0VmFsdWVDb25maWcgPSB7fSxcbiAgKSA9PiB7XG4gICAgY29uc3QgZmllbGQ6IEZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgIGxldCBmaWVsZFZhbHVlOiB1bmtub3duID0gdmFsdWU7XG5cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gZmllbGQuX2Y7XG5cbiAgICAgIGlmIChmaWVsZFJlZmVyZW5jZSkge1xuICAgICAgICAhZmllbGRSZWZlcmVuY2UuZGlzYWJsZWQgJiZcbiAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldEZpZWxkVmFsdWVBcyh2YWx1ZSwgZmllbGRSZWZlcmVuY2UpKTtcblxuICAgICAgICBmaWVsZFZhbHVlID1cbiAgICAgICAgICBpc0hUTUxFbGVtZW50KGZpZWxkUmVmZXJlbmNlLnJlZikgJiYgaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpXG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc011bHRpcGxlU2VsZWN0KGZpZWxkUmVmZXJlbmNlLnJlZikpIHtcbiAgICAgICAgICBbLi4uZmllbGRSZWZlcmVuY2UucmVmLm9wdGlvbnNdLmZvckVhY2goXG4gICAgICAgICAgICAob3B0aW9uUmVmKSA9PlxuICAgICAgICAgICAgICAob3B0aW9uUmVmLnNlbGVjdGVkID0gKFxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgYXMgSW50ZXJuYWxGaWVsZE5hbWVbXVxuICAgICAgICAgICAgICApLmluY2x1ZGVzKG9wdGlvblJlZi52YWx1ZSkpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGRSZWZlcmVuY2UucmVmcykge1xuICAgICAgICAgIGlmIChpc0NoZWNrQm94SW5wdXQoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmcy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgID8gZmllbGRSZWZlcmVuY2UucmVmcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgKGNoZWNrYm94UmVmKSA9PlxuICAgICAgICAgICAgICAgICAgICAoIWNoZWNrYm94UmVmLmRlZmF1bHRDaGVja2VkIHx8ICFjaGVja2JveFJlZi5kaXNhYmxlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGNoZWNrYm94UmVmLmNoZWNrZWQgPSBBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgPyAhIShmaWVsZFZhbHVlIGFzIFtdKS5maW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoZGF0YTogc3RyaW5nKSA9PiBkYXRhID09PSBjaGVja2JveFJlZi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkVmFsdWUgPT09IGNoZWNrYm94UmVmLnZhbHVlKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogZmllbGRSZWZlcmVuY2UucmVmc1swXSAmJlxuICAgICAgICAgICAgICAgIChmaWVsZFJlZmVyZW5jZS5yZWZzWzBdLmNoZWNrZWQgPSAhIWZpZWxkVmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goXG4gICAgICAgICAgICAgIChyYWRpb1JlZjogSFRNTElucHV0RWxlbWVudCkgPT5cbiAgICAgICAgICAgICAgICAocmFkaW9SZWYuY2hlY2tlZCA9IHJhZGlvUmVmLnZhbHVlID09PSBmaWVsZFZhbHVlKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzRmlsZUlucHV0KGZpZWxkUmVmZXJlbmNlLnJlZikpIHtcbiAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWYudmFsdWUgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWYudmFsdWUgPSBmaWVsZFZhbHVlO1xuXG4gICAgICAgICAgaWYgKCFmaWVsZFJlZmVyZW5jZS5yZWYudHlwZSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAob3B0aW9ucy5zaG91bGREaXJ0eSB8fCBvcHRpb25zLnNob3VsZFRvdWNoKSAmJlxuICAgICAgdXBkYXRlVG91Y2hBbmREaXJ0eShcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZmllbGRWYWx1ZSxcbiAgICAgICAgb3B0aW9ucy5zaG91bGRUb3VjaCxcbiAgICAgICAgb3B0aW9ucy5zaG91bGREaXJ0eSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICk7XG5cbiAgICBvcHRpb25zLnNob3VsZFZhbGlkYXRlICYmIHRyaWdnZXIobmFtZSBhcyBQYXRoPFRGaWVsZFZhbHVlcz4pO1xuICB9O1xuXG4gIGNvbnN0IHNldFZhbHVlcyA9IDxcbiAgICBUIGV4dGVuZHMgSW50ZXJuYWxGaWVsZE5hbWUsXG4gICAgSyBleHRlbmRzIFNldEZpZWxkVmFsdWU8VEZpZWxkVmFsdWVzPixcbiAgICBVIGV4dGVuZHMgU2V0VmFsdWVDb25maWcsXG4gID4oXG4gICAgbmFtZTogVCxcbiAgICB2YWx1ZTogSyxcbiAgICBvcHRpb25zOiBVLFxuICApID0+IHtcbiAgICBmb3IgKGNvbnN0IGZpZWxkS2V5IGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBmaWVsZFZhbHVlID0gdmFsdWVbZmllbGRLZXldO1xuICAgICAgY29uc3QgZmllbGROYW1lID0gYCR7bmFtZX0uJHtmaWVsZEtleX1gO1xuICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcblxuICAgICAgKF9uYW1lcy5hcnJheS5oYXMobmFtZSkgfHxcbiAgICAgICAgIWlzUHJpbWl0aXZlKGZpZWxkVmFsdWUpIHx8XG4gICAgICAgIChmaWVsZCAmJiAhZmllbGQuX2YpKSAmJlxuICAgICAgIWlzRGF0ZU9iamVjdChmaWVsZFZhbHVlKVxuICAgICAgICA/IHNldFZhbHVlcyhmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpXG4gICAgICAgIDogc2V0RmllbGRWYWx1ZShmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZXRWYWx1ZTogVXNlRm9ybVNldFZhbHVlPFRGaWVsZFZhbHVlcz4gPSAoXG4gICAgbmFtZSxcbiAgICB2YWx1ZSxcbiAgICBvcHRpb25zID0ge30sXG4gICkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgIGNvbnN0IGlzRmllbGRBcnJheSA9IF9uYW1lcy5hcnJheS5oYXMobmFtZSk7XG4gICAgY29uc3QgY2xvbmVWYWx1ZSA9IGNsb25lT2JqZWN0KHZhbHVlKTtcblxuICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgY2xvbmVWYWx1ZSk7XG5cbiAgICBpZiAoaXNGaWVsZEFycmF5KSB7XG4gICAgICBfc3ViamVjdHMuYXJyYXkubmV4dCh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5IHx8IF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcykgJiZcbiAgICAgICAgb3B0aW9ucy5zaG91bGREaXJ0eVxuICAgICAgKSB7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRpcnR5RmllbGRzOiBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCBjbG9uZVZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkICYmICFmaWVsZC5fZiAmJiAhaXNOdWxsT3JVbmRlZmluZWQoY2xvbmVWYWx1ZSlcbiAgICAgICAgPyBzZXRWYWx1ZXMobmFtZSwgY2xvbmVWYWx1ZSwgb3B0aW9ucylcbiAgICAgICAgOiBzZXRGaWVsZFZhbHVlKG5hbWUsIGNsb25lVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlzV2F0Y2hlZChuYW1lLCBfbmFtZXMpICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uX2Zvcm1TdGF0ZSB9KTtcbiAgICBfc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgbmFtZTogX3N0YXRlLm1vdW50ID8gbmFtZSA6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IG9uQ2hhbmdlOiBDaGFuZ2VIYW5kbGVyID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgX3N0YXRlLm1vdW50ID0gdHJ1ZTtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgbGV0IG5hbWUgPSB0YXJnZXQubmFtZSBhcyBzdHJpbmc7XG4gICAgbGV0IGlzRmllbGRWYWx1ZVVwZGF0ZWQgPSB0cnVlO1xuICAgIGNvbnN0IGZpZWxkOiBGaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICBjb25zdCBnZXRDdXJyZW50RmllbGRWYWx1ZSA9ICgpID0+XG4gICAgICB0YXJnZXQudHlwZSA/IGdldEZpZWxkVmFsdWUoZmllbGQuX2YpIDogZ2V0RXZlbnRWYWx1ZShldmVudCk7XG4gICAgY29uc3QgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQgPSAoZmllbGRWYWx1ZTogYW55KTogdm9pZCA9PiB7XG4gICAgICBpc0ZpZWxkVmFsdWVVcGRhdGVkID1cbiAgICAgICAgTnVtYmVyLmlzTmFOKGZpZWxkVmFsdWUpIHx8XG4gICAgICAgIGZpZWxkVmFsdWUgPT09IGdldChfZm9ybVZhbHVlcywgbmFtZSwgZmllbGRWYWx1ZSk7XG4gICAgfTtcblxuICAgIGlmIChmaWVsZCkge1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICBjb25zdCBmaWVsZFZhbHVlID0gZ2V0Q3VycmVudEZpZWxkVmFsdWUoKTtcbiAgICAgIGNvbnN0IGlzQmx1ckV2ZW50ID1cbiAgICAgICAgZXZlbnQudHlwZSA9PT0gRVZFTlRTLkJMVVIgfHwgZXZlbnQudHlwZSA9PT0gRVZFTlRTLkZPQ1VTX09VVDtcbiAgICAgIGNvbnN0IHNob3VsZFNraXBWYWxpZGF0aW9uID1cbiAgICAgICAgKCFoYXNWYWxpZGF0aW9uKGZpZWxkLl9mKSAmJlxuICAgICAgICAgICFfb3B0aW9ucy5yZXNvbHZlciAmJlxuICAgICAgICAgICFnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpICYmXG4gICAgICAgICAgIWZpZWxkLl9mLmRlcHMpIHx8XG4gICAgICAgIHNraXBWYWxpZGF0aW9uKFxuICAgICAgICAgIGlzQmx1ckV2ZW50LFxuICAgICAgICAgIGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLFxuICAgICAgICAgIF9mb3JtU3RhdGUuaXNTdWJtaXR0ZWQsXG4gICAgICAgICAgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCxcbiAgICAgICAgICB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCxcbiAgICAgICAgKTtcbiAgICAgIGNvbnN0IHdhdGNoZWQgPSBpc1dhdGNoZWQobmFtZSwgX25hbWVzLCBpc0JsdXJFdmVudCk7XG5cbiAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgZmllbGRWYWx1ZSk7XG5cbiAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICBmaWVsZC5fZi5vbkJsdXIgJiYgZmllbGQuX2Yub25CbHVyKGV2ZW50KTtcbiAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrICYmIGRlbGF5RXJyb3JDYWxsYmFjaygwKTtcbiAgICAgIH0gZWxzZSBpZiAoZmllbGQuX2Yub25DaGFuZ2UpIHtcbiAgICAgICAgZmllbGQuX2Yub25DaGFuZ2UoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWVsZFN0YXRlID0gdXBkYXRlVG91Y2hBbmREaXJ0eShcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZmllbGRWYWx1ZSxcbiAgICAgICAgaXNCbHVyRXZlbnQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc2hvdWxkUmVuZGVyID0gIWlzRW1wdHlPYmplY3QoZmllbGRTdGF0ZSkgfHwgd2F0Y2hlZDtcblxuICAgICAgIWlzQmx1ckV2ZW50ICYmXG4gICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0eXBlOiBldmVudC50eXBlLFxuICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgICB9KTtcblxuICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmIF91cGRhdGVWYWxpZCgpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgc2hvdWxkUmVuZGVyICYmXG4gICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBuYW1lLCAuLi4od2F0Y2hlZCA/IHt9IDogZmllbGRTdGF0ZSkgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgIWlzQmx1ckV2ZW50ICYmIHdhdGNoZWQgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuXG4gICAgICBpZiAoX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9leGVjdXRlU2NoZW1hKFtuYW1lXSk7XG5cbiAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0ID0gc2NoZW1hRXJyb3JMb29rdXAoXG4gICAgICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgIF9maWVsZHMsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgZXJyb3JMb29rdXBSZXN1bHQgPSBzY2hlbWFFcnJvckxvb2t1cChcbiAgICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICAgIF9maWVsZHMsXG4gICAgICAgICAgICBwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0Lm5hbWUgfHwgbmFtZSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZXJyb3IgPSBlcnJvckxvb2t1cFJlc3VsdC5lcnJvcjtcbiAgICAgICAgICBuYW1lID0gZXJyb3JMb29rdXBSZXN1bHQubmFtZTtcblxuICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW25hbWVdLCB0cnVlKTtcbiAgICAgICAgZXJyb3IgPSAoXG4gICAgICAgICAgYXdhaXQgdmFsaWRhdGVGaWVsZChcbiAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgX2Zvcm1WYWx1ZXMsXG4gICAgICAgICAgICBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycyxcbiAgICAgICAgICAgIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sXG4gICAgICAgICAgKVxuICAgICAgICApW25hbWVdO1xuICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtuYW1lXSk7XG5cbiAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNGaWVsZFZhbHVlVXBkYXRlZCkge1xuICAgICAgICBmaWVsZC5fZi5kZXBzICYmXG4gICAgICAgICAgdHJpZ2dlcihcbiAgICAgICAgICAgIGZpZWxkLl9mLmRlcHMgYXNcbiAgICAgICAgICAgICAgfCBGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPlxuICAgICAgICAgICAgICB8IEZpZWxkUGF0aDxURmllbGRWYWx1ZXM+W10sXG4gICAgICAgICAgKTtcbiAgICAgICAgc2hvdWxkUmVuZGVyQnlFcnJvcihuYW1lLCBpc1ZhbGlkLCBlcnJvciwgZmllbGRTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IF9mb2N1c0lucHV0ID0gKHJlZjogUmVmLCBrZXk6IHN0cmluZykgPT4ge1xuICAgIGlmIChnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGtleSkgJiYgcmVmLmZvY3VzKSB7XG4gICAgICByZWYuZm9jdXMoKTtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH07XG5cbiAgY29uc3QgdHJpZ2dlcjogVXNlRm9ybVRyaWdnZXI8VEZpZWxkVmFsdWVzPiA9IGFzeW5jIChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBsZXQgaXNWYWxpZDtcbiAgICBsZXQgdmFsaWRhdGlvblJlc3VsdDtcbiAgICBjb25zdCBmaWVsZE5hbWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpIGFzIEludGVybmFsRmllbGROYW1lW107XG5cbiAgICBpZiAoX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgIGNvbnN0IGVycm9ycyA9IGF3YWl0IGV4ZWN1dGVTY2hlbWFBbmRVcGRhdGVTdGF0ZShcbiAgICAgICAgaXNVbmRlZmluZWQobmFtZSkgPyBuYW1lIDogZmllbGROYW1lcyxcbiAgICAgICk7XG5cbiAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gbmFtZVxuICAgICAgICA/ICFmaWVsZE5hbWVzLnNvbWUoKG5hbWUpID0+IGdldChlcnJvcnMsIG5hbWUpKVxuICAgICAgICA6IGlzVmFsaWQ7XG4gICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gKFxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBmaWVsZE5hbWVzLm1hcChhc3luYyAoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihcbiAgICAgICAgICAgICAgZmllbGQgJiYgZmllbGQuX2YgPyB7IFtmaWVsZE5hbWVdOiBmaWVsZCB9IDogZmllbGQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pLFxuICAgICAgICApXG4gICAgICApLmV2ZXJ5KEJvb2xlYW4pO1xuICAgICAgISghdmFsaWRhdGlvblJlc3VsdCAmJiAhX2Zvcm1TdGF0ZS5pc1ZhbGlkKSAmJiBfdXBkYXRlVmFsaWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IGlzVmFsaWQgPSBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcyk7XG4gICAgfVxuXG4gICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgLi4uKCFpc1N0cmluZyhuYW1lKSB8fFxuICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmIGlzVmFsaWQgIT09IF9mb3JtU3RhdGUuaXNWYWxpZClcbiAgICAgICAgPyB7fVxuICAgICAgICA6IHsgbmFtZSB9KSxcbiAgICAgIC4uLihfb3B0aW9ucy5yZXNvbHZlciB8fCAhbmFtZSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICB9KTtcblxuICAgIG9wdGlvbnMuc2hvdWxkRm9jdXMgJiZcbiAgICAgICF2YWxpZGF0aW9uUmVzdWx0ICYmXG4gICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oXG4gICAgICAgIF9maWVsZHMsXG4gICAgICAgIF9mb2N1c0lucHV0LFxuICAgICAgICBuYW1lID8gZmllbGROYW1lcyA6IF9uYW1lcy5tb3VudCxcbiAgICAgICk7XG5cbiAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdDtcbiAgfTtcblxuICBjb25zdCBnZXRWYWx1ZXM6IFVzZUZvcm1HZXRWYWx1ZXM8VEZpZWxkVmFsdWVzPiA9IChcbiAgICBmaWVsZE5hbWVzPzpcbiAgICAgIHwgRmllbGRQYXRoPFRGaWVsZFZhbHVlcz5cbiAgICAgIHwgUmVhZG9ubHlBcnJheTxGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPj4sXG4gICkgPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgIC4uLihfc3RhdGUubW91bnQgPyBfZm9ybVZhbHVlcyA6IF9kZWZhdWx0VmFsdWVzKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKGZpZWxkTmFtZXMpXG4gICAgICA/IHZhbHVlc1xuICAgICAgOiBpc1N0cmluZyhmaWVsZE5hbWVzKVxuICAgICAgPyBnZXQodmFsdWVzLCBmaWVsZE5hbWVzKVxuICAgICAgOiBmaWVsZE5hbWVzLm1hcCgobmFtZSkgPT4gZ2V0KHZhbHVlcywgbmFtZSkpO1xuICB9O1xuXG4gIGNvbnN0IGdldEZpZWxkU3RhdGU6IFVzZUZvcm1HZXRGaWVsZFN0YXRlPFRGaWVsZFZhbHVlcz4gPSAoXG4gICAgbmFtZSxcbiAgICBmb3JtU3RhdGUsXG4gICkgPT4gKHtcbiAgICBpbnZhbGlkOiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmVycm9ycywgbmFtZSksXG4gICAgaXNEaXJ0eTogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5kaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgaXNUb3VjaGVkOiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLnRvdWNoZWRGaWVsZHMsIG5hbWUpLFxuICAgIGlzVmFsaWRhdGluZzogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKSxcbiAgICBlcnJvcjogZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkuZXJyb3JzLCBuYW1lKSxcbiAgfSk7XG5cbiAgY29uc3QgY2xlYXJFcnJvcnM6IFVzZUZvcm1DbGVhckVycm9yczxURmllbGRWYWx1ZXM+ID0gKG5hbWUpID0+IHtcbiAgICBuYW1lICYmXG4gICAgICBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkuZm9yRWFjaCgoaW5wdXROYW1lKSA9PlxuICAgICAgICB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgaW5wdXROYW1lKSxcbiAgICAgICk7XG5cbiAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICBlcnJvcnM6IG5hbWUgPyBfZm9ybVN0YXRlLmVycm9ycyA6IHt9LFxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHNldEVycm9yOiBVc2VGb3JtU2V0RXJyb3I8VEZpZWxkVmFsdWVzPiA9IChuYW1lLCBlcnJvciwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHJlZiA9IChnZXQoX2ZpZWxkcywgbmFtZSwgeyBfZjoge30gfSkuX2YgfHwge30pLnJlZjtcbiAgICBjb25zdCBjdXJyZW50RXJyb3IgPSBnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpIHx8IHt9O1xuXG4gICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgZXJyb3IgbWVzc2FnZXMgZWxzZXdoZXJlIGluIHRoZSBvYmplY3QgdHJlZS5cbiAgICBjb25zdCB7IHJlZjogY3VycmVudFJlZiwgbWVzc2FnZSwgdHlwZSwgLi4ucmVzdE9mRXJyb3JUcmVlIH0gPSBjdXJyZW50RXJyb3I7XG5cbiAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIHtcbiAgICAgIC4uLnJlc3RPZkVycm9yVHJlZSxcbiAgICAgIC4uLmVycm9yLFxuICAgICAgcmVmLFxuICAgIH0pO1xuXG4gICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgbmFtZSxcbiAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaG91bGRGb2N1cyAmJiByZWYgJiYgcmVmLmZvY3VzICYmIHJlZi5mb2N1cygpO1xuICB9O1xuXG4gIGNvbnN0IHdhdGNoOiBVc2VGb3JtV2F0Y2g8VEZpZWxkVmFsdWVzPiA9IChcbiAgICBuYW1lPzpcbiAgICAgIHwgRmllbGRQYXRoPFRGaWVsZFZhbHVlcz5cbiAgICAgIHwgUmVhZG9ubHlBcnJheTxGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPj5cbiAgICAgIHwgV2F0Y2hPYnNlcnZlcjxURmllbGRWYWx1ZXM+LFxuICAgIGRlZmF1bHRWYWx1ZT86IERlZXBQYXJ0aWFsPFRGaWVsZFZhbHVlcz4sXG4gICkgPT5cbiAgICBpc0Z1bmN0aW9uKG5hbWUpXG4gICAgICA/IF9zdWJqZWN0cy52YWx1ZXMuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiAocGF5bG9hZCkgPT5cbiAgICAgICAgICAgIG5hbWUoXG4gICAgICAgICAgICAgIF9nZXRXYXRjaCh1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZSksXG4gICAgICAgICAgICAgIHBheWxvYWQgYXMge1xuICAgICAgICAgICAgICAgIG5hbWU/OiBGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPjtcbiAgICAgICAgICAgICAgICB0eXBlPzogRXZlbnRUeXBlO1xuICAgICAgICAgICAgICAgIHZhbHVlPzogdW5rbm93bjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICksXG4gICAgICAgIH0pXG4gICAgICA6IF9nZXRXYXRjaChcbiAgICAgICAgICBuYW1lIGFzIEludGVybmFsRmllbGROYW1lIHwgSW50ZXJuYWxGaWVsZE5hbWVbXSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgKTtcblxuICBjb25zdCB1bnJlZ2lzdGVyOiBVc2VGb3JtVW5yZWdpc3RlcjxURmllbGRWYWx1ZXM+ID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIG5hbWUgPyBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkgOiBfbmFtZXMubW91bnQpIHtcbiAgICAgIF9uYW1lcy5tb3VudC5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgIF9uYW1lcy5hcnJheS5kZWxldGUoZmllbGROYW1lKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmtlZXBWYWx1ZSkge1xuICAgICAgICB1bnNldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICB1bnNldChfZm9ybVZhbHVlcywgZmllbGROYW1lKTtcbiAgICAgIH1cblxuICAgICAgIW9wdGlvbnMua2VlcEVycm9yICYmIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBmaWVsZE5hbWUpO1xuICAgICAgIW9wdGlvbnMua2VlcERpcnR5ICYmIHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAhb3B0aW9ucy5rZWVwVG91Y2hlZCAmJiB1bnNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAhb3B0aW9ucy5rZWVwSXNWYWxpZGF0aW5nICYmXG4gICAgICAgIHVuc2V0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICFfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyICYmXG4gICAgICAgICFvcHRpb25zLmtlZXBEZWZhdWx0VmFsdWUgJiZcbiAgICAgICAgdW5zZXQoX2RlZmF1bHRWYWx1ZXMsIGZpZWxkTmFtZSk7XG4gICAgfVxuXG4gICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgIH0pO1xuXG4gICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgIC4uLighb3B0aW9ucy5rZWVwRGlydHkgPyB7fSA6IHsgaXNEaXJ0eTogX2dldERpcnR5KCkgfSksXG4gICAgfSk7XG5cbiAgICAhb3B0aW9ucy5rZWVwSXNWYWxpZCAmJiBfdXBkYXRlVmFsaWQoKTtcbiAgfTtcblxuICBjb25zdCBfdXBkYXRlRGlzYWJsZWRGaWVsZDogQ29udHJvbDxURmllbGRWYWx1ZXM+WydfdXBkYXRlRGlzYWJsZWRGaWVsZCddID0gKHtcbiAgICBkaXNhYmxlZCxcbiAgICBuYW1lLFxuICAgIGZpZWxkLFxuICAgIGZpZWxkcyxcbiAgICB2YWx1ZSxcbiAgfSkgPT4ge1xuICAgIGlmICgoaXNCb29sZWFuKGRpc2FibGVkKSAmJiBfc3RhdGUubW91bnQpIHx8ICEhZGlzYWJsZWQpIHtcbiAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBkaXNhYmxlZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IGlzVW5kZWZpbmVkKHZhbHVlKVxuICAgICAgICA/IGdldEZpZWxkVmFsdWUoZmllbGQgPyBmaWVsZC5fZiA6IGdldChmaWVsZHMsIG5hbWUpLl9mKVxuICAgICAgICA6IHZhbHVlO1xuICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBpbnB1dFZhbHVlKTtcbiAgICAgIHVwZGF0ZVRvdWNoQW5kRGlydHkobmFtZSwgaW5wdXRWYWx1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVnaXN0ZXI6IFVzZUZvcm1SZWdpc3RlcjxURmllbGRWYWx1ZXM+ID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGxldCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICBjb25zdCBkaXNhYmxlZElzRGVmaW5lZCA9IGlzQm9vbGVhbihvcHRpb25zLmRpc2FibGVkKTtcblxuICAgIHNldChfZmllbGRzLCBuYW1lLCB7XG4gICAgICAuLi4oZmllbGQgfHwge30pLFxuICAgICAgX2Y6IHtcbiAgICAgICAgLi4uKGZpZWxkICYmIGZpZWxkLl9mID8gZmllbGQuX2YgOiB7IHJlZjogeyBuYW1lIH0gfSksXG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1vdW50OiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBfbmFtZXMubW91bnQuYWRkKG5hbWUpO1xuXG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICBfdXBkYXRlRGlzYWJsZWRGaWVsZCh7XG4gICAgICAgIGZpZWxkLFxuICAgICAgICBkaXNhYmxlZDogb3B0aW9ucy5kaXNhYmxlZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlVmFsaWRBbmRWYWx1ZShuYW1lLCB0cnVlLCBvcHRpb25zLnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uKGRpc2FibGVkSXNEZWZpbmVkID8geyBkaXNhYmxlZDogb3B0aW9ucy5kaXNhYmxlZCB9IDoge30pLFxuICAgICAgLi4uKF9vcHRpb25zLnByb2dyZXNzaXZlXG4gICAgICAgID8ge1xuICAgICAgICAgICAgcmVxdWlyZWQ6ICEhb3B0aW9ucy5yZXF1aXJlZCxcbiAgICAgICAgICAgIG1pbjogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWluKSxcbiAgICAgICAgICAgIG1heDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWF4KSxcbiAgICAgICAgICAgIG1pbkxlbmd0aDogZ2V0UnVsZVZhbHVlPG51bWJlcj4ob3B0aW9ucy5taW5MZW5ndGgpIGFzIG51bWJlcixcbiAgICAgICAgICAgIG1heExlbmd0aDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWF4TGVuZ3RoKSBhcyBudW1iZXIsXG4gICAgICAgICAgICBwYXR0ZXJuOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5wYXR0ZXJuKSBhcyBzdHJpbmcsXG4gICAgICAgICAgfVxuICAgICAgICA6IHt9KSxcbiAgICAgIG5hbWUsXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIG9uQmx1cjogb25DaGFuZ2UsXG4gICAgICByZWY6IChyZWY6IEhUTUxJbnB1dEVsZW1lbnQgfCBudWxsKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICByZWdpc3RlcihuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcblxuICAgICAgICAgIGNvbnN0IGZpZWxkUmVmID0gaXNVbmRlZmluZWQocmVmLnZhbHVlKVxuICAgICAgICAgICAgPyByZWYucXVlcnlTZWxlY3RvckFsbFxuICAgICAgICAgICAgICA/IChyZWYucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsc2VsZWN0LHRleHRhcmVhJylbMF0gYXMgUmVmKSB8fCByZWZcbiAgICAgICAgICAgICAgOiByZWZcbiAgICAgICAgICAgIDogcmVmO1xuICAgICAgICAgIGNvbnN0IHJhZGlvT3JDaGVja2JveCA9IGlzUmFkaW9PckNoZWNrYm94KGZpZWxkUmVmKTtcbiAgICAgICAgICBjb25zdCByZWZzID0gZmllbGQuX2YucmVmcyB8fCBbXTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHJhZGlvT3JDaGVja2JveFxuICAgICAgICAgICAgICA/IHJlZnMuZmluZCgob3B0aW9uOiBSZWYpID0+IG9wdGlvbiA9PT0gZmllbGRSZWYpXG4gICAgICAgICAgICAgIDogZmllbGRSZWYgPT09IGZpZWxkLl9mLnJlZlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldChfZmllbGRzLCBuYW1lLCB7XG4gICAgICAgICAgICBfZjoge1xuICAgICAgICAgICAgICAuLi5maWVsZC5fZixcbiAgICAgICAgICAgICAgLi4uKHJhZGlvT3JDaGVja2JveFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICByZWZzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4ucmVmcy5maWx0ZXIobGl2ZSksXG4gICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkgPyBbe31dIDogW10pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHsgdHlwZTogZmllbGRSZWYudHlwZSwgbmFtZSB9LFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogeyByZWY6IGZpZWxkUmVmIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHVwZGF0ZVZhbGlkQW5kVmFsdWUobmFtZSwgZmFsc2UsIHVuZGVmaW5lZCwgZmllbGRSZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUsIHt9KTtcblxuICAgICAgICAgIGlmIChmaWVsZC5fZikge1xuICAgICAgICAgICAgZmllbGQuX2YubW91bnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAoX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBvcHRpb25zLnNob3VsZFVucmVnaXN0ZXIpICYmXG4gICAgICAgICAgICAhKGlzTmFtZUluRmllbGRBcnJheShfbmFtZXMuYXJyYXksIG5hbWUpICYmIF9zdGF0ZS5hY3Rpb24pICYmXG4gICAgICAgICAgICBfbmFtZXMudW5Nb3VudC5hZGQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBfZm9jdXNFcnJvciA9ICgpID0+XG4gICAgX29wdGlvbnMuc2hvdWxkRm9jdXNFcnJvciAmJlxuICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihfZmllbGRzLCBfZm9jdXNJbnB1dCwgX25hbWVzLm1vdW50KTtcblxuICBjb25zdCBfZGlzYWJsZUZvcm0gPSAoZGlzYWJsZWQ/OiBib29sZWFuKSA9PiB7XG4gICAgaWYgKGlzQm9vbGVhbihkaXNhYmxlZCkpIHtcbiAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgZGlzYWJsZWQgfSk7XG4gICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oXG4gICAgICAgIF9maWVsZHMsXG4gICAgICAgIChyZWYsIG5hbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50RmllbGQ6IEZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgIGlmIChjdXJyZW50RmllbGQpIHtcbiAgICAgICAgICAgIHJlZi5kaXNhYmxlZCA9IGN1cnJlbnRGaWVsZC5fZi5kaXNhYmxlZCB8fCBkaXNhYmxlZDtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudEZpZWxkLl9mLnJlZnMpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRGaWVsZC5fZi5yZWZzLmZvckVhY2goKGlucHV0UmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgaW5wdXRSZWYuZGlzYWJsZWQgPSBjdXJyZW50RmllbGQuX2YuZGlzYWJsZWQgfHwgZGlzYWJsZWQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgMCxcbiAgICAgICAgZmFsc2UsXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVTdWJtaXQ6IFVzZUZvcm1IYW5kbGVTdWJtaXQ8VEZpZWxkVmFsdWVzPiA9XG4gICAgKG9uVmFsaWQsIG9uSW52YWxpZCkgPT4gYXN5bmMgKGUpID0+IHtcbiAgICAgIGxldCBvblZhbGlkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5wZXJzaXN0ICYmIGUucGVyc2lzdCgpO1xuICAgICAgfVxuICAgICAgbGV0IGZpZWxkVmFsdWVzID0gY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpO1xuXG4gICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcnMsIHZhbHVlcyB9ID0gYXdhaXQgX2V4ZWN1dGVTY2hlbWEoKTtcbiAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIGZpZWxkVmFsdWVzID0gdmFsdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMpO1xuICAgICAgfVxuXG4gICAgICB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgJ3Jvb3QnKTtcblxuICAgICAgaWYgKGlzRW1wdHlPYmplY3QoX2Zvcm1TdGF0ZS5lcnJvcnMpKSB7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICBlcnJvcnM6IHt9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBvblZhbGlkKGZpZWxkVmFsdWVzIGFzIFRGaWVsZFZhbHVlcywgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgb25WYWxpZEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvbkludmFsaWQpIHtcbiAgICAgICAgICBhd2FpdCBvbkludmFsaWQoeyAuLi5fZm9ybVN0YXRlLmVycm9ycyB9LCBlKTtcbiAgICAgICAgfVxuICAgICAgICBfZm9jdXNFcnJvcigpO1xuICAgICAgICBzZXRUaW1lb3V0KF9mb2N1c0Vycm9yKTtcbiAgICAgIH1cblxuICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICBpc1N1Ym1pdHRlZDogdHJ1ZSxcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSAmJiAhb25WYWxpZEVycm9yLFxuICAgICAgICBzdWJtaXRDb3VudDogX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudCArIDEsXG4gICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICB9KTtcbiAgICAgIGlmIChvblZhbGlkRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgb25WYWxpZEVycm9yO1xuICAgICAgfVxuICAgIH07XG5cbiAgY29uc3QgcmVzZXRGaWVsZDogVXNlRm9ybVJlc2V0RmllbGQ8VEZpZWxkVmFsdWVzPiA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoZ2V0KF9maWVsZHMsIG5hbWUpKSB7XG4gICAgICBpZiAoaXNVbmRlZmluZWQob3B0aW9ucy5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIHNldFZhbHVlKG5hbWUsIGNsb25lT2JqZWN0KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFZhbHVlKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VmFsdWUgYXMgUGF0aFZhbHVlPFxuICAgICAgICAgICAgVEZpZWxkVmFsdWVzLFxuICAgICAgICAgICAgRmllbGRQYXRoPFRGaWVsZFZhbHVlcz5cbiAgICAgICAgICA+LFxuICAgICAgICApO1xuICAgICAgICBzZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIGNsb25lT2JqZWN0KG9wdGlvbnMuZGVmYXVsdFZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5rZWVwVG91Y2hlZCkge1xuICAgICAgICB1bnNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMua2VlcERpcnR5KSB7XG4gICAgICAgIHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpO1xuICAgICAgICBfZm9ybVN0YXRlLmlzRGlydHkgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZVxuICAgICAgICAgID8gX2dldERpcnR5KG5hbWUsIGNsb25lT2JqZWN0KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpKVxuICAgICAgICAgIDogX2dldERpcnR5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5rZWVwRXJyb3IpIHtcbiAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICBfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCAmJiBfdXBkYXRlVmFsaWQoKTtcbiAgICAgIH1cblxuICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBfcmVzZXQ6IFVzZUZvcm1SZXNldDxURmllbGRWYWx1ZXM+ID0gKFxuICAgIGZvcm1WYWx1ZXMsXG4gICAga2VlcFN0YXRlT3B0aW9ucyA9IHt9LFxuICApID0+IHtcbiAgICBjb25zdCB1cGRhdGVkVmFsdWVzID0gZm9ybVZhbHVlcyA/IGNsb25lT2JqZWN0KGZvcm1WYWx1ZXMpIDogX2RlZmF1bHRWYWx1ZXM7XG4gICAgY29uc3QgY2xvbmVVcGRhdGVkVmFsdWVzID0gY2xvbmVPYmplY3QodXBkYXRlZFZhbHVlcyk7XG4gICAgY29uc3QgaXNFbXB0eVJlc2V0VmFsdWVzID0gaXNFbXB0eU9iamVjdChmb3JtVmFsdWVzKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBpc0VtcHR5UmVzZXRWYWx1ZXMgPyBfZGVmYXVsdFZhbHVlcyA6IGNsb25lVXBkYXRlZFZhbHVlcztcblxuICAgIGlmICgha2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcykge1xuICAgICAgX2RlZmF1bHRWYWx1ZXMgPSB1cGRhdGVkVmFsdWVzO1xuICAgIH1cblxuICAgIGlmICgha2VlcFN0YXRlT3B0aW9ucy5rZWVwVmFsdWVzKSB7XG4gICAgICBpZiAoa2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgX25hbWVzLm1vdW50KSB7XG4gICAgICAgICAgZ2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSlcbiAgICAgICAgICAgID8gc2V0KHZhbHVlcywgZmllbGROYW1lLCBnZXQoX2Zvcm1WYWx1ZXMsIGZpZWxkTmFtZSkpXG4gICAgICAgICAgICA6IHNldFZhbHVlKFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSBhcyBGaWVsZFBhdGg8VEZpZWxkVmFsdWVzPixcbiAgICAgICAgICAgICAgICBnZXQodmFsdWVzLCBmaWVsZE5hbWUpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNXZWIgJiYgaXNVbmRlZmluZWQoZm9ybVZhbHVlcykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLm1vdW50KSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC5fZikge1xuICAgICAgICAgICAgICBjb25zdCBmaWVsZFJlZmVyZW5jZSA9IEFycmF5LmlzQXJyYXkoZmllbGQuX2YucmVmcylcbiAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnNbMF1cbiAgICAgICAgICAgICAgICA6IGZpZWxkLl9mLnJlZjtcblxuICAgICAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtID0gZmllbGRSZWZlcmVuY2UuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgICAgICAgICAgICBmb3JtLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZmllbGRzID0ge307XG4gICAgICB9XG5cbiAgICAgIF9mb3JtVmFsdWVzID0gcHJvcHMuc2hvdWxkVW5yZWdpc3RlclxuICAgICAgICA/IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXNcbiAgICAgICAgICA/IGNsb25lT2JqZWN0KF9kZWZhdWx0VmFsdWVzKVxuICAgICAgICAgIDoge31cbiAgICAgICAgOiBjbG9uZU9iamVjdCh2YWx1ZXMpO1xuXG4gICAgICBfc3ViamVjdHMuYXJyYXkubmV4dCh7XG4gICAgICAgIHZhbHVlczogeyAuLi52YWx1ZXMgfSxcbiAgICAgIH0pO1xuXG4gICAgICBfc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICB2YWx1ZXM6IHsgLi4udmFsdWVzIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfbmFtZXMgPSB7XG4gICAgICBtb3VudDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMgPyBfbmFtZXMubW91bnQgOiBuZXcgU2V0KCksXG4gICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICBhcnJheTogbmV3IFNldCgpLFxuICAgICAgd2F0Y2g6IG5ldyBTZXQoKSxcbiAgICAgIHdhdGNoQWxsOiBmYWxzZSxcbiAgICAgIGZvY3VzOiAnJyxcbiAgICB9O1xuXG4gICAgX3N0YXRlLm1vdW50ID1cbiAgICAgICFfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fFxuICAgICAgISFrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1ZhbGlkIHx8XG4gICAgICAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzO1xuXG4gICAgX3N0YXRlLndhdGNoID0gISFwcm9wcy5zaG91bGRVbnJlZ2lzdGVyO1xuXG4gICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgc3VibWl0Q291bnQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcFN1Ym1pdENvdW50XG4gICAgICAgID8gX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudFxuICAgICAgICA6IDAsXG4gICAgICBpc0RpcnR5OiBpc0VtcHR5UmVzZXRWYWx1ZXNcbiAgICAgICAgPyBmYWxzZVxuICAgICAgICA6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5XG4gICAgICAgID8gX2Zvcm1TdGF0ZS5pc0RpcnR5XG4gICAgICAgIDogISEoXG4gICAgICAgICAgICBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmXG4gICAgICAgICAgICAhZGVlcEVxdWFsKGZvcm1WYWx1ZXMsIF9kZWZhdWx0VmFsdWVzKVxuICAgICAgICAgICksXG4gICAgICBpc1N1Ym1pdHRlZDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwSXNTdWJtaXR0ZWRcbiAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0dGVkXG4gICAgICAgIDogZmFsc2UsXG4gICAgICBkaXJ0eUZpZWxkczogaXNFbXB0eVJlc2V0VmFsdWVzXG4gICAgICAgID8gW11cbiAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlc1xuICAgICAgICA/IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiYgX2Zvcm1WYWx1ZXNcbiAgICAgICAgICA/IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcylcbiAgICAgICAgICA6IF9mb3JtU3RhdGUuZGlydHlGaWVsZHNcbiAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmIGZvcm1WYWx1ZXNcbiAgICAgICAgPyBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcylcbiAgICAgICAgOiB7fSxcbiAgICAgIHRvdWNoZWRGaWVsZHM6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcFRvdWNoZWRcbiAgICAgICAgPyBfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHNcbiAgICAgICAgOiB7fSxcbiAgICAgIGVycm9yczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRXJyb3JzID8gX2Zvcm1TdGF0ZS5lcnJvcnMgOiB7fSxcbiAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwSXNTdWJtaXRTdWNjZXNzZnVsXG4gICAgICAgID8gX2Zvcm1TdGF0ZS5pc1N1Ym1pdFN1Y2Nlc3NmdWxcbiAgICAgICAgOiBmYWxzZSxcbiAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgcmVzZXQ6IFVzZUZvcm1SZXNldDxURmllbGRWYWx1ZXM+ID0gKGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMpID0+XG4gICAgX3Jlc2V0KFxuICAgICAgaXNGdW5jdGlvbihmb3JtVmFsdWVzKVxuICAgICAgICA/IGZvcm1WYWx1ZXMoX2Zvcm1WYWx1ZXMgYXMgVEZpZWxkVmFsdWVzKVxuICAgICAgICA6IGZvcm1WYWx1ZXMsXG4gICAgICBrZWVwU3RhdGVPcHRpb25zLFxuICAgICk7XG5cbiAgY29uc3Qgc2V0Rm9jdXM6IFVzZUZvcm1TZXRGb2N1czxURmllbGRWYWx1ZXM+ID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gZmllbGQgJiYgZmllbGQuX2Y7XG5cbiAgICBpZiAoZmllbGRSZWZlcmVuY2UpIHtcbiAgICAgIGNvbnN0IGZpZWxkUmVmID0gZmllbGRSZWZlcmVuY2UucmVmc1xuICAgICAgICA/IGZpZWxkUmVmZXJlbmNlLnJlZnNbMF1cbiAgICAgICAgOiBmaWVsZFJlZmVyZW5jZS5yZWY7XG5cbiAgICAgIGlmIChmaWVsZFJlZi5mb2N1cykge1xuICAgICAgICBmaWVsZFJlZi5mb2N1cygpO1xuICAgICAgICBvcHRpb25zLnNob3VsZFNlbGVjdCAmJiBmaWVsZFJlZi5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgX3VwZGF0ZUZvcm1TdGF0ZSA9IChcbiAgICB1cGRhdGVkRm9ybVN0YXRlOiBQYXJ0aWFsPEZvcm1TdGF0ZTxURmllbGRWYWx1ZXM+PixcbiAgKSA9PiB7XG4gICAgX2Zvcm1TdGF0ZSA9IHtcbiAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAuLi51cGRhdGVkRm9ybVN0YXRlLFxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgX3Jlc2V0RGVmYXVsdFZhbHVlcyA9ICgpID0+XG4gICAgaXNGdW5jdGlvbihfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSAmJlxuICAgIF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMoKS50aGVuKCh2YWx1ZXMpID0+IHtcbiAgICAgIHJlc2V0KHZhbHVlcywgX29wdGlvbnMucmVzZXRPcHRpb25zKTtcbiAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIHJldHVybiB7XG4gICAgY29udHJvbDoge1xuICAgICAgcmVnaXN0ZXIsXG4gICAgICB1bnJlZ2lzdGVyLFxuICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICAgIGhhbmRsZVN1Ym1pdCxcbiAgICAgIHNldEVycm9yLFxuICAgICAgX2V4ZWN1dGVTY2hlbWEsXG4gICAgICBfZ2V0V2F0Y2gsXG4gICAgICBfZ2V0RGlydHksXG4gICAgICBfdXBkYXRlVmFsaWQsXG4gICAgICBfcmVtb3ZlVW5tb3VudGVkLFxuICAgICAgX3VwZGF0ZUZpZWxkQXJyYXksXG4gICAgICBfdXBkYXRlRGlzYWJsZWRGaWVsZCxcbiAgICAgIF9nZXRGaWVsZEFycmF5LFxuICAgICAgX3Jlc2V0LFxuICAgICAgX3Jlc2V0RGVmYXVsdFZhbHVlcyxcbiAgICAgIF91cGRhdGVGb3JtU3RhdGUsXG4gICAgICBfZGlzYWJsZUZvcm0sXG4gICAgICBfc3ViamVjdHMsXG4gICAgICBfcHJveHlGb3JtU3RhdGUsXG4gICAgICBfc2V0RXJyb3JzLFxuICAgICAgZ2V0IF9maWVsZHMoKSB7XG4gICAgICAgIHJldHVybiBfZmllbGRzO1xuICAgICAgfSxcbiAgICAgIGdldCBfZm9ybVZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9mb3JtVmFsdWVzO1xuICAgICAgfSxcbiAgICAgIGdldCBfc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBfc3RhdGU7XG4gICAgICB9LFxuICAgICAgc2V0IF9zdGF0ZSh2YWx1ZSkge1xuICAgICAgICBfc3RhdGUgPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBnZXQgX2RlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdFZhbHVlcztcbiAgICAgIH0sXG4gICAgICBnZXQgX25hbWVzKCkge1xuICAgICAgICByZXR1cm4gX25hbWVzO1xuICAgICAgfSxcbiAgICAgIHNldCBfbmFtZXModmFsdWUpIHtcbiAgICAgICAgX25hbWVzID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgZ2V0IF9mb3JtU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBfZm9ybVN0YXRlO1xuICAgICAgfSxcbiAgICAgIHNldCBfZm9ybVN0YXRlKHZhbHVlKSB7XG4gICAgICAgIF9mb3JtU3RhdGUgPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBnZXQgX29wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfb3B0aW9ucztcbiAgICAgIH0sXG4gICAgICBzZXQgX29wdGlvbnModmFsdWUpIHtcbiAgICAgICAgX29wdGlvbnMgPSB7XG4gICAgICAgICAgLi4uX29wdGlvbnMsXG4gICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH0sXG4gICAgdHJpZ2dlcixcbiAgICByZWdpc3RlcixcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgd2F0Y2gsXG4gICAgc2V0VmFsdWUsXG4gICAgZ2V0VmFsdWVzLFxuICAgIHJlc2V0LFxuICAgIHJlc2V0RmllbGQsXG4gICAgY2xlYXJFcnJvcnMsXG4gICAgdW5yZWdpc3RlcixcbiAgICBzZXRFcnJvcixcbiAgICBzZXRGb2N1cyxcbiAgICBnZXRGaWVsZFN0YXRlLFxuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgY3JlYXRlRm9ybUNvbnRyb2wgfSBmcm9tICcuL2xvZ2ljL2NyZWF0ZUZvcm1Db250cm9sJztcbmltcG9ydCBnZXRQcm94eUZvcm1TdGF0ZSBmcm9tICcuL2xvZ2ljL2dldFByb3h5Rm9ybVN0YXRlJztcbmltcG9ydCBzaG91bGRSZW5kZXJGb3JtU3RhdGUgZnJvbSAnLi9sb2dpYy9zaG91bGRSZW5kZXJGb3JtU3RhdGUnO1xuaW1wb3J0IGRlZXBFcXVhbCBmcm9tICcuL3V0aWxzL2RlZXBFcXVhbCc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL3V0aWxzL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHtcbiAgRmllbGRWYWx1ZXMsXG4gIEZvcm1TdGF0ZSxcbiAgSW50ZXJuYWxGaWVsZE5hbWUsXG4gIFVzZUZvcm1Qcm9wcyxcbiAgVXNlRm9ybVJldHVybixcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyB1c2VTdWJzY3JpYmUgfSBmcm9tICcuL3VzZVN1YnNjcmliZSc7XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gbWFuYWdlIHRoZSBlbnRpcmUgZm9ybS5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLWdldC1zdGFydGVkLXRzLTVrc21tKSDigKIgW1ZpZGVvXShodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PVJrWHY0QVhYQ180KVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGZvcm0gY29uZmlndXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBwYXJhbWV0ZXJzLlxuICpcbiAqIEByZXR1cm5zIG1ldGhvZHMgLSBpbmRpdmlkdWFsIGZ1bmN0aW9ucyB0byBtYW5hZ2UgdGhlIGZvcm0gc3RhdGUuIHtAbGluayBVc2VGb3JtUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciwgaGFuZGxlU3VibWl0LCB3YXRjaCwgZm9ybVN0YXRlOiB7IGVycm9ycyB9IH0gPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIGNvbnNvbGUubG9nKHdhdGNoKFwiZXhhbXBsZVwiKSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXQob25TdWJtaXQpfT5cbiAqICAgICAgIDxpbnB1dCBkZWZhdWx0VmFsdWU9XCJ0ZXN0XCIgey4uLnJlZ2lzdGVyKFwiZXhhbXBsZVwiKX0gLz5cbiAqICAgICAgIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJleGFtcGxlUmVxdWlyZWRcIiwgeyByZXF1aXJlZDogdHJ1ZSB9KX0gLz5cbiAqICAgICAgIHtlcnJvcnMuZXhhbXBsZVJlcXVpcmVkICYmIDxzcGFuPlRoaXMgZmllbGQgaXMgcmVxdWlyZWQ8L3NwYW4+fVxuICogICAgICAgPGJ1dHRvbj5TdWJtaXQ8L2J1dHRvbj5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcm08XG4gIFRGaWVsZFZhbHVlcyBleHRlbmRzIEZpZWxkVmFsdWVzID0gRmllbGRWYWx1ZXMsXG4gIFRDb250ZXh0ID0gYW55LFxuICBUVHJhbnNmb3JtZWRWYWx1ZXMgZXh0ZW5kcyBGaWVsZFZhbHVlcyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbj4oXG4gIHByb3BzOiBVc2VGb3JtUHJvcHM8VEZpZWxkVmFsdWVzLCBUQ29udGV4dD4gPSB7fSxcbik6IFVzZUZvcm1SZXR1cm48VEZpZWxkVmFsdWVzLCBUQ29udGV4dCwgVFRyYW5zZm9ybWVkVmFsdWVzPiB7XG4gIGNvbnN0IF9mb3JtQ29udHJvbCA9IFJlYWN0LnVzZVJlZjxcbiAgICBVc2VGb3JtUmV0dXJuPFRGaWVsZFZhbHVlcywgVENvbnRleHQsIFRUcmFuc2Zvcm1lZFZhbHVlcz4gfCB1bmRlZmluZWRcbiAgPigpO1xuICBjb25zdCBfdmFsdWVzID0gUmVhY3QudXNlUmVmPHR5cGVvZiBwcm9wcy52YWx1ZXM+KCk7XG4gIGNvbnN0IFtmb3JtU3RhdGUsIHVwZGF0ZUZvcm1TdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZTxGb3JtU3RhdGU8VEZpZWxkVmFsdWVzPj4oe1xuICAgIGlzRGlydHk6IGZhbHNlLFxuICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgaXNMb2FkaW5nOiBpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpLFxuICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcbiAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXG4gICAgaXNWYWxpZDogZmFsc2UsXG4gICAgc3VibWl0Q291bnQ6IDAsXG4gICAgZGlydHlGaWVsZHM6IHt9LFxuICAgIHRvdWNoZWRGaWVsZHM6IHt9LFxuICAgIHZhbGlkYXRpbmdGaWVsZHM6IHt9LFxuICAgIGVycm9yczogcHJvcHMuZXJyb3JzIHx8IHt9LFxuICAgIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB8fCBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWVzOiBpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBwcm9wcy5kZWZhdWx0VmFsdWVzLFxuICB9KTtcblxuICBpZiAoIV9mb3JtQ29udHJvbC5jdXJyZW50KSB7XG4gICAgX2Zvcm1Db250cm9sLmN1cnJlbnQgPSB7XG4gICAgICAuLi5jcmVhdGVGb3JtQ29udHJvbChwcm9wcyksXG4gICAgICBmb3JtU3RhdGUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGNvbnRyb2wgPSBfZm9ybUNvbnRyb2wuY3VycmVudC5jb250cm9sO1xuICBjb250cm9sLl9vcHRpb25zID0gcHJvcHM7XG5cbiAgdXNlU3Vic2NyaWJlKHtcbiAgICBzdWJqZWN0OiBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZSxcbiAgICBuZXh0OiAoXG4gICAgICB2YWx1ZTogUGFydGlhbDxGb3JtU3RhdGU8VEZpZWxkVmFsdWVzPj4gJiB7IG5hbWU/OiBJbnRlcm5hbEZpZWxkTmFtZSB9LFxuICAgICkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBzaG91bGRSZW5kZXJGb3JtU3RhdGUoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgY29udHJvbC5fcHJveHlGb3JtU3RhdGUsXG4gICAgICAgICAgY29udHJvbC5fdXBkYXRlRm9ybVN0YXRlLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB1cGRhdGVGb3JtU3RhdGUoeyAuLi5jb250cm9sLl9mb3JtU3RhdGUgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KFxuICAgICgpID0+IGNvbnRyb2wuX2Rpc2FibGVGb3JtKHByb3BzLmRpc2FibGVkKSxcbiAgICBbY29udHJvbCwgcHJvcHMuZGlzYWJsZWRdLFxuICApO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgIGNvbnN0IGlzRGlydHkgPSBjb250cm9sLl9nZXREaXJ0eSgpO1xuICAgICAgaWYgKGlzRGlydHkgIT09IGZvcm1TdGF0ZS5pc0RpcnR5KSB7XG4gICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgIGlzRGlydHksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2NvbnRyb2wsIGZvcm1TdGF0ZS5pc0RpcnR5XSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvcHMudmFsdWVzICYmICFkZWVwRXF1YWwocHJvcHMudmFsdWVzLCBfdmFsdWVzLmN1cnJlbnQpKSB7XG4gICAgICBjb250cm9sLl9yZXNldChwcm9wcy52YWx1ZXMsIGNvbnRyb2wuX29wdGlvbnMucmVzZXRPcHRpb25zKTtcbiAgICAgIF92YWx1ZXMuY3VycmVudCA9IHByb3BzLnZhbHVlcztcbiAgICAgIHVwZGF0ZUZvcm1TdGF0ZSgoc3RhdGUpID0+ICh7IC4uLnN0YXRlIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udHJvbC5fcmVzZXREZWZhdWx0VmFsdWVzKCk7XG4gICAgfVxuICB9LCBbcHJvcHMudmFsdWVzLCBjb250cm9sXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvcHMuZXJyb3JzKSB7XG4gICAgICBjb250cm9sLl9zZXRFcnJvcnMocHJvcHMuZXJyb3JzKTtcbiAgICB9XG4gIH0sIFtwcm9wcy5lcnJvcnMsIGNvbnRyb2xdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29udHJvbC5fc3RhdGUubW91bnQpIHtcbiAgICAgIGNvbnRyb2wuX3VwZGF0ZVZhbGlkKCk7XG4gICAgICBjb250cm9sLl9zdGF0ZS5tb3VudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRyb2wuX3N0YXRlLndhdGNoKSB7XG4gICAgICBjb250cm9sLl9zdGF0ZS53YXRjaCA9IGZhbHNlO1xuICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSB9KTtcbiAgICB9XG5cbiAgICBjb250cm9sLl9yZW1vdmVVbm1vdW50ZWQoKTtcbiAgfSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcm9wcy5zaG91bGRVbnJlZ2lzdGVyICYmXG4gICAgICBjb250cm9sLl9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICAgIHZhbHVlczogY29udHJvbC5fZ2V0V2F0Y2goKSxcbiAgICAgIH0pO1xuICB9LCBbcHJvcHMuc2hvdWxkVW5yZWdpc3RlciwgY29udHJvbF0pO1xuXG4gIF9mb3JtQ29udHJvbC5jdXJyZW50LmZvcm1TdGF0ZSA9IGdldFByb3h5Rm9ybVN0YXRlKGZvcm1TdGF0ZSwgY29udHJvbCk7XG5cbiAgcmV0dXJuIF9mb3JtQ29udHJvbC5jdXJyZW50O1xufVxuIl0sIm5hbWVzIjpbImlzQ2hlY2tCb3hJbnB1dCIsImVsZW1lbnQiLCJ0eXBlIiwiaXNEYXRlT2JqZWN0IiwidmFsdWUiLCJEYXRlIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc09iamVjdFR5cGUiLCJpc09iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsImdldEV2ZW50VmFsdWUiLCJldmVudCIsInRhcmdldCIsImNoZWNrZWQiLCJnZXROb2RlUGFyZW50TmFtZSIsIm5hbWUiLCJzdWJzdHJpbmciLCJzZWFyY2giLCJpc05hbWVJbkZpZWxkQXJyYXkiLCJuYW1lcyIsImhhcyIsImlzUGxhaW5PYmplY3QiLCJ0ZW1wT2JqZWN0IiwicHJvdG90eXBlQ29weSIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJpc1dlYiIsIndpbmRvdyIsIkhUTUxFbGVtZW50IiwiZG9jdW1lbnQiLCJjbG9uZU9iamVjdCIsImRhdGEiLCJjb3B5IiwiU2V0IiwiQmxvYiIsIkZpbGVMaXN0Iiwia2V5IiwiY29tcGFjdCIsImZpbHRlciIsIkJvb2xlYW4iLCJpc1VuZGVmaW5lZCIsInZhbCIsInVuZGVmaW5lZCIsImdldCIsIm9iamVjdCIsInBhdGgiLCJkZWZhdWx0VmFsdWUiLCJyZXN1bHQiLCJzcGxpdCIsInJlZHVjZSIsImlzQm9vbGVhbiIsImlzS2V5IiwidGVzdCIsInN0cmluZ1RvUGF0aCIsImlucHV0IiwicmVwbGFjZSIsInNldCIsImluZGV4IiwidGVtcFBhdGgiLCJsZW5ndGgiLCJsYXN0SW5kZXgiLCJuZXdWYWx1ZSIsIm9ialZhbHVlIiwiaXNOYU4iLCJFVkVOVFMiLCJCTFVSIiwiRk9DVVNfT1VUIiwiQ0hBTkdFIiwiVkFMSURBVElPTl9NT0RFIiwib25CbHVyIiwib25DaGFuZ2UiLCJvblN1Ym1pdCIsIm9uVG91Y2hlZCIsImFsbCIsIklOUFVUX1ZBTElEQVRJT05fUlVMRVMiLCJtYXgiLCJtaW4iLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJwYXR0ZXJuIiwicmVxdWlyZWQiLCJ2YWxpZGF0ZSIsIkhvb2tGb3JtQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUZvcm1Db250ZXh0IiwidXNlQ29udGV4dCIsIkZvcm1Qcm92aWRlciIsInByb3BzIiwiY2hpbGRyZW4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJnZXRQcm94eUZvcm1TdGF0ZSIsImZvcm1TdGF0ZSIsImNvbnRyb2wiLCJsb2NhbFByb3h5Rm9ybVN0YXRlIiwiaXNSb290IiwiZGVmYXVsdFZhbHVlcyIsIl9kZWZhdWx0VmFsdWVzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfa2V5IiwiX3Byb3h5Rm9ybVN0YXRlIiwiaXNFbXB0eU9iamVjdCIsImtleXMiLCJzaG91bGRSZW5kZXJGb3JtU3RhdGUiLCJmb3JtU3RhdGVEYXRhIiwidXBkYXRlRm9ybVN0YXRlIiwiZmluZCIsImNvbnZlcnRUb0FycmF5UGF5bG9hZCIsInNob3VsZFN1YnNjcmliZUJ5TmFtZSIsInNpZ25hbE5hbWUiLCJleGFjdCIsInNvbWUiLCJjdXJyZW50TmFtZSIsInN0YXJ0c1dpdGgiLCJ1c2VTdWJzY3JpYmUiLCJfcHJvcHMiLCJ1c2VSZWYiLCJjdXJyZW50IiwidXNlRWZmZWN0Iiwic3Vic2NyaXB0aW9uIiwiZGlzYWJsZWQiLCJzdWJqZWN0Iiwic3Vic2NyaWJlIiwibmV4dCIsInVuc3Vic2NyaWJlIiwidXNlRm9ybVN0YXRlIiwibWV0aG9kcyIsInVzZVN0YXRlIiwiX2Zvcm1TdGF0ZSIsIl9tb3VudGVkIiwiX2xvY2FsUHJveHlGb3JtU3RhdGUiLCJpc0RpcnR5IiwiaXNMb2FkaW5nIiwiZGlydHlGaWVsZHMiLCJ0b3VjaGVkRmllbGRzIiwidmFsaWRhdGluZ0ZpZWxkcyIsImlzVmFsaWRhdGluZyIsImlzVmFsaWQiLCJlcnJvcnMiLCJfbmFtZSIsIl91cGRhdGVGb3JtU3RhdGUiLCJfc3ViamVjdHMiLCJzdGF0ZSIsIl91cGRhdGVWYWxpZCIsImlzU3RyaW5nIiwiZ2VuZXJhdGVXYXRjaE91dHB1dCIsIl9uYW1lcyIsImZvcm1WYWx1ZXMiLCJpc0dsb2JhbCIsIndhdGNoIiwiYWRkIiwibWFwIiwiZmllbGROYW1lIiwid2F0Y2hBbGwiLCJ1c2VXYXRjaCIsInZhbHVlcyIsInVwZGF0ZVZhbHVlIiwiX2Zvcm1WYWx1ZXMiLCJfZ2V0V2F0Y2giLCJfcmVtb3ZlVW5tb3VudGVkIiwidXNlQ29udHJvbGxlciIsInNob3VsZFVucmVnaXN0ZXIiLCJpc0FycmF5RmllbGQiLCJhcnJheSIsIl9yZWdpc3RlclByb3BzIiwicmVnaXN0ZXIiLCJydWxlcyIsIl9zaG91bGRVbnJlZ2lzdGVyRmllbGQiLCJfb3B0aW9ucyIsInVwZGF0ZU1vdW50ZWQiLCJmaWVsZCIsIl9maWVsZHMiLCJfZiIsIm1vdW50IiwiX3N0YXRlIiwiYWN0aW9uIiwidW5yZWdpc3RlciIsIl91cGRhdGVEaXNhYmxlZEZpZWxkIiwiZmllbGRzIiwidXNlQ2FsbGJhY2siLCJyZWYiLCJlbG0iLCJmb2N1cyIsInNlbGVjdCIsInNldEN1c3RvbVZhbGlkaXR5IiwibWVzc2FnZSIsInJlcG9ydFZhbGlkaXR5IiwiZmllbGRTdGF0ZSIsImRlZmluZVByb3BlcnRpZXMiLCJpbnZhbGlkIiwiZW51bWVyYWJsZSIsImlzVG91Y2hlZCIsImVycm9yIiwiQ29udHJvbGxlciIsInJlbmRlciIsIlBPU1RfUkVRVUVTVCIsIkZvcm0iLCJtb3VudGVkIiwic2V0TW91bnRlZCIsIm1ldGhvZCIsImhlYWRlcnMiLCJlbmNUeXBlIiwib25FcnJvciIsIm9uU3VjY2VzcyIsInZhbGlkYXRlU3RhdHVzIiwicmVzdCIsInN1Ym1pdCIsImhhc0Vycm9yIiwiaGFuZGxlU3VibWl0IiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImZvcm1EYXRhSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJfYSIsImFwcGVuZCIsInNob3VsZFN0cmluZ2lmeVN1Ym1pc3Npb25EYXRhIiwiaW5jbHVkZXMiLCJyZXNwb25zZSIsImZldGNoIiwiYm9keSIsInN0YXR1cyIsIlN0cmluZyIsImlzU3VibWl0U3VjY2Vzc2Z1bCIsInNldEVycm9yIiwiRnJhZ21lbnQiLCJub1ZhbGlkYXRlIiwiYXBwZW5kRXJyb3JzIiwidmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhIiwidHlwZXMiLCJnZW5lcmF0ZUlkIiwiZCIsInBlcmZvcm1hbmNlIiwibm93IiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJnZXRGb2N1c0ZpZWxkTmFtZSIsIm9wdGlvbnMiLCJzaG91bGRGb2N1cyIsImZvY3VzTmFtZSIsImZvY3VzSW5kZXgiLCJnZXRWYWxpZGF0aW9uTW9kZXMiLCJtb2RlIiwiaXNPblN1Ym1pdCIsImlzT25CbHVyIiwiaXNPbkNoYW5nZSIsImlzT25BbGwiLCJpc09uVG91Y2giLCJpc1dhdGNoZWQiLCJpc0JsdXJFdmVudCIsIndhdGNoTmFtZSIsInNsaWNlIiwiaXRlcmF0ZUZpZWxkc0J5QWN0aW9uIiwiZmllbGRzTmFtZXMiLCJhYm9ydEVhcmx5IiwiY3VycmVudEZpZWxkIiwicmVmcyIsInVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IiLCJmaWVsZEFycmF5RXJyb3JzIiwiaXNGaWxlSW5wdXQiLCJpc0Z1bmN0aW9uIiwiaXNIVE1MRWxlbWVudCIsIm93bmVyIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNNZXNzYWdlIiwiaXNSYWRpb0lucHV0IiwiaXNSZWdleCIsIlJlZ0V4cCIsImRlZmF1bHRSZXN1bHQiLCJ2YWxpZFJlc3VsdCIsImdldENoZWNrYm94VmFsdWUiLCJvcHRpb24iLCJhdHRyaWJ1dGVzIiwiZGVmYXVsdFJldHVybiIsImdldFJhZGlvVmFsdWUiLCJwcmV2aW91cyIsImdldFZhbGlkYXRlRXJyb3IiLCJldmVyeSIsImdldFZhbHVlQW5kTWVzc2FnZSIsInZhbGlkYXRpb25EYXRhIiwidmFsaWRhdGVGaWVsZCIsInNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24iLCJpc0ZpZWxkQXJyYXkiLCJ2YWx1ZUFzTnVtYmVyIiwiaW5wdXRWYWx1ZSIsImlucHV0UmVmIiwiaXNSYWRpbyIsImlzQ2hlY2tCb3giLCJpc1JhZGlvT3JDaGVja2JveCIsImlzRW1wdHkiLCJhcHBlbmRFcnJvcnNDdXJyeSIsImJpbmQiLCJnZXRNaW5NYXhNZXNzYWdlIiwiZXhjZWVkTWF4IiwibWF4TGVuZ3RoTWVzc2FnZSIsIm1pbkxlbmd0aE1lc3NhZ2UiLCJtYXhUeXBlIiwibWluVHlwZSIsImV4Y2VlZE1pbiIsIm1heE91dHB1dCIsIm1pbk91dHB1dCIsInZhbHVlTnVtYmVyIiwidmFsdWVEYXRlIiwidmFsdWVBc0RhdGUiLCJjb252ZXJ0VGltZVRvRGF0ZSIsInRpbWUiLCJ0b0RhdGVTdHJpbmciLCJpc1RpbWUiLCJpc1dlZWsiLCJtYXhMZW5ndGhPdXRwdXQiLCJtaW5MZW5ndGhPdXRwdXQiLCJwYXR0ZXJuVmFsdWUiLCJtYXRjaCIsInZhbGlkYXRlRXJyb3IiLCJ2YWxpZGF0aW9uUmVzdWx0IiwiYXBwZW5kQXQiLCJmaWxsRW1wdHlBcnJheSIsImluc2VydCIsIm1vdmVBcnJheUF0IiwiZnJvbSIsInRvIiwic3BsaWNlIiwicHJlcGVuZEF0IiwicmVtb3ZlQXRJbmRleGVzIiwiaW5kZXhlcyIsImkiLCJ0ZW1wIiwicmVtb3ZlQXJyYXlBdCIsInNvcnQiLCJhIiwiYiIsInN3YXBBcnJheUF0IiwiaW5kZXhBIiwiaW5kZXhCIiwiYmFzZUdldCIsInVwZGF0ZVBhdGgiLCJpc0VtcHR5QXJyYXkiLCJvYmoiLCJ1bnNldCIsInBhdGhzIiwiY2hpbGRPYmplY3QiLCJ1cGRhdGVBdCIsImZpZWxkVmFsdWVzIiwidXNlRmllbGRBcnJheSIsImtleU5hbWUiLCJzZXRGaWVsZHMiLCJfZ2V0RmllbGRBcnJheSIsImlkcyIsIl9maWVsZElkcyIsIl9hY3Rpb25lZCIsImZpZWxkQXJyYXlOYW1lIiwidXBkYXRlVmFsdWVzIiwidXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMiLCJfdXBkYXRlRmllbGRBcnJheSIsImFwcGVuZFZhbHVlIiwiYXJnQSIsInByZXBlbmQiLCJwcmVwZW5kVmFsdWUiLCJyZW1vdmUiLCJpbnNlcnRWYWx1ZSIsImluc2VydEF0IiwiYXJnQiIsInN3YXAiLCJtb3ZlIiwidXBkYXRlIiwiaXRlbSIsImlzU3VibWl0dGVkIiwicmVzb2x2ZXIiLCJfZXhlY3V0ZVNjaGVtYSIsInRoZW4iLCJleGlzdGluZ0Vycm9yIiwicmVWYWxpZGF0ZU1vZGUiLCJjcml0ZXJpYU1vZGUiLCJ1c2VNZW1vIiwiY3JlYXRlU3ViamVjdCIsIl9vYnNlcnZlcnMiLCJvYnNlcnZlciIsInB1c2giLCJvIiwib2JzZXJ2ZXJzIiwiaXNQcmltaXRpdmUiLCJkZWVwRXF1YWwiLCJvYmplY3QxIiwib2JqZWN0MiIsImdldFRpbWUiLCJrZXlzMSIsImtleXMyIiwidmFsMSIsInZhbDIiLCJpc011bHRpcGxlU2VsZWN0IiwibGl2ZSIsImlzQ29ubmVjdGVkIiwib2JqZWN0SGFzRnVuY3Rpb24iLCJtYXJrRmllbGRzRGlydHkiLCJpc1BhcmVudE5vZGVBcnJheSIsImdldERpcnR5RmllbGRzRnJvbURlZmF1bHRWYWx1ZXMiLCJkaXJ0eUZpZWxkc0Zyb21WYWx1ZXMiLCJnZXREaXJ0eUZpZWxkcyIsImdldEZpZWxkVmFsdWVBcyIsInNldFZhbHVlQXMiLCJOYU4iLCJnZXRGaWVsZFZhbHVlIiwiZmlsZXMiLCJzZWxlY3RlZE9wdGlvbnMiLCJnZXRSZXNvbHZlck9wdGlvbnMiLCJnZXRSdWxlVmFsdWUiLCJydWxlIiwic291cmNlIiwiaGFzVmFsaWRhdGlvbiIsInNjaGVtYUVycm9yTG9va3VwIiwiam9pbiIsImZvdW5kRXJyb3IiLCJwb3AiLCJza2lwVmFsaWRhdGlvbiIsInVuc2V0RW1wdHlBcnJheSIsImRlZmF1bHRPcHRpb25zIiwic2hvdWxkRm9jdXNFcnJvciIsImNyZWF0ZUZvcm1Db250cm9sIiwic3VibWl0Q291bnQiLCJpc1N1Ym1pdHRpbmciLCJ1bk1vdW50IiwiZGVsYXlFcnJvckNhbGxiYWNrIiwidGltZXIiLCJ2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCIsInZhbGlkYXRpb25Nb2RlQWZ0ZXJTdWJtaXQiLCJzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycyIsImRlYm91bmNlIiwiY2FsbGJhY2siLCJ3YWl0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInNob3VsZFVwZGF0ZVZhbGlkIiwiZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uIiwiX3VwZGF0ZUlzVmFsaWRhdGluZyIsImZvckVhY2giLCJhcmdzIiwic2hvdWxkU2V0VmFsdWVzIiwic2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUiLCJfZ2V0RGlydHkiLCJ1cGRhdGVFcnJvcnMiLCJfc2V0RXJyb3JzIiwidXBkYXRlVmFsaWRBbmRWYWx1ZSIsInNob3VsZFNraXBTZXRWYWx1ZUFzIiwiZGVmYXVsdENoZWNrZWQiLCJzZXRGaWVsZFZhbHVlIiwidXBkYXRlVG91Y2hBbmREaXJ0eSIsImZpZWxkVmFsdWUiLCJzaG91bGREaXJ0eSIsInNob3VsZFJlbmRlciIsInNob3VsZFVwZGF0ZUZpZWxkIiwiaXNQcmV2aW91c0RpcnR5Iiwib3V0cHV0IiwiZGlzYWJsZWRGaWVsZCIsImlzQ3VycmVudEZpZWxkUHJpc3RpbmUiLCJpc1ByZXZpb3VzRmllbGRUb3VjaGVkIiwic2hvdWxkUmVuZGVyQnlFcnJvciIsInByZXZpb3VzRmllbGRFcnJvciIsImRlbGF5RXJyb3IiLCJ1cGRhdGVkRm9ybVN0YXRlIiwiY29udGV4dCIsImV4ZWN1dGVTY2hlbWFBbmRVcGRhdGVTdGF0ZSIsInNob3VsZE9ubHlDaGVja1ZhbGlkIiwidmFsaWQiLCJpc0ZpZWxkQXJyYXlSb290IiwiZmllbGRFcnJvciIsImdldFZhbHVlcyIsImZpZWxkUmVmZXJlbmNlIiwib3B0aW9uUmVmIiwic2VsZWN0ZWQiLCJjaGVja2JveFJlZiIsInJhZGlvUmVmIiwic2hvdWxkVG91Y2giLCJzaG91bGRWYWxpZGF0ZSIsInRyaWdnZXIiLCJzZXRWYWx1ZXMiLCJmaWVsZEtleSIsInNldFZhbHVlIiwiY2xvbmVWYWx1ZSIsImlzRmllbGRWYWx1ZVVwZGF0ZWQiLCJnZXRDdXJyZW50RmllbGRWYWx1ZSIsIl91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkIiwiTnVtYmVyIiwic2hvdWxkU2tpcFZhbGlkYXRpb24iLCJkZXBzIiwid2F0Y2hlZCIsInByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQiLCJlcnJvckxvb2t1cFJlc3VsdCIsIl9mb2N1c0lucHV0IiwiZmllbGROYW1lcyIsIlByb21pc2UiLCJnZXRGaWVsZFN0YXRlIiwiY2xlYXJFcnJvcnMiLCJpbnB1dE5hbWUiLCJjdXJyZW50RXJyb3IiLCJjdXJyZW50UmVmIiwicmVzdE9mRXJyb3JUcmVlIiwicGF5bG9hZCIsImRlbGV0ZSIsImtlZXBWYWx1ZSIsImtlZXBFcnJvciIsImtlZXBEaXJ0eSIsImtlZXBUb3VjaGVkIiwia2VlcElzVmFsaWRhdGluZyIsImtlZXBEZWZhdWx0VmFsdWUiLCJrZWVwSXNWYWxpZCIsImRpc2FibGVkSXNEZWZpbmVkIiwicHJvZ3Jlc3NpdmUiLCJmaWVsZFJlZiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyYWRpb09yQ2hlY2tib3giLCJfZm9jdXNFcnJvciIsIl9kaXNhYmxlRm9ybSIsIm9uVmFsaWQiLCJvbkludmFsaWQiLCJlIiwib25WYWxpZEVycm9yIiwicHJldmVudERlZmF1bHQiLCJwZXJzaXN0IiwicmVzZXRGaWVsZCIsIl9yZXNldCIsImtlZXBTdGF0ZU9wdGlvbnMiLCJ1cGRhdGVkVmFsdWVzIiwiY2xvbmVVcGRhdGVkVmFsdWVzIiwiaXNFbXB0eVJlc2V0VmFsdWVzIiwia2VlcERlZmF1bHRWYWx1ZXMiLCJrZWVwVmFsdWVzIiwia2VlcERpcnR5VmFsdWVzIiwiZm9ybSIsImNsb3Nlc3QiLCJyZXNldCIsImtlZXBTdWJtaXRDb3VudCIsImtlZXBJc1N1Ym1pdHRlZCIsImtlZXBFcnJvcnMiLCJrZWVwSXNTdWJtaXRTdWNjZXNzZnVsIiwic2V0Rm9jdXMiLCJzaG91bGRTZWxlY3QiLCJfcmVzZXREZWZhdWx0VmFsdWVzIiwicmVzZXRPcHRpb25zIiwidXNlRm9ybSIsIl9mb3JtQ29udHJvbCIsIl92YWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-hook-form/dist/index.esm.mjs\n");

/***/ })

};
;